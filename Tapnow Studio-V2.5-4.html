<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tapnow Studio</title>
    
    <!-- 1. Resource Preconnect & DNS Prefetch -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="https://ai.comfly.chat">
    <link rel="dns-prefetch" href="https://api.midjourney.com">

    <!-- 2. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 3. React & ReactDOM (Defer loading) -->
    <script defer crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script defer crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 4. Babel (Defer loading) -->
    <script defer src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 5. Lucide Icons (Defer loading) -->
    <script defer src="https://unpkg.com/lucide@latest"></script>
    
    <!-- 6. Marked (Defer loading) -->
    <script defer src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        body { margin: 0; padding: 0; background-color: #09090b; }
        /* Prevent selection during drag - applied to canvas only mostly */
        .select-none { user-select: none; }
        /* Allow selection in chat */
        .select-text { user-select: text; }
        
        /* Loader animation fallback */
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .animate-spin { animation: spin 1s linear infinite; }
        
        /* Artistic Minimalist Loader - V2 with Credits */
        .art-loader-container {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #09090b;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* 垂直居中 */
            z-index: 9999;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: #e4e4e7;
        }

        /* 将中间动画打包，确保它稍微偏上一点，给底部留空间 */
        .art-center-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: translateY(-20px); /* 视觉微调 */
        }

        .art-visual {
            position: relative;
            width: 60px;
            height: 60px;
            margin-bottom: 30px;
        }

        .art-ring-outer {
            position: absolute; inset: 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            animation: art-breathe 4s ease-in-out infinite;
        }

        .art-ring-inner {
            position: absolute; inset: 0;
            border-radius: 50%;
            border: 1px solid transparent;
            border-top-color: #fff;
            border-left-color: rgba(255,255,255,0.3);
            opacity: 0.8;
            animation: art-spin 2s cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        .art-dot {
            position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px;
            background-color: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .art-title {
            font-size: 12px; font-weight: 300;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            opacity: 0.9; margin-bottom: 8px;
        }

        .art-status {
            font-family: 'Courier New', monospace;
            font-size: 10px; color: #71717a;
            letter-spacing: 0.1em;
            animation: art-pulse 2s ease-in-out infinite;
        }

        /* --- 底部署名区域样式 --- */
        .art-footer {
            position: absolute;
            bottom: 40px; /* 距离底部 */
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 12px;
            opacity: 0; /* 初始隐藏 */
            animation: art-fade-up 1s ease-out 0.5s forwards; /* 延迟淡入 */
        }

        .footer-author {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .footer-author .label {
            font-size: 9px;
            color: #52525b;
            text-transform: uppercase;
            letter-spacing: 0.2em;
        }

        .footer-author .name {
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.5em; /* 名字字间距拉大，极显逼格 */
            color: #fff;
            text-indent: 0.5em; /* 修正字间距带来的视觉中心偏移 */
        }

        .footer-divider {
            width: 20px;
            height: 1px;
            background-color: #27272a;
        }

        .footer-thanks {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .footer-thanks .label {
            font-size: 8px;
            color: #3f3f46;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .footer-thanks .content {
            font-size: 10px;
            color: #71717a;
            font-family: 'Courier New', monospace; /* 致谢使用代码字体 */
        }

        .footer-thanks .highlight {
            color: #a1a1aa;
            font-weight: 600;
        }

        /* 动画定义 */
        @keyframes art-spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes art-breathe { 0%, 100% { transform: scale(1); opacity: 0.5; } 50% { transform: scale(1.1); opacity: 0.2; } }
        @keyframes art-pulse { 0%, 100% { opacity: 0.4; } 50% { opacity: 0.8; } }
        @keyframes art-fade-up { 
            from { opacity: 0; transform: translateY(10px); } 
            to { opacity: 1; transform: translateY(0); } 
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="art-loader-container">
            <div class="art-center-group">
                <div class="art-visual">
                    <div class="art-ring-outer"></div>
                    <div class="art-ring-inner"></div>
                    <div class="art-dot"></div>
                </div>
                <div class="art-content">
                    <div class="art-title">Tapnow Studio</div>
                    <div class="art-status">Loading Resources</div>
                </div>
            </div>

            <div class="art-footer">
                <div class="footer-author">
                    <span class="label">Created by</span>
                    <span class="name">桥豆麻衣酱</span>
                </div>
                <div class="footer-divider"></div>
                <div class="footer-thanks">
                    <span class="label">Special Thanks</span>
                    <span class="content">
                        <span class="highlight">@MrWhte-s</span> for Maintenance & Suggestions
                    </span>
                </div>
            </div>
        </div>
    </div>

    <script type="text/babel" data-presets="env,react">
        // 全局屏蔽滚轮事件相关的控制台错误（在 React 渲染之前设置）
        (function() {
            const originalError = console.error;
            const originalWarn = console.warn;
            const originalLog = console.log;
            
            const shouldFilter = (args) => {
                // 检查所有参数，包括字符串、对象、错误等
                for (let arg of args) {
                    let msg = '';
                    if (typeof arg === 'string') {
                        msg = arg;
                    } else if (arg && typeof arg === 'object') {
                        // 检查错误对象的 message 属性
                        if (arg.message) msg = arg.message;
                        else if (arg.toString) msg = arg.toString();
                        else msg = JSON.stringify(arg);
                    } else if (arg != null) {
                        msg = String(arg);
                    }
                    
                    // 精确匹配 passive 事件监听器相关的错误
                    if (msg.includes('Unable to preventDefault inside passive event listener') ||
                        msg.includes('passive event listener invocation') ||
                        (msg.includes('preventDefault') && msg.includes('passive'))) {
                        return true;
                    }
                }
                return false;
            };
            
            console.error = function(...args) {
                if (shouldFilter(args)) return;
                originalError.apply(console, args);
            };
            
            console.warn = function(...args) {
                if (shouldFilter(args)) return;
                originalWarn.apply(console, args);
            };
            
            console.log = function(...args) {
                if (shouldFilter(args)) return;
                originalLog.apply(console, args);
            };
        })();

        const { useState, useRef, useEffect, useCallback, useMemo, memo } = React;

        // --- ICON SYSTEM ADAPTER (Optimized with memo) ---
        const IconWrapper = React.memo(({ name, size = 24, className = "", ...props }) => {
            const iconData = lucide.icons[name];
            if (!iconData) return null;
            
            return React.createElement('svg', {
                xmlns: "http://www.w3.org/2000/svg",
                width: size,
                height: size,
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: 2,
                strokeLinecap: "round",
                strokeLinejoin: "round",
                className: `lucide lucide-${name} ${className}`,
                ...props
            }, ...iconData.map(([tag, attrs]) => React.createElement(tag, attrs)));
        });

        const Plus = (p) => <IconWrapper name="Plus" {...p} />;
        const ImageIcon = (p) => <IconWrapper name="Image" {...p} />;
        const Video = (p) => <IconWrapper name="Video" {...p} />;
        const Settings = (p) => <IconWrapper name="Settings" {...p} />;
        const X = (p) => <IconWrapper name="X" {...p} />;
        const Play = (p) => <IconWrapper name="Play" {...p} />;
        const Layers = (p) => <IconWrapper name="Layers" {...p} />;
        const MousePointer2 = (p) => <IconWrapper name="MousePointer2" {...p} />;
        const Wand2 = (p) => <IconWrapper name="Wand2" {...p} />;
        const Loader2 = (p) => <IconWrapper name="Loader2" {...p} />;
        const LinkIcon = (p) => <IconWrapper name="Link" {...p} />;
        const History = (p) => <IconWrapper name="History" {...p} />;
        const ImagePlus = (p) => <IconWrapper name="ImagePlus" {...p} />;
        const Trash2 = (p) => <IconWrapper name="Trash2" {...p} />;
        const CheckCircle2 = (p) => <IconWrapper name="CheckCircle2" {...p} />;
        const Unlink = (p) => <IconWrapper name="Unlink" {...p} />;
        const CopyPlus = (p) => <IconWrapper name="CopyPlus" {...p} />;
        const ArrowRightSquare = (p) => <IconWrapper name="ArrowRightSquare" {...p} />;
        const MessageSquare = (p) => <IconWrapper name="MessageSquare" {...p} />;
        const Send = (p) => <IconWrapper name="Send" {...p} />;
        const Paperclip = (p) => <IconWrapper name="Paperclip" {...p} />;
        const FileText = (p) => <IconWrapper name="FileText" {...p} />;
        const FileAudio = (p) => <IconWrapper name="FileAudio" {...p} />;
        const FileVideo = (p) => <IconWrapper name="FileVideo" {...p} />;
        const FileImage = (p) => <IconWrapper name="FileImage" {...p} />;
        const ChevronRight = (p) => <IconWrapper name="ChevronRight" {...p} />;
        const ChevronLeft = (p) => <IconWrapper name="ChevronLeft" {...p} />;
        const MoreHorizontal = (p) => <IconWrapper name="MoreHorizontal" {...p} />;
        const Bot = (p) => <IconWrapper name="Bot" {...p} />;
        const User = (p) => <IconWrapper name="User" {...p} />;
        const Users = (p) => <IconWrapper name="Users" {...p} />;
        const GripVertical = (p) => <IconWrapper name="GripVertical" {...p} />;
        const Forward = (p) => <IconWrapper name="Forward" {...p} />;
        const RefreshCw = (p) => <IconWrapper name="RefreshCw" {...p} />;
        const Split = (p) => <IconWrapper name="Split" {...p} />;
        const Maximize2 = (p) => <IconWrapper name="Maximize2" {...p} />;
        const Sun = (p) => <IconWrapper name="Sun" {...p} />;
        const Moon = (p) => <IconWrapper name="Moon" {...p} />;
        const FileSearch = (p) => <IconWrapper name="FileSearch" {...p} />;
        const Sparkles = (p) => <IconWrapper name="Sparkles" {...p} />;
        const Mic = (p) => <IconWrapper name="Mic" {...p} />;
        const Mic2 = (p) => <IconWrapper name="Mic2" {...p} />;
        const Camera = (p) => <IconWrapper name="Camera" {...p} />;
        const Code = (p) => <IconWrapper name="Code" {...p} />;
        const ClipboardCopy = (p) => <IconWrapper name="ClipboardCopy" {...p} />;
        const Edit = (p) => <IconWrapper name="Edit" {...p} />;
        const LayoutGrid = (p) => <IconWrapper name="LayoutGrid" {...p} />;
        const Check = (p) => <IconWrapper name="Check" {...p} />;
        const CheckSquare = (p) => <IconWrapper name="CheckSquare" {...p} />;
        const Eye = (p) => <IconWrapper name="Eye" {...p} />;
        const Scissors = (p) => <IconWrapper name="Scissors" {...p} />;
        const Layout = (p) => <IconWrapper name="Layout" {...p} />;
        const Download = (p) => <IconWrapper name="Download" {...p} />;
        const Save = (p) => <IconWrapper name="Save" {...p} />;
        const FolderOpen = (p) => <IconWrapper name="FolderOpen" {...p} />;
        const Brush = (p) => <IconWrapper name="Brush" {...p} />;
        const Undo2 = (p) => <IconWrapper name="Undo2" {...p} />;
        const Eraser = (p) => <IconWrapper name="Eraser" {...p} />;

        // --- MaskVisualFeedback 组件：蒙版视觉反馈层 ---
        const MaskVisualFeedback = ({ canvasRef, isDrawing }) => {
            const [maskUrl, setMaskUrl] = useState('');
            const rafRef = useRef(null);
            
            const updateMask = useCallback(() => {
                if (canvasRef.current) {
                    setMaskUrl(canvasRef.current.toDataURL());
                }
            }, [canvasRef]);
            
            // 初始更新
            useEffect(() => {
                if (!canvasRef.current) return;
                updateMask();
            }, [canvasRef, updateMask]);
            
            // 仅在绘制时使用 requestAnimationFrame 更新
            useEffect(() => {
                if (!isDrawing) {
                    // 绘制结束时更新一次
                    updateMask();
                    return;
                }
                
                // 绘制中：使用 requestAnimationFrame 更新
                const animate = () => {
                    updateMask();
                    if (isDrawing) {
                        rafRef.current = requestAnimationFrame(animate);
                    }
                };
                
                rafRef.current = requestAnimationFrame(animate);
                
                return () => {
                    if (rafRef.current) {
                        cancelAnimationFrame(rafRef.current);
                    }
                };
            }, [isDrawing, updateMask]);
            
            if (!maskUrl) return null;
            
            return (
                <div
                    className="absolute inset-0 pointer-events-none"
                    style={{
                        background: 'rgba(255, 0, 0, 0.3)',
                        mixBlendMode: 'multiply',
                        WebkitMaskImage: `url(${maskUrl})`,
                        maskImage: `url(${maskUrl})`,
                        WebkitMaskSize: '100% 100%',
                        maskSize: '100% 100%',
                        WebkitMaskRepeat: 'no-repeat',
                        maskRepeat: 'no-repeat',
                    }}
                />
            );
        };

        // --- LazyBase64Image 组件：将 Base64 转换为 Blob URL 的智能图片组件 ---
        const LazyBase64Image = ({ src, className, alt, onError, onLoad, ...props }) => {
            const [blobUrl, setBlobUrl] = useState(null);
            const [error, setError] = useState(false);
            const blobUrlRef = useRef(null);

            useEffect(() => {
                // 如果已经是 Blob URL 或 HTTP URL，直接使用
                if (!src || src.startsWith('blob:') || src.startsWith('http://') || src.startsWith('https://')) {
                    setBlobUrl(src);
                    return;
                }

                // 如果是 Base64 Data URL，转换为 Blob URL
                if (src.startsWith('data:')) {
                    const convertToBlobUrl = async () => {
                        try {
                            const res = await fetch(src);
                            const blob = await res.blob();
                            const url = URL.createObjectURL(blob);
                            blobUrlRef.current = url;
                            setBlobUrl(url);
                        } catch (err) {
                            console.error('Base64转Blob失败', err);
                            setError(true);
                            setBlobUrl(src); // 失败时使用原始数据
                        }
                    };
                    convertToBlobUrl();
                } else {
                    setBlobUrl(src);
                }

                // 清理函数：组件卸载时释放 Blob URL
                return () => {
                    if (blobUrlRef.current && blobUrlRef.current.startsWith('blob:')) {
                        URL.revokeObjectURL(blobUrlRef.current);
                        blobUrlRef.current = null;
                    }
                };
            }, [src]);

            if (error && !blobUrl) {
                return null;
            }

            return (
                <img
                    src={blobUrl || src}
                    className={className}
                    alt={alt}
                    onError={onError}
                    onLoad={onLoad}
                    {...props}
                />
            );
        };

        // --- HistoryItem 组件：历史记录项，使用 React.memo 优化 ---
        const HistoryItem = memo(({ 
            item, 
            theme, 
            lightboxItem, 
            onDelete, 
            onClick, 
            onContextMenu, 
            onImageClick, 
            onImageContextMenu,
            onRefresh,
            Loader2,
            Trash2,
            RefreshCw
        }) => {
            return (
                <div
                    className={`group rounded-lg overflow-hidden border relative cursor-pointer hover:border-blue-500/50 transition-colors ${
                        theme === 'dark' ? 'bg-zinc-900 border-zinc-800' : 'bg-white border-zinc-200'
                    }`}
                    style={{
                        contentVisibility: 'auto',
                        containIntrinsicSize: '1px 300px'
                    }}
                    onClick={onClick}
                    onContextMenu={onContextMenu}
                >
                    <div className={`bg-black relative ${
                        ((item.mjImages && (item.mjImages.length === 4 || item.mjImages.length > 1)) || (item.mjNeedsSplit && item.apiConfig?.modelId?.includes('mj')))
                            ? (() => {
                                const ratio = item.mjRatio || '1:1';
                                if (ratio === '16:9') return 'aspect-video';
                                if (ratio === '9:16') return 'aspect-[9/16]';
                                if (ratio === '4:3') return 'aspect-[4/3]';
                                if (ratio === '3:4') return 'aspect-[3/4]';
                                if (ratio === '21:9') return 'aspect-[21/9]';
                                return 'aspect-square';
                            })()
                            : 'aspect-video'
                    }`}>
                        {item.status === 'completed' ? (
                            item.mjImages && (item.mjImages.length === 4 || item.mjImages.length > 1) ? (
                                <div className={`w-full h-full grid gap-0.5 p-0.5 ${item.mjImages.length === 4 ? 'grid-cols-2 grid-rows-2' : 'grid-cols-2'}`}>
                                    {item.mjImages.map((imgUrl, idx) => {
                                        const imgInfo = item.mjImageInfo && item.mjImageInfo[idx];
                                        return (
                                            <div
                                                key={idx}
                                                onClick={(e) => onImageClick && onImageClick(e, item, imgUrl, idx)}
                                                onContextMenu={(e) => onImageContextMenu && onImageContextMenu(e, item, imgUrl, idx)}
                                                className={`relative w-full h-full cursor-pointer border-2 transition-all overflow-hidden ${
                                                    item.selectedMjImageIndex === idx && lightboxItem && lightboxItem.id === item.id
                                                        ? 'border-blue-500 scale-95'
                                                        : 'border-transparent hover:border-blue-500/50'
                                                }`}
                                            >
                                                <LazyBase64Image
                                                    src={imgUrl}
                                                    loading="lazy"
                                                    className="w-full h-full object-contain"
                                                    alt={`生成图 ${idx + 1}`}
                                                    onError={(e) => {
                                                        console.error(`图片 ${idx + 1} 加载失败`);
                                                        e.target.style.display = 'none';
                                                    }}
                                                />
                                                {item.selectedMjImageIndex === idx && lightboxItem && lightboxItem.id === item.id && (
                                                    <div className="absolute top-1 right-1 w-3 h-3 bg-blue-500 rounded-full flex items-center justify-center z-10">
                                                        <svg className="w-2 h-2 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                            <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                                                        </svg>
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            ) : (
                                item.type === 'image' ? (
                                    <LazyBase64Image
                                        src={item.url || item.mjOriginalUrl}
                                        loading="lazy"
                                        className="w-full h-full object-cover"
                                        alt={item.prompt || '生成的图片'}
                                        onError={(e) => {
                                            console.error('图片加载失败:', item.url || item.mjOriginalUrl);
                                            e.target.style.display = 'none';
                                        }}
                                    />
                                ) : (
                                    <video
                                        src={item.url}
                                        className="w-full h-full object-cover"
                                        muted
                                        loop
                                        playsInline
                                        onError={(e) => {
                                            console.error('视频加载失败:', item.url);
                                        }}
                                    />
                                )
                            )
                        ) : (
                            <div className="w-full h-full flex items-center justify-center">
                                <Loader2 className="animate-spin text-zinc-600" />
                            </div>
                        )}
                        <div className="absolute bottom-0 left-0 right-0 h-1 bg-zinc-800">
                            <div className="h-full bg-blue-500 transition-all" style={{ width: `${item.progress}%` }}></div>
                        </div>
                    </div>
                    <div className="p-2">
                        <div className="flex justify-between items-start gap-2">
                            <p
                                className={`text-[10px] line-clamp-1 flex-1 ${
                                    theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'
                                }`}
                            >
                                {item.prompt}
                            </p>
                            <button
                                onClick={(e) => { e.stopPropagation(); onDelete && onDelete(item.id); }}
                                className={`shrink-0 p-0.5 mr-1 ${
                                    theme === 'dark'
                                        ? 'text-zinc-500 hover:text-red-500'
                                        : 'text-zinc-400 hover:text-red-500'
                                }`}
                                title="删除"
                            >
                                <Trash2 size={12} />
                            </button>
                            {item.type === 'video' && (item.status === 'generating' || item.status === 'failed') && (
                                <button
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onRefresh && onRefresh(item);
                                    }}
                                    className={`shrink-0 p-0.5 ${
                                        theme === 'dark'
                                            ? 'text-zinc-500 hover:text-white'
                                            : 'text-zinc-400 hover:text-zinc-900'
                                    }`}
                                    title="刷新状态"
                                >
                                    <RefreshCw size={12} />
                                </button>
                            )}
                        </div>
                        {item.status === 'failed' && item.errorMsg && (
                            <p className="text-[9px] text-red-500 mt-1 break-words whitespace-pre-wrap">
                                {item.errorMsg.split('\n').map((line, idx) => (
                                    <span key={idx}>
                                        {line}
                                        {idx < item.errorMsg.split('\n').length - 1 && <br />}
                                    </span>
                                ))}
                            </p>
                        )}
                        {item.status === 'generating' && (
                            <p className="text-[9px] text-blue-500 mt-1">
                                {item.errorMsg || '生成中...'}
                            </p>
                        )}
                    </div>
                    <div className="flex items-center justify-between px-3 py-2 text-[11px]">
                        <div className="flex flex-col">
                            <span className={theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}>
                                {item.prompt?.slice(0, 40) || 'Untitled'}
                                {item.prompt && item.prompt.length > 40 ? '…' : ''}
                            </span>
                            <span className={theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}>
                                {item.time} · {item.modelName}
                                {typeof item.durationMs === 'number' && item.durationMs > 0 && (
                                    <> · 用时 {(item.durationMs / 1000).toFixed(1)}s</>
                                )}
                            </span>
                        </div>
                    </div>
                </div>
            );
        }, (prevProps, nextProps) => {
            // 自定义对比函数：只检查关键属性变化
            return (
                prevProps.item === nextProps.item &&
                prevProps.theme === nextProps.theme &&
                prevProps.lightboxItem?.id === nextProps.lightboxItem?.id
            );
        });

        // --- MaskEditor 组件：图片标注/局部重绘 ---
        const MaskEditor = ({ nodeId, imageUrl, imageDimensions, isActive, onClose, onSave, theme, view, maskContent, onUpdateNode }) => {
            const canvasRef = useRef(null);
            const ctxRef = useRef(null);
            const [brushSize, setBrushSize] = useState(30);
            const [isDrawing, setIsDrawing] = useState(false);
            const [history, setHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const maxHistory = 10;

            // 初始化 Canvas
            useEffect(() => {
                if (!isActive || !canvasRef.current || !imageDimensions) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                ctxRef.current = ctx;
                
                // 设置 Canvas 尺寸为图片原始分辨率
                canvas.width = imageDimensions.w;
                canvas.height = imageDimensions.h;
                
                // 清空画布（透明背景）
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 如果有保存的蒙版，恢复它
                if (maskContent) {
                    const img = new Image();
                    img.onload = () => {
                        ctx.drawImage(img, 0, 0);
                        saveToHistory();
                    };
                    img.src = maskContent;
                } else {
                    saveToHistory();
                }
            }, [isActive, imageDimensions, nodeId, maskContent]);

            // 保存当前状态到历史记录
            const saveToHistory = () => {
                if (!canvasRef.current || !ctxRef.current) return;
                const canvas = canvasRef.current;
                const ctx = ctxRef.current;
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push(imageData);
                if (newHistory.length > maxHistory) {
                    newHistory.shift();
                }
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
            };

            // 获取鼠标在 Canvas 上的真实像素坐标
            const getCanvasCoordinates = (e) => {
                if (!canvasRef.current) return null;
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                
                // 使用 getBoundingClientRect 获取 Canvas 在视口中的绝对位置
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // 计算缩放比例（图片原始尺寸 / DOM 显示尺寸）
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                // 映射回真实像素坐标
                return {
                    x: Math.round(x * scaleX),
                    y: Math.round(y * scaleY)
                };
            };

            // 绘制函数
            const draw = (e) => {
                if (!isDrawing || !canvasRef.current || !ctxRef.current) return;
                const coords = getCanvasCoordinates(e);
                if (!coords) return;
                
                const ctx = ctxRef.current;
                
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = '#FFFFFF'; // 白色（蒙版标准格式）
                ctx.beginPath();
                ctx.arc(coords.x, coords.y, brushSize / 2, 0, Math.PI * 2);
                ctx.fill();
            };

            // 鼠标事件处理
            const handleMouseDown = (e) => {
                if (e.button !== 0) return; // 只处理左键
                e.preventDefault();
                e.stopPropagation();
                setIsDrawing(true);
                saveToHistory();
                draw(e);
            };

            const handleMouseMove = (e) => {
                if (!isDrawing) return;
                e.preventDefault();
                e.stopPropagation();
                draw(e);
            };

            const handleMouseUp = (e) => {
                if (!isDrawing) return;
                e.preventDefault();
                e.stopPropagation();
                setIsDrawing(false);
                saveToHistory();
            };

            // 撤销
            const handleUndo = () => {
                if (historyIndex <= 0 || !canvasRef.current || !ctxRef.current) return;
                const newIndex = historyIndex - 1;
                setHistoryIndex(newIndex);
                const ctx = ctxRef.current;
                ctx.putImageData(history[newIndex], 0, 0);
            };

            // 清空
            const handleClear = () => {
                if (!canvasRef.current || !ctxRef.current) return;
                const ctx = ctxRef.current;
                ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                saveToHistory();
            };

            // 保存蒙版
            const handleSave = () => {
                if (!canvasRef.current) return;
                const canvas = canvasRef.current;
                const maskDataUrl = canvas.toDataURL('image/png');
                
                // 更新节点状态
                if (onUpdateNode) {
                    onUpdateNode(nodeId, { maskContent: maskDataUrl, isMasking: false });
                }
                
                if (onSave) onSave(maskDataUrl);
                if (onClose) onClose();
            };

            // 键盘快捷键：Ctrl+Z 撤销
            useEffect(() => {
                if (!isActive) return;
                const handleKeyDown = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        handleUndo();
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [isActive, historyIndex, history]);

            if (!isActive || !imageUrl || !imageDimensions) return null;

            return (
                <div 
                    className="absolute inset-0 z-50 pointer-events-auto"
                    style={{ 
                        mixBlendMode: 'normal',
                    }}
                    onMouseDown={(e) => e.stopPropagation()}
                    onMouseMove={(e) => e.stopPropagation()}
                    onMouseUp={(e) => e.stopPropagation()}
                >
                    {/* Canvas 层：用于绘制蒙版 */}
                    <canvas
                        ref={canvasRef}
                        className="absolute inset-0 w-full h-full"
                        style={{
                            opacity: 0.5,
                            mixBlendMode: 'multiply',
                            cursor: 'crosshair',
                            pointerEvents: 'auto',
                            imageRendering: 'pixelated'
                        }}
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseUp}
                    />
                    
                    {/* 视觉反馈层：半透明红色覆盖 - 使用 Canvas 作为 mask */}
                    <MaskVisualFeedback canvasRef={canvasRef} isDrawing={isDrawing} />
                    
                    {/* 工具栏 - 底部居中悬浮 */}
                    <div
                        className={`absolute bottom-4 left-1/2 -translate-x-1/2 flex flex-row items-center gap-4 p-2 rounded-full border backdrop-blur-md shadow-xl ${
                            theme === 'dark'
                                ? 'bg-zinc-900/90 border-zinc-700 text-zinc-200'
                                : 'bg-white/90 border-zinc-300 text-zinc-800'
                        }`}
                        onMouseDown={(e) => e.stopPropagation()}
                    >
                        {/* 笔刷粗细 */}
                        <div className="flex items-center gap-2">
                            <span className="text-[10px] font-medium whitespace-nowrap">笔刷</span>
                            <input
                                type="range"
                                min="10"
                                max="100"
                                value={brushSize}
                                onChange={(e) => setBrushSize(Number(e.target.value))}
                                className="w-20"
                                onMouseDown={(e) => e.stopPropagation()}
                            />
                            <span className="text-[10px] w-8 text-right whitespace-nowrap">{brushSize}px</span>
                        </div>
                        
                        {/* 按钮组 */}
                        <div className="flex items-center gap-1">
                            <button
                                onClick={handleUndo}
                                disabled={historyIndex <= 0}
                                className={`p-1.5 rounded-full transition-colors ${
                                    theme === 'dark'
                                        ? 'hover:bg-zinc-800 disabled:opacity-50 disabled:cursor-not-allowed'
                                        : 'hover:bg-zinc-100 disabled:opacity-50 disabled:cursor-not-allowed'
                                }`}
                                title="撤销 (Ctrl+Z)"
                            >
                                <Undo2 size={14} />
                            </button>
                            <button
                                onClick={handleClear}
                                className={`p-1.5 rounded-full transition-colors ${
                                    theme === 'dark'
                                        ? 'hover:bg-zinc-800'
                                        : 'hover:bg-zinc-100'
                                }`}
                                title="清空"
                            >
                                <Eraser size={14} />
                            </button>
                            <button
                                onClick={handleSave}
                                className="p-1.5 rounded-full bg-blue-600 hover:bg-blue-500 text-white transition-colors"
                                title="保存/完成"
                            >
                                <Check size={14} />
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- 自定义样式 ---
        const styles = `
        /* 全局字体渲染优化 */
        * {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }
        
        /* 画布容器渲染优化 */
        #canvas-bg {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        
        /* 画布内容容器优化 */
        #canvas-bg > div[style*="transform"] {
            transform: translateZ(0);
            will-change: transform;
        }
        
        /* 节点容器优化 */
        .node-wrapper {
            transform: translateZ(0);
            backface-visibility: hidden;
            contain: layout style;
            will-change: transform, left, top;
        }
        
        /* 节点内图片渲染优化 - 使用高质量渲染 */
        .node-wrapper img,
        .node-wrapper video {
            image-rendering: auto;
            image-rendering: -webkit-optimize-contrast;
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            pointer-events: none;
        }
        
        /* 连接线优化 */
        svg {
            shape-rendering: geometricPrecision;
            text-rendering: optimizeLegibility;
        }
        
        /* 高性能模式：当节点数量超过阈值时自动启用 */
        .perf-mode .node-wrapper {
            box-shadow: none !important;
            backdrop-filter: none !important;
            border-radius: 0 !important;
            transition: none !important;
        }
        .perf-mode .connection-group {
            opacity: 1 !important;
        }
        
        /* 交互时动态降级：拖拽或缩放时降低渲染质量 */
        .interacting .node-wrapper img {
            image-rendering: pixelated;
        }
        .interacting .connection-group {
            display: none;
            pointer-events: none;
        }
        
        .custom-scrollbar::-webkit-scrollbar { width: 4px; height: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 2px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #52525b; }
        .resize-handle { cursor: nwse-resize; opacity: 0; transition: opacity 0.2s; }
        .node-wrapper:hover .resize-handle { opacity: 1; }
        
        /* 连接点样式 */
        .connector { position: absolute; top: 50%; transform: translateY(-50%); width: 0.9rem; height: 0.9rem; background-color: #27272a; border: 1px solid #71717a; color: #a1a1aa; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: crosshair; transition: all 0.2s; z-index: 30; opacity: 0; pointer-events: auto; }
        .node-wrapper:hover .connector { opacity: 1; }
        .connector:hover, .connector.active { background-color: #d4d4d8; border-color: #fff; transform: translateY(-50%) scale(1.2); opacity: 1; color: #000; }
        .connector-right { right: -0.45rem; }
        
        /* 输入点样式 */
        .input-point { position: absolute; top: 50%; transform: translateY(-50%); left: -0.25rem; width: 0.5rem; height: 0.5rem; background-color: #52525b; border-radius: 50%; border: 1px solid #18181b; transition: all 0.2s; z-index: 20; cursor: crosshair; }
        .node-wrapper:hover .input-point { background-color: #a1a1aa; }
        .input-point.connected { background-color: #60a5fa; box-shadow: 0 0 6px #60a5fa; }
        .input-point.active { background-color: #60a5fa; border-color: #fff; transform: translateY(-50%) scale(1.3); box-shadow: 0 0 8px #60a5fa; }

        /* Lightbox & Overlay */
        .lightbox-overlay { background-color: rgba(0, 0, 0, 0.95); backdrop-filter: blur(5px); }
        
        /* Stack Items */
        .thumb-stack-item {
             transition: transform 0.2s, z-index 0.2s;
        }
        .thumb-stack-item:hover {
            transform: scale(1.1) translateY(-2px);
            z-index: 10 !important;
            border-color: #60a5fa;
        }

        /* 连接线删除按钮 */
        .connection-delete {
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: auto; /* 关键：确保鼠标能交互 */
        }
        /* 当鼠标悬停在整个连接组（包含粗透明线）时显示 */
        .connection-group:hover .connection-delete {
            opacity: 1;
        }

        /* 拖放区域样式 */
        .drop-zone {
            border: 2px dashed transparent;
            transition: all 0.3s;
        }
        .drop-zone.drag-over {
            border-color: #60a5fa;
            background-color: rgba(96, 165, 250, 0.1);
        }

        /* Markdown Styles for Chat */
        .markdown-body { font-size: 13px; line-height: 1.5; color: #e4e4e7; word-wrap: break-word; }
        .markdown-body pre { background: #27272a; padding: 10px; border-radius: 6px; overflow-x: auto; margin: 8px 0; white-space: pre-wrap; word-wrap: break-word; }
        .markdown-body code { font-family: monospace; background: #3f3f46; padding: 2px 4px; border-radius: 4px; font-size: 12px; }
        .markdown-body pre code { background: transparent; padding: 0; color: #a1a1aa; }
        .markdown-body p { margin-bottom: 8px; }
        .markdown-body ul, .markdown-body ol { margin-left: 20px; margin-bottom: 8px; list-style: disc; }
        .markdown-body video { max-width: 100%; border-radius: 0.5rem; margin-top: 0.5rem; }
        .markdown-body table { border-collapse: collapse; width: 100%; margin: 12px 0; }
        .markdown-body table th, .markdown-body table td { border: 1px solid #3f3f46; padding: 8px 12px; text-align: left; }
        .markdown-body table th { background-color: #3f3f46; font-weight: 600; }
        .markdown-body table tr:nth-child(even) { background-color: #27272a; }
        .theme-light .markdown-body table th, .theme-light .markdown-body table td { border-color: #d4d4d8; }
        .theme-light .markdown-body table th { background-color: #e4e4e7; }
        .theme-light .markdown-body table tr:nth-child(even) { background-color: #f4f4f5; }
        .theme-light .markdown-body { color: #18181b; }
        .theme-light .markdown-body pre { background: #f4f4f5; color: #18181b; }
        .theme-light .markdown-body code { background: #e4e4e7; color: #18181b; }
        .theme-light .markdown-body pre code { color: #18181b; }
        `;

        // --- 虚拟画布尺寸 ---
        const VIRTUAL_CANVAS_WIDTH = 4000;
        const VIRTUAL_CANVAS_HEIGHT = 4000;

        // --- 默认配置 ---
        const DEFAULT_BASE_URL = 'https://ai.comfly.chat';
        
        // 即梦API配置（代理地址，默认本地5100端口）
        const JIMENG_API_BASE_URL = 'http://localhost:5100';
        const JIMENG_SESSION_ID = '7a16459fbd65d9c87b4ea44d3318f5fa';

        const DEFAULT_API_CONFIGS = [
            // Chat Models
            { id: 'gemini-3-pro', provider: 'Gemini 3 Pro', modelName: 'gemini-3-pro-preview', type: 'Chat', key: '', url: DEFAULT_BASE_URL },
            { id: 'gpt-5-1', provider: 'GPT 5.1', modelName: 'gpt-5.1', type: 'Chat', key: '', url: DEFAULT_BASE_URL },
            { id: 'gpt-5-2', provider: 'GPT 5.2', modelName: 'gpt-5.2', type: 'Chat', key: '', url: DEFAULT_BASE_URL },
            { id: 'deepseek-v3', provider: 'DeepSeek V3', modelName: 'deepseek-v3-1-250821', type: 'Chat', key: '', url: DEFAULT_BASE_URL },
            { id: 'gpt-4o', provider: 'GPT-4o', modelName: 'gpt-4o', type: 'Chat', key: '', url: DEFAULT_BASE_URL },
            
            // Image Models
            { id: 'nano-banana', provider: 'Nano Banana', modelName: 'nano-banana', type: 'Image', key: '', url: DEFAULT_BASE_URL },
            { id: 'nano-banana-2', provider: 'Nano Banana 2', modelName: 'nano-banana-2', type: 'Image', key: '', url: DEFAULT_BASE_URL },
            { id: 'gpt-image', provider: 'GPT-4o Image', modelName: 'gpt-4o-image', type: 'Image', key: '', url: DEFAULT_BASE_URL },
            { id: 'flux-kontext', provider: 'Flux Kontext', modelName: 'flux-kontext-pro', type: 'Image', key: '', url: DEFAULT_BASE_URL },
            { id: 'mj-v6', provider: 'Midjourney', modelName: 'MJ V6', type: 'Image', key: '', url: 'https://api.midjourney.com' },
            // 即梦模型（使用sessionid作为key，首次打开时为空，需要用户输入）
            { id: 'jimeng-4.5', provider: 'Jimeng 4.5', modelName: 'jimeng-4.5', type: 'Image', key: '', url: JIMENG_API_BASE_URL },
            { id: 'jimeng-4.1', provider: 'Jimeng 4.1', modelName: 'jimeng-4.1', type: 'Image', key: '', url: JIMENG_API_BASE_URL },
            { id: 'jimeng-3.1', provider: 'Jimeng 3.1', modelName: 'jimeng-3.1', type: 'Image', key: '', url: JIMENG_API_BASE_URL },
            
            // Video Models
            { id: 'sora-2', provider: 'Sora 2', modelName: 'sora-2', type: 'Video', key: '', url: DEFAULT_BASE_URL, durations: ['5s', '10s', '15s'] },
            { id: 'sora-2-pro', provider: 'Sora 2 Pro', modelName: 'sora-2-pro', type: 'Video', key: '', url: DEFAULT_BASE_URL, durations: ['15s', '25s'] },
            { id: 'google-veo3', provider: 'Google Veo 3', modelName: 'veo3.1-components', type: 'Video', key: '', url: 'https://ai.t8star.cn', durations: ['8s'] },
            { id: 'grok-3', provider: 'Grok3 Video', modelName: 'grok-video-3', type: 'Video', key: '', url: 'https://ai.t8star.cn', durations: ['8s', '5s'] },
        ];

        const RATIOS = ['Auto', '1:1', '16:9', '9:16', '4:3', '3:4', '21:9', '3:2', '2:3'];
        const GROK_VIDEO_RATIOS = ['3:2', '2:3', '1:1'];
        const VIDEO_RES_OPTIONS = ['1080P', '720P'];
        const PROMPT_LIBRARY_KEY = 'tapnow_prompt_library';
        const GRID_PROMPT_TEXT = `基于我上传的这张参考图，生成一张九宫格（3x3 grid）布局的分镜脚本。请严格保持角色与参考图一致（Keep character strictly consistent），但在9个格子中展示该角色不同的动作、表情和拍摄角度（如正面、侧面、背面、特写等）。要求风格高度统一，形成一张完整的角色动态表（Character Sheet）。`;
        const UPSCALE_PROMPT_TEXT = `请对参考图片进行无损高清放大（Upscale）。请严格保持原图的构图、色彩、光影和所有细节元素不变，不要进行任何创造性的重绘或添加新内容。仅专注于提升分辨率、锐化边缘（Sharpening）和去除噪点（Denoising），实现像素级的高清修复。Best quality, 8k, masterpiece, highres, ultra detailed, sharp focus, image restoration, upscale, faithful to original.`;
        const STORYBOARD_PROMPT_TEXT = `you are a veteran Hollywood storyboard artist with years of experience. You have the ability to accurately analyze character features and scene characteristics based on images. Provide me with the most suitable camera angles and storyboards. Strictly base this on the uploaded character and scene images, while maintaining a consistent visual style.

MANDATORY LAYOUT: Create a precise 3x3 GRID containing exactly 9 distinct panels.

- The output image MUST be a single image divided into a 3 (rows) by 3 (columns) matrix.
- There must be EXACTLY 3 horizontal rows and 3 vertical columns.
- Each panel must be completely separated by a thin, distinct, solid black line.
- DO NOT create a collage. DO NOT overlap images. DO NOT create random sizes. 
- The grid structure must be perfectly aligned for slicing.

Subject Content: "[在此处填充你对故事的描述]"

Styling Instructions:
- Each panel shows the SAME subject/scene from a DIFFERENT angle (e.g., Front, Side, Back, Action, Close-up).
- Maintain perfect consistency of the character/object across all panels.
- Cinematic lighting, high fidelity, 8k resolution.

Negative Constraints:
- No text, no captions, no UI elements.
- No watermarks.
- No broken grid lines.`;

        const CHARACTER_SHEET_PROMPT_TEXT = `(strictly mimic source image art style:1.5), (same visual style:1.4),
score_9, score_8_up, masterpiece, best quality, (character sheet:1.4), (reference sheet:1.3), (consistent art style:1.3), matching visual style, 

[Structure & General Annotations]:
multiple views, full body central figure, clean background, 
(heavy annotation:1.4), (text labels with arrows:1.3), handwriting, data readout,

[SPECIAL CHARACTER DESCRIPTION AREA]:
(prominent character profile text box:1.6), (dedicated biography section:1.5), large descriptive text block,
[在此处填写特殊角色说明，例如：姓名、种族、背景故事等],

[Clothing Breakdown]:
(clothing breakdown:1.5), (outfit decomposition:1.4), garment analysis, (floating apparel:1.3), 
displaying outerwear, displaying upper body garment, displaying lower body garment, 

[Footwear Focus]:
(detailed footwear display:1.5), (floating shoes:1.4), shoe design breakdown, focus on shoes, 

[Inventory & Details]:
(inventory knolling:1.2), open container, personal accessories, organized items display, expression panels`;

        const MOOD_BOARD_PROMPT_TEXT = `# Directive: Create a "Rich Narrative Mood Board" (8-Grid Layout)

## 1. PROJECT INPUT 

**A. [Story & Concept / 故事与核心想法]**
> [跟据自身内容书写]

**B. [Key Symbols / 核心意象 (Optional)]**
> [深度理解参考图，自行创作]

**C. [Color Preferences / 色彩倾向 (Optional)]**
> [深度理解参考图，自行创作]

**D. [Reference Images / 参考图]**
> (See attached images / 请读取我上传的图片)

---

## 2. Role Definition
Act as a **Senior Art Director**. Synthesize the Input above into a single, cohesive, high-density **Visual Mood Board** using a complex **8-Panel Asymmetrical Grid Layout**.

## 3. Layout Mapping (Strict Adherence)
You must design a visual composition that tells the story through **8 distinct panels** within one image. **Do not** generate random grids. Map the content exactly as follows:

* **Panel 1 (The World):** A wide, cinematic establishing shot of the environment (based on Input A).
* **Panel 2 (The Protagonist):** A portrait close-up (based on reference images), focusing on micro-expressions.
* **Panel 3 (The Metaphor):** An **abstract symbolic object** representing the core theme (based on Input B).
* **Panel 4 (The Palette):** A graphical **Color Palette Strip** showcasing 5 specific colors extracted from the scene.
* **Panel 5 (The Texture):** Extreme macro close-up of a material surface (e.g., rust, skin, fabric) to add tactile richness.
* **Panel 6 (The Motion):** A motion-blurred or long-exposure shot representing time/chaos.
* **Panel 7 (The Detail):** A focused shot of a specific prop or accessory relevant to the plot.
* **Panel 8 (The AI Art Interpretation - CRITICAL):** This is your **free creative space**. Generate an artistic, surreal, or abstract re-interpretation of the story's emotion. **Do not just copy the inputs.** Create a "Vibe Image" (e.g., Double Exposure, Oil Painting style, or abstract geometry) that captures the *soul* of the narrative.

## 4. Execution Requirements
* **Composition Style:** High-end Editorial / Magazine Layout. Clean, thin white borders.
* **Visual Unity:** All panels must share the same lighting conditions and color grading logic (Unified Aesthetic).
* **Task:** Provide the **Final English Image Prompt** that explicitly describes this 8-grid layout, ensuring Panel 8 stands out as an artistic variation.`;
        // 已删除的模型ID列表（用于过滤）
        const DELETED_MODEL_IDS = [
            'gemini-image',
            'qwen-image', 
            'doubao-seedream',
            'jimeng', // Jimeng Video
            'hailuo-02',
            'kling-v1-6',
            'wan-2.5'
        ];

        const getRatiosForModel = (modelId) => {
            if (!modelId) return RATIOS;
            if (modelId.includes('grok')) return GROK_VIDEO_RATIOS;
            return RATIOS;
        };
        const RESOLUTIONS = ['Auto', '1K', '2K', '4K'];
        // 根据模型返回不同的分辨率选项
        const getResolutionsForModel = (modelId) => {
            if (!modelId) return RESOLUTIONS;
            // jimeng-4.5模型只显示2K和4K两个选项
            if (modelId.includes('jimeng-4.5')) return ['2K', '4K'];
            return RESOLUTIONS;
        }; 
        // Midjourney版本列表
        const MJ_VERSIONS = [
            { label: 'MJ V7', value: '--v 7' },
            { label: 'MJ V6.1', value: '--v 6.1' },
            { label: 'MJ V6', value: '--v 6' },
            { label: 'MJ V5.2', value: '--v 5.2' },
            { label: 'MJ V5.1', value: '--v 5.1' },
            { label: 'Niji V6', value: '--niji 6' },
            { label: 'Niji V5', value: '--niji 5' },
            { label: 'Niji V4', value: '--niji 4' }
        ]; 

        // --- 辅助：计算真实分辨率 ---
        const calculateResolution = (ratio, baseResolution) => {
            let baseW = 1024;
            let baseH = 1024;
            
            if (baseResolution === '1080P') { baseW = 1920; baseH = 1080; }
            else if (baseResolution === '720P') { baseW = 1280; baseH = 720; }
            else if (baseResolution === '2K') { baseW = 2048; baseH = 2048; }
            else if (baseResolution === '4K') { baseW = 3840; baseH = 2160; }

            if (ratio === 'Auto') {
                return { str: `${baseW}x${baseH}`, w: baseW, h: baseH };
            }

            const [rW, rH] = ratio.split(':').map(Number);
            if (!rW || !rH) return { str: '1024x1024', w: 1024, h: 1024 };

            let targetW;
            let targetH;

            if (Math.abs(rW - rH) < 0.1) {
                targetW = baseW; targetH = baseH;
            } else if (rW > rH) {
                targetW = (baseResolution === 'Auto' || baseResolution === '1K') ? 1280 : baseW;
                targetH = Math.round(targetW * (rH / rW));
            } else {
                targetH = (baseResolution === 'Auto' || baseResolution === '1K') ? 1280 : baseW;
                targetW = Math.round(targetH * (rW / rH));
            }

            targetW = Math.round(targetW / 16) * 16;
            targetH = Math.round(targetH / 16) * 16;

            return { str: `${targetW}x${targetH}`, w: targetW, h: targetH };
        };

        const getModelParams = (modelId, ratio, resolution) => {
            const { str, w, h } = calculateResolution(ratio, resolution);
            if (modelId.includes('minimax')) {
                return { sizeStr: resolution === '4K' ? '1080p' : '720p', w, h };
            }
            if (modelId.includes('jimeng') || modelId.includes('veo')) {
                return { sizeStr: ratio, w, h };
            }
            if (modelId.includes('grok')) {
                // Grok 接口需要传 aspect_ratio，size 传比例字符串即可
                return { sizeStr: ratio, w, h };
            }
            return { sizeStr: str, w, h };
        };

        // --- Helper: Get Image Dimensions ---
        const getImageDimensions = (src) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve({ w: img.naturalWidth, h: img.naturalHeight });
                img.onerror = () => reject(new Error("Failed to load image"));
                img.src = src;
            });
        };
        
        // --- Helper: Check if URL is video ---
        const isVideoUrl = (url) => {
            if (!url) return false;
            if (url.startsWith('data:video')) return true;
            if (url.includes('force_video_display=true')) return true;
            const ext = url.split('.').pop().split('?')[0].toLowerCase();
            return ['mp4', 'webm', 'ogg', 'mov'].includes(ext);
        };

        // --- Helper: Load Video Metadata ---
        const getVideoMetadata = (src) => {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.preload = 'metadata';
                video.muted = true;
                video.playsInline = true;
                video.onloadedmetadata = () => {
                    resolve({
                        duration: Number(video.duration) || 0,
                        w: video.videoWidth || 0,
                        h: video.videoHeight || 0,
                    });
                };
                video.onerror = () => reject(new Error('视频加载失败'));
                video.src = src;
            });
        };

        // --- Helper: Extract Key Frames from video using <video> + <canvas> ---
        const extractKeyFrames = (src, { fps = 2 } = {}) => {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                video.muted = true;
                video.playsInline = true;
                video.crossOrigin = 'anonymous';
                video.src = src;
                const frames = [];

                const handleError = () => reject(new Error('视频抽帧失败'));
                video.onerror = handleError;

                video.onloadedmetadata = () => {
                    const duration = Number(video.duration) || 0;
                    if (!duration || !isFinite(duration)) {
                        reject(new Error('无法读取视频时长'));
                        return;
                    }
                    canvas.width = video.videoWidth || 1280;
                    canvas.height = video.videoHeight || 720;
                    const interval = 1 / Math.max(0.1, fps);
                    let current = 0;

                    const captureFrame = () => {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        frames.push({
                            time: Number(current.toFixed(2)),
                            url: canvas.toDataURL('image/jpeg', 0.82),
                        });
                        current += interval;
                        if (current <= duration) {
                            video.currentTime = Math.min(current, duration);
                        } else {
                            resolve(frames);
                        }
                    };

                    video.onseeked = captureFrame;
                    // 启动首次抽帧
                    video.currentTime = 0;
                };
            });
        };

        // --- Component: ImageCompareView (Beautified & Optimized) ---
        const ImageCompareView = React.memo(({ img1, img2 }) => {
            const [pos, setPos] = useState(50);
            const containerRef = useRef(null);
            const [isHovering, setIsHovering] = useState(false);
            const requestRef = useRef();

            const handleMove = useCallback((e) => {
                if (!containerRef.current) return;
                
                // 使用 requestAnimationFrame 优化性能
                if (requestRef.current) return;
                
                requestRef.current = requestAnimationFrame(() => {
                    if (!containerRef.current) return;
                    const rect = containerRef.current.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
                    setPos((x / rect.width) * 100);
                    requestRef.current = null;
                });
            }, []);

            useEffect(() => {
                return () => {
                    if (requestRef.current) {
                        cancelAnimationFrame(requestRef.current);
                    }
                };
            }, []);

            const displayImg1 = img1;
            const displayImg2 = img2 || img1; 

            if (!displayImg1) return (
                <div className="w-full h-full flex flex-col items-center justify-center text-zinc-500 bg-zinc-900/50 rounded-lg border border-zinc-800 border-dashed pointer-events-none">
                    <Split size={24} className="mb-2 opacity-50" />
                    <span className="text-xs font-medium">连接图片以对比</span>
                </div>
            );

            return (
                <div 
                    ref={containerRef}
                    className="relative w-full h-full cursor-col-resize overflow-hidden group rounded-lg select-none shadow-2xl border border-zinc-800 bg-[#09090b]"
                    onMouseMove={handleMove}
                    onTouchMove={handleMove}
                    onMouseEnter={() => setIsHovering(true)}
                    onMouseLeave={() => setIsHovering(false)}
                >
                    {/* Checkered Background */}
                    <div className="absolute inset-0 opacity-20 pointer-events-none" 
                         style={{ 
                             backgroundImage: 'conic-gradient(#333 90deg, transparent 90deg), conic-gradient(transparent 90deg, #333 90deg)', 
                             backgroundSize: '20px 20px', 
                             backgroundPosition: '0 0, 10px 10px' 
                         }} 
                    />
                    <img src={displayImg1} loading="lazy" decoding="async" className="absolute inset-0 w-full h-full object-contain pointer-events-none select-none" draggable={false} />
                    <div 
                        className="absolute inset-0 w-full h-full overflow-hidden pointer-events-none select-none"
                        style={{ clipPath: `inset(0 0 0 ${pos}%)` }} 
                    >
                        <img src={displayImg2} loading="lazy" decoding="async" className="absolute inset-0 w-full h-full object-contain" draggable={false} />
                    </div>
                    <div 
                        className="absolute top-0 bottom-0 w-0.5 bg-white/80 shadow-[0_0_10px_rgba(0,0,0,0.5)] pointer-events-none"
                        style={{ left: `${pos}%` }}
                    >
                        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-6 h-6 bg-white rounded-full shadow-lg flex items-center justify-center text-black">
                            <Split size={12} className="rotate-90" />
                        </div>
                    </div>
                    <div className={`absolute bottom-2 left-2 bg-black/70 text-white text-[10px] font-medium px-2 py-0.5 rounded border border-white/10 transition-opacity duration-200 pointer-events-none ${isHovering ? 'opacity-100' : 'opacity-60'}`}>
                        原始
                    </div>
                    <div className={`absolute bottom-2 right-2 bg-blue-600/80 text-white text-[10px] font-medium px-2 py-0.5 rounded border border-white/10 transition-opacity duration-200 pointer-events-none ${isHovering ? 'opacity-100' : 'opacity-60'}`}>
                        生成
                    </div>
                </div>
            );
        });

        // --- 辅助组件 ---
        const Button = React.memo(({ children, onClick, className = '', variant = 'primary', icon: Icon, disabled = false, title = '' }) => {
            const baseStyle = 'flex items-center justify-center px-3 py-1.5 rounded-lg transition-all duration-200 font-medium text-xs select-none disabled:opacity-50 disabled:cursor-not-allowed';
            const variants = {
                primary: 'bg-blue-600 hover:bg-blue-500 text-white shadow-lg shadow-blue-900/20 active:scale-95',
                secondary: 'bg-zinc-800 hover:bg-zinc-700 text-zinc-300 border border-zinc-700 active:scale-95',
                ghost: 'bg-transparent hover:bg-zinc-800 text-zinc-400 hover:text-white',
                danger: 'bg-red-900/30 hover:bg-red-800 text-red-200 border border-red-800 active:scale-95',
            };
            return (
                <button onClick={onClick} disabled={disabled} className={`${baseStyle} ${variants[variant]} ${className}`} title={title}>
                    {Icon && <Icon size={14} className={children ? 'mr-1.5' : ''} />}
                    {children}
                </button>
            );
        });

        // --- 性能优化工具函数 ---
        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        const Modal = ({ isOpen, onClose, title, children, theme = 'dark' }) => {
            if (!isOpen) return null;
            const isDark = theme === 'dark';
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/60 backdrop-blur-sm" onClick={onClose}>
                    <div
                        className={`rounded-xl shadow-2xl w-[680px] max-w-[90vw] overflow-hidden animate-in fade-in zoom-in-95 duration-200 flex flex-col max-h-[85vh] border ${
                            isDark ? 'bg-[#09090b] border-zinc-800' : 'bg-white border-zinc-200'
                        }`}
                        onClick={(e) => e.stopPropagation()}
                    >
                        <div
                            className={`flex items-center justify-between p-5 border-b shrink-0 ${
                                isDark ? 'border-zinc-800/50' : 'border-zinc-200'
                            }`}
                        >
                            <h3 className={`font-bold text-lg ${isDark ? 'text-white' : 'text-zinc-900'}`}>{title}</h3>
                            <button
                                onClick={onClose}
                                className={isDark ? 'text-zinc-500 hover:text-white' : 'text-zinc-500 hover:text-zinc-900'}
                            >
                                <X size={20} />
                            </button>
                        </div>
                        <div className={`p-0 overflow-y-auto custom-scrollbar flex-1 ${isDark ? 'bg-[#09090b]' : 'bg-white'}`}>
                            {children}
                        </div>
                    </div>
                </div>
            );
        };

        const Lightbox = ({ item, onClose, onNavigate }) => {
            if (!item) return null;
            
            // 使用ref存储最新的item值，避免闭包问题
            const itemRef = useRef(item);
            useEffect(() => {
                itemRef.current = item;
            }, [item]);
            
            // 键盘事件处理：左右方向键切换图片
            useEffect(() => {
                if (!item) return;
                
                const handleKeyDown = (e) => {
                    // 使用ref获取最新的item值
                    const currentItem = itemRef.current;
                    if (!currentItem) return;
                    
                    // 只在有多张图片时响应方向键
                    if (!currentItem.mjImages || currentItem.mjImages.length <= 1) return;
                    
                    // 防止在输入框中触发
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    if (e.key === 'ArrowLeft' || e.key === 'Left') {
                        e.preventDefault();
                        e.stopPropagation();
                        // 切换到上一张（只在当前item的mjImages范围内）
                        const currentIndex = currentItem.selectedMjImageIndex !== undefined ? currentItem.selectedMjImageIndex : 0;
                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : currentItem.mjImages.length - 1;
                        // 确保索引在有效范围内，并且只操作当前item的mjImages
                        if (prevIndex >= 0 && prevIndex < currentItem.mjImages.length && onNavigate) {
                            onNavigate(prevIndex);
                        }
                    } else if (e.key === 'ArrowRight' || e.key === 'Right') {
                        e.preventDefault();
                        e.stopPropagation();
                        // 切换到下一张（只在当前item的mjImages范围内）
                        const currentIndex = currentItem.selectedMjImageIndex !== undefined ? currentItem.selectedMjImageIndex : 0;
                        const nextIndex = currentIndex < currentItem.mjImages.length - 1 ? currentIndex + 1 : 0;
                        // 确保索引在有效范围内，并且只操作当前item的mjImages
                        if (nextIndex >= 0 && nextIndex < currentItem.mjImages.length && onNavigate) {
                            onNavigate(nextIndex);
                        }
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                };
            }, [item, onNavigate]);
            
            return (
                <div className="fixed inset-0 z-[200] lightbox-overlay flex flex-col items-center justify-center animate-in fade-in duration-200" onClick={onClose}>
                    <button className="absolute top-4 right-4 text-white/70 hover:text-white p-2 bg-black/50 rounded-full transition-colors" onClick={onClose}><X size={24} /></button>
                    <div className="max-w-[90vw] max-h-[85vh] relative" onClick={(e) => e.stopPropagation()}>
                        {item.type === 'image' ? (
                            <img src={item.url} alt={item.prompt} className="max-w-full max-h-[85vh] rounded-lg shadow-2xl object-contain" />
                        ) : (
                            <video src={item.url} controls autoPlay className="max-w-full max-h-[85vh] rounded-lg shadow-2xl" />
                        )}
                        <div className="absolute bottom-8 left-1/2 -translate-x-1/2 bg-black/60 backdrop-blur-md px-6 py-3 rounded-full text-white text-sm font-medium border border-white/10 text-center shadow-2xl">
                            <div className="line-clamp-1 max-w-xl">{item.prompt}</div>
                            <div className="text-[10px] text-zinc-400 mt-1">
                                {item.width}x{item.height} • {item.modelName}
                                {item.mjImages && item.mjImages.length > 1 && (
                                    <span className="ml-2">({(item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0) + 1}/{item.mjImages.length})</span>
                                )}
                            </div>
                        </div>
                        {/* 左右切换提示 */}
                        {item.mjImages && item.mjImages.length > 1 && (
                            <>
                                <button
                                    className="absolute left-4 top-1/2 -translate-y-1/2 text-white/70 hover:text-white p-3 bg-black/50 rounded-full transition-colors"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        const currentIndex = item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0;
                                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : item.mjImages.length - 1;
                                        if (onNavigate) onNavigate(prevIndex);
                                    }}
                                    title="上一张 (←)"
                                >
                                    <ChevronLeft size={24} />
                                </button>
                                <button
                                    className="absolute right-4 top-1/2 -translate-y-1/2 text-white/70 hover:text-white p-3 bg-black/50 rounded-full transition-colors"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        const currentIndex = item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0;
                                        const nextIndex = currentIndex < item.mjImages.length - 1 ? currentIndex + 1 : 0;
                                        if (onNavigate) onNavigate(nextIndex);
                                    }}
                                    title="下一张 (→)"
                                >
                                    <ChevronRight size={24} />
                                </button>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        function TapnowApp() {
            const [theme, setTheme] = useState(() => {
                try {
                    return localStorage.getItem('tapnow_theme') || 'dark';
                } catch (e) {
                    return 'dark';
                }
            });

            useEffect(() => {
                const styleSheet = document.createElement('style');
                styleSheet.innerText = styles;
                document.head.appendChild(styleSheet);
                return () => { document.head.removeChild(styleSheet); };
            }, []);

            useEffect(() => {
                try {
                    localStorage.setItem('tapnow_theme', theme);
                } catch (e) {}
                const root = document.documentElement;
                if (theme === 'dark') {
                    root.classList.add('theme-dark');
                    root.classList.remove('theme-light');
                    document.body.style.backgroundColor = '#09090b';
                } else {
                    root.classList.add('theme-light');
                    root.classList.remove('theme-dark');
                    document.body.style.backgroundColor = '#f4f4f5';
                }
            }, [theme]);

            const [nodes, setNodes] = useState([]);
            const [connections, setConnections] = useState([]);
            const [view, setView] = useState({ x: 0, y: 0, zoom: 1 });
            // 性能优化：使用 ref 存储 view 和拖拽状态，避免频繁 setState
            const viewRef = useRef({ x: 0, y: 0, zoom: 1 });
            const viewRafRef = useRef(null);
            const dragOffsetRef = useRef(new Map()); // nodeId -> { x, y }
            const dragStartPosRef = useRef(new Map()); // nodeId -> { x, y }
            const [selectedNodeId, setSelectedNodeId] = useState(null);

            const [apiConfigs, setApiConfigs] = useState(() => {
                const saved = localStorage.getItem('tapnow_api_configs');
                let configs = saved ? JSON.parse(saved) : DEFAULT_API_CONFIGS;
                
                // 确保 gpt-5.2 存在（如果不存在则添加）
                const hasGpt52 = configs.some(c => c.id === 'gpt-5-2');
                if (!hasGpt52) {
                    // 找到 gpt-5-1 的位置，在它后面插入 gpt-5-2
                    const gpt51Index = configs.findIndex(c => c.id === 'gpt-5-1');
                    const insertIndex = gpt51Index >= 0 ? gpt51Index + 1 : configs.findIndex(c => c.type === 'Chat' && c.id === 'deepseek-v3');
                    const finalIndex = insertIndex >= 0 ? insertIndex : configs.length;
                    configs.splice(finalIndex, 0, { id: 'gpt-5-2', provider: 'GPT 5.2', modelName: 'gpt-5.2', type: 'Chat', key: '', url: DEFAULT_BASE_URL });
                }
                
                // 过滤掉jimeng-4.5配置（如果存在）
                configs = configs.filter(c => c.id !== 'jimeng-4.5');
                
                // 确保 sora-2-pro 存在（如果不存在则添加）
                const hasSora2Pro = configs.some(c => c.id === 'sora-2-pro');
                if (!hasSora2Pro) {
                    // 找到 sora-2 的位置，在它后面插入 sora-2-pro
                    const sora2Index = configs.findIndex(c => c.id === 'sora-2');
                    const insertIndex = sora2Index >= 0 ? sora2Index + 1 : configs.findIndex(c => c.type === 'Video' && c.id === 'google-veo3');
                    const finalIndex = insertIndex >= 0 ? insertIndex : configs.length;
                    configs.splice(finalIndex, 0, { id: 'sora-2-pro', provider: 'Sora 2 Pro', modelName: 'sora-2-pro', type: 'Video', key: '', url: DEFAULT_BASE_URL, durations: ['15s', '25s'] });
                }
                
                // 过滤掉已删除的模型配置
                configs = configs.filter(c => !DELETED_MODEL_IDS.includes(c.id));
                
                // 从localStorage读取保存的Session ID
                // 第一次打开时如果没有保存的Session ID，使用空字符串（需要用户输入）
                // 如果有保存的Session ID，则使用保存的值
                const savedSessionId = localStorage.getItem('tapnow_jimeng_session_id');
                const sessionIdToUse = savedSessionId || ''; // 如果没有保存的，使用空字符串，让用户输入
                
                // 确保即梦模型存在（如果不存在则添加）
                const hasJimeng45 = configs.some(c => c.id === 'jimeng-4.5');
                const hasJimeng41 = configs.some(c => c.id === 'jimeng-4.1');
                const hasJimeng31 = configs.some(c => c.id === 'jimeng-3.1');
                
                if (!hasJimeng45 || !hasJimeng41 || !hasJimeng31) {
                    // 找到即梦模型在默认配置中的位置（在Midjourney之后）
                    const mjIndex = configs.findIndex(c => c.id === 'mj-v6');
                    const insertIndex = mjIndex >= 0 ? mjIndex + 1 : configs.length;
                    
                    if (!hasJimeng45) {
                        configs.splice(insertIndex, 0, { id: 'jimeng-4.5', provider: 'Jimeng 4.5', modelName: 'jimeng-4.5', type: 'Image', key: sessionIdToUse, url: JIMENG_API_BASE_URL });
                    }
                    if (!hasJimeng41) {
                        const jimeng45Index = configs.findIndex(c => c.id === 'jimeng-4.5');
                        const nextIndex = jimeng45Index >= 0 ? jimeng45Index + 1 : insertIndex;
                        configs.splice(nextIndex, 0, { id: 'jimeng-4.1', provider: 'Jimeng 4.1', modelName: 'jimeng-4.1', type: 'Image', key: sessionIdToUse, url: JIMENG_API_BASE_URL });
                    }
                    if (!hasJimeng31) {
                        const jimeng41Index = configs.findIndex(c => c.id === 'jimeng-4.1');
                        const nextIndex = jimeng41Index >= 0 ? jimeng41Index + 1 : insertIndex + 1;
                        configs.splice(nextIndex, 0, { id: 'jimeng-3.1', provider: 'Jimeng 3.1', modelName: 'jimeng-3.1', type: 'Image', key: sessionIdToUse, url: JIMENG_API_BASE_URL });
                    }
                } else {
                    // 如果模型已存在，更新所有jimeng模型的Session ID
                    // 如果有保存的Session ID，使用保存的值；如果没有，使用空字符串（让用户输入）
                    configs = configs.map(c => 
                        (c.id.includes('jimeng') || c.provider?.includes('Jimeng'))
                            ? { ...c, key: sessionIdToUse }
                            : c
                    );
                }
                
                // 确保 Grok-3 Video 模型存在（兼容旧的本地存储配置）
                const hasGrok3 = configs.some(c => c.id === 'grok-3');
                if (!hasGrok3) {
                    const firstVideoIndex = configs.findIndex(c => c.type === 'Video');
                    const insertIndex = firstVideoIndex >= 0 ? firstVideoIndex : configs.length;
                    configs.splice(insertIndex, 0, { id: 'grok-3', provider: 'Grok3 Video', modelName: 'grok-video-3', type: 'Video', key: '', url: 'https://ai.t8star.cn', durations: ['8s', '5s'] });
                }
                
                return configs;
            });
            const [globalApiKey, setGlobalApiKey] = useState(() => localStorage.getItem('tapnow_global_key') || '');
            
            // 即梦图生图使用本地文件设置（默认true，强制使用本地文件而不是URL）
            const [jimengUseLocalFile, setJimengUseLocalFile] = useState(() => {
                const saved = localStorage.getItem('tapnow_jimeng_use_local_file');
                return saved !== null ? saved === 'true' : true; // 默认true
            });

            // 项目名称状态
            const [projectName, setProjectName] = useState(() => {
                try {
                    const saved = localStorage.getItem('tapnow_project_name');
                    return saved || '未命名项目';
                } catch (e) {
                    return '未命名项目';
                }
            });
            const [isEditingProjectName, setIsEditingProjectName] = useState(false);
            const projectNameInputRef = useRef(null);

            const [history, setHistory] = useState(() => {
                try {
                const saved = localStorage.getItem('tapnow_history');
                    if (!saved) return [];
                    const parsed = JSON.parse(saved);
                    // 检查是否有需要重新切割的Midjourney图片
                    return parsed.map(item => {
                        if (item.mjNeedsSplit && item.mjOriginalUrl && item.apiConfig?.modelId?.includes('mj')) {
                            // 标记需要重新切割，但不立即切割（避免阻塞初始化）
                            return { ...item, url: item.mjOriginalUrl, mjImages: null, mjNeedsSplit: true };
                        }
                        return item;
                    });
                } catch (e) {
                    console.error('加载历史记录失败:', e);
                    return [];
                }
            });
            
            const [chatSessions, setChatSessions] = useState(() => {
                try {
                    const saved = localStorage.getItem('tapnow_chat_sessions');
                    return saved ? JSON.parse(saved) : [{ id: 'default', title: '新对话', messages: [] }];
                } catch (e) {
                    return [{ id: 'default', title: '新对话', messages: [] }];
                }
            });
            const [currentChatId, setCurrentChatId] = useState('default');
            const [chatInput, setChatInput] = useState('');
            const [isChatOpen, setIsChatOpen] = useState(false);
            const [chatWidth, setChatWidth] = useState(400); 
            const [chatFiles, setChatFiles] = useState([]); 
            const [chatModel, setChatModel] = useState('gemini-3-pro');
            const [isChatSending, setIsChatSending] = useState(false);

            const [lightboxItem, setLightboxItem] = useState(null);

            const [promptLibrary, setPromptLibrary] = useState(() => {
                try {
                    const saved = localStorage.getItem(PROMPT_LIBRARY_KEY);
                    const parsed = saved ? JSON.parse(saved) : [];
                    const defaults = [
                        { id: 'grid-default', name: '九宫格分镜脚本', prompt: GRID_PROMPT_TEXT },
                        { id: 'upscale-default', name: '高清放大', prompt: UPSCALE_PROMPT_TEXT },
                        { id: 'moodboard-default', name: '情绪版', prompt: MOOD_BOARD_PROMPT_TEXT },
                        { id: 'storyboard-default', name: '【分镜版】', prompt: STORYBOARD_PROMPT_TEXT },
                        { id: 'character-sheet-default', name: '【角色板】', prompt: CHARACTER_SHEET_PROMPT_TEXT }
                    ];
                    // 确保默认项存在且不重复
                    const existingIds = new Set((parsed || []).map(p => p.id));
                    const merged = [...parsed];
                    defaults.forEach(def => {
                        const hasSameName = merged.some(p => p.name === def.name);
                        if (!existingIds.has(def.id) && !hasSameName) merged.unshift(def);
                    });
                    return merged;
                } catch (e) {
                    return [
                        { id: 'grid-default', name: '九宫格分镜脚本', prompt: GRID_PROMPT_TEXT },
                        { id: 'upscale-default', name: '高清放大', prompt: UPSCALE_PROMPT_TEXT },
                        { id: 'moodboard-default', name: '情绪版', prompt: MOOD_BOARD_PROMPT_TEXT },
                        { id: 'storyboard-default', name: '【分镜版】', prompt: STORYBOARD_PROMPT_TEXT },
                        { id: 'character-sheet-default', name: '【角色板】', prompt: CHARACTER_SHEET_PROMPT_TEXT }
                    ];
                }
            });
            const [promptLibraryForm, setPromptLibraryForm] = useState({ name: '', prompt: '' });
            const [promptLibraryCollapsed, setPromptLibraryCollapsed] = useState(false);
            const [promptLibraryEditorOpen, setPromptLibraryEditorOpen] = useState(false);
            useEffect(() => {
                try {
                    localStorage.setItem(PROMPT_LIBRARY_KEY, JSON.stringify(promptLibrary));
                } catch (e) {}
            }, [promptLibrary]);

            // State management
            const [isPanning, setIsPanning] = useState(false);
            const [isDragging, setIsDragging] = useState(false);
            const [dragNodeId, setDragNodeId] = useState(null);
            const [resizingNodeId, setResizingNodeId] = useState(null);
            const [connectingSource, setConnectingSource] = useState(null);
            const [connectingTarget, setConnectingTarget] = useState(null); // 从输入端口开始的连接目标节点ID
            const [connectingInputType, setConnectingInputType] = useState(null); // 'default', 'oref', 'sref'
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [hoverTargetId, setHoverTargetId] = useState(null);
            const [isMouseOverStoryboard, setIsMouseOverStoryboard] = useState(false); // 鼠标是否在智能分镜表窗口内

            // 框选相关状态
            const [isSelecting, setIsSelecting] = useState(false);
            const [selectionBox, setSelectionBox] = useState(null); // { startX, startY, endX, endY } (屏幕坐标)
            const [selectedNodeIds, setSelectedNodeIds] = useState(new Set()); // 多选节点ID集合
            const isSelectingRef = useRef(false); // 使用ref跟踪框选状态，确保即使Ctrl松开也能继续框选

            const [contextMenu, setContextMenu] = useState({ x: 0, y: 0, worldX: 0, worldY: 0, visible: false });
            const [historyContextMenu, setHistoryContextMenu] = useState({ visible: false, x: 0, y: 0, worldX: 0, worldY: 0, item: null });
            // 记录当前选中的分镜格，用于接收历史记录图片
            const [activeShot, setActiveShot] = useState({ nodeId: null, shotId: null });
            const [frameContextMenu, setFrameContextMenu] = useState({ visible: false, x: 0, y: 0, nodeId: null, frame: null });
            const [previewContextMenu, setPreviewContextMenu] = useState({ visible: false, x: 0, y: 0, item: null });
            const [inputImageContextMenu, setInputImageContextMenu] = useState({ visible: false, x: 0, y: 0, nodeId: null });
            const [settingsOpen, setSettingsOpen] = useState(false);
            const [historyOpen, setHistoryOpen] = useState(false);
            const [charactersOpen, setCharactersOpen] = useState(false);
            const [characterLibrary, setCharacterLibrary] = useState(() => {
                try {
                    const saved = localStorage.getItem('tapnow_characters');
                    return saved ? JSON.parse(saved) : [];
                } catch (e) {
                    console.error('加载角色库失败:', e);
                    return [];
                }
            });
            const [createCharacterOpen, setCreateCharacterOpen] = useState(false);
            const [createCharacterVideoSourceType, setCreateCharacterVideoSourceType] = useState('url');
            const [createCharacterVideoUrl, setCreateCharacterVideoUrl] = useState('');
            const [createCharacterSelectedTaskId, setCreateCharacterSelectedTaskId] = useState('');
            const [createCharacterStartSecond, setCreateCharacterStartSecond] = useState(1);
            const [createCharacterEndSecond, setCreateCharacterEndSecond] = useState(3);
            const [createCharacterEndpoint, setCreateCharacterEndpoint] = useState('');
            const [createCharacterSubmitting, setCreateCharacterSubmitting] = useState(false);
            const [createCharacterVideoError, setCreateCharacterVideoError] = useState(null);
            const [characterReferenceBarExpanded, setCharacterReferenceBarExpanded] = useState({});
            const [batchModalOpen, setBatchModalOpen] = useState(false);
            const [batchSelectedIds, setBatchSelectedIds] = useState(new Set());
            const [chatSessionDropdownOpen, setChatSessionDropdownOpen] = useState(false);
            const [activeTool, setActiveTool] = useState('select');
            const [activeDropdown, setActiveDropdown] = useState(null);
            const [apiTesting, setApiTesting] = useState(null);
            const [apiStatus, setApiStatus] = useState({});
            // 实时计时器状态：nodeId -> elapsedSeconds
            const [nodeTimers, setNodeTimers] = useState({});

            const canvasRef = useRef(null);
            const lastMousePos = useRef({ x: 0, y: 0 });
            const chatEndRef = useRef(null);
            const nodesRef = useRef(nodes);
            const selectedNodeIdRef = useRef(selectedNodeId);
            const selectedNodeIdsRef = useRef(selectedNodeIds); // 存储多选节点ID的ref
            const connectionsRef = useRef(connections);
            const frameSelectionRef = useRef({});
            const copiedNodesRef = useRef(null); // 存储复制的节点数据

            useEffect(() => { 
                // 保存时过滤掉jimeng-4.5配置
                const filteredConfigs = apiConfigs.filter(c => c.id !== 'jimeng-4.5');
                localStorage.setItem('tapnow_api_configs', JSON.stringify(filteredConfigs)); 
            }, [apiConfigs]);
            
            // 全局 Delete 键删除节点
            useEffect(() => {
                const handleDeleteKey = (e) => {
                    // 防止在输入框中触发
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
                    
                    // 检查是否按下了 Delete 或 Del 键
                    if (e.key === 'Delete' || e.key === 'Del') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const currentSelectedId = selectedNodeIdRef.current;
                        const currentSelectedIds = selectedNodeIdsRef.current;
                        
                        // 删除选中的节点
                        if (currentSelectedId) {
                            deleteNode(currentSelectedId);
                            setSelectedNodeId(null);
                        } else if (currentSelectedIds && currentSelectedIds.size > 0) {
                            // 删除多选节点
                            currentSelectedIds.forEach(id => deleteNode(id));
                            setSelectedNodeIds(new Set());
                        }
                    }
                };
                
                window.addEventListener('keydown', handleDeleteKey);
                return () => {
                    window.removeEventListener('keydown', handleDeleteKey);
                };
            }, []);
            // 保存角色库到 localStorage（使用防抖优化）
            const debouncedSaveCharacters = useMemo(() => debounce((charactersToSave) => {
                try {
                    localStorage.setItem('tapnow_characters', JSON.stringify(charactersToSave));
                } catch (e) {
                    console.error('保存角色库失败:', e);
                }
            }, 500), []);

            useEffect(() => {
                debouncedSaveCharacters(characterLibrary);
            }, [characterLibrary, debouncedSaveCharacters]);

            // 当视频 URL 改变时清除错误提示
            useEffect(() => {
                setCreateCharacterVideoError(null);
            }, [createCharacterVideoUrl, createCharacterSelectedTaskId, createCharacterVideoSourceType]);

            // localStorage 写入防抖函数
            const debouncedSaveHistory = useMemo(() => debounce((historyToSave) => {
                try {
                    localStorage.setItem('tapnow_history', JSON.stringify(historyToSave));
                } catch (e) {
                    console.error('保存历史记录失败（可能超出存储配额）:', e);
                    // 如果存储失败，尝试减少数据量
                    try {
                        const reduced = historyToSave.map(item => ({
                            id: item.id,
                            type: item.type,
                            url: item.url,
                            prompt: item.prompt?.substring(0, 200) || '',
                            time: item.time,
                            status: item.status,
                            modelName: item.modelName,
                            width: item.width,
                            height: item.height,
                            ratio: item.ratio,
                            mjImages: item.mjImages,
                            selectedMjImageIndex: item.selectedMjImageIndex,
                            mjRatio: item.mjRatio,
                            mjNeedsSplit: item.mjNeedsSplit,
                            mjImageInfo: item.mjImageInfo
                        }));
                        localStorage.setItem('tapnow_history', JSON.stringify(reduced));
                    } catch (e2) {
                        console.error('减少数据后保存也失败:', e2);
                        try {
                            // 最小化保存：只保留必要字段
                            const minimal = historyToSave.map(item => ({
                                id: item.id,
                                type: item.type,
                                url: item.url,
                                prompt: item.prompt?.substring(0, 100) || '',
                                time: item.time,
                                status: item.status,
                                modelName: item.modelName
                            }));
                            debouncedSaveHistory(minimal);
                        } catch (e3) {
                            console.error('最小化保存也失败:', e3);
                        }
                    }
                }
            }, 1000), []);

            const debouncedSaveGlobalKey = useMemo(() => debounce((key) => {
                localStorage.setItem('tapnow_global_key', key);
            }, 1000), []);

            useEffect(() => { debouncedSaveGlobalKey(globalApiKey); }, [globalApiKey, debouncedSaveGlobalKey]);
            
            // 优化localStorage存储，处理配额超限问题
            useEffect(() => {
                try {
                    // 只存储必要的元数据，不存储完整的base64图片和长URL
                    const historyToSave = history.map(item => {
                        const saved = { ...item };
                        // 如果是Midjourney切割后的图片，只保存标记和原图URL，不保存完整的base64数组
                        if (item.mjImages && item.mjImages.length === 4) {
                            // 保存切割标记和原图URL，切割后的图片在需要时重新生成
                            saved.mjImages = null; // 不保存base64数组
                            saved.mjNeedsSplit = true; // 标记需要重新切割
                            saved.mjOriginalUrl = item.mjOriginalUrl || item.url; // 保存原图URL
                        }
                        // 如果URL是data URL且太长，只保存前100个字符作为标记
                        if (item.url && item.url.startsWith('data:') && item.url.length > 5000) {
                            saved.url = item.url.substring(0, 100) + '...'; // 只保存前100个字符
                        }
                        // 移除不必要的字段，减少存储大小
                        delete saved.mjImageInfo; // 不保存图片信息
                        return saved;
                    });
                    debouncedSaveHistory(historyToSave);
                } catch (e) {
                    console.error('保存历史记录失败（可能超出存储配额）:', e);
                    // 如果存储失败，尝试清理旧数据，只保留最近20条
                    try {
                        const reduced = history.slice(0, 20).map(item => {
                            const saved = { ...item };
                            // 移除所有可能很大的字段
                            if (saved.url && saved.url.startsWith('data:')) {
                                saved.url = saved.url.substring(0, 100) + '...';
                            }
                            if (saved.mjImages) saved.mjImages = null;
                            if (saved.mjImageInfo) delete saved.mjImageInfo;
                            return saved;
                        });
                        debouncedSaveHistory(reduced);
                    } catch (e2) {
                        console.error('清理后仍无法保存:', e2);
                        // 最后尝试：只保存最基本的字段
                        try {
                            const minimal = history.slice(0, 10).map(item => ({
                                id: item.id,
                                type: item.type,
                                prompt: item.prompt?.substring(0, 100),
                                time: item.time,
                                status: item.status,
                                modelName: item.modelName
                            }));
                            debouncedSaveHistory(minimal);
                        } catch (e3) {
                            console.error('最小化保存也失败:', e3);
                        }
                    }
                }
            }, [history, debouncedSaveHistory]);
            const debouncedSaveChatSessions = useMemo(() => debounce((sessions) => {
                try { localStorage.setItem('tapnow_chat_sessions', JSON.stringify(sessions)); } catch (e) {}
            }, 1000), []);
            useEffect(() => { debouncedSaveChatSessions(chatSessions); }, [chatSessions, debouncedSaveChatSessions]);
            useEffect(() => { 
                nodesRef.current = nodes; 
                selectedNodeIdRef.current = selectedNodeId;
                selectedNodeIdsRef.current = selectedNodeIds; // 同步更新多选节点ref
                connectionsRef.current = connections;
                isSelectingRef.current = isSelecting; // 同步更新框选状态ref
            }, [nodes, selectedNodeId, selectedNodeIds, connections, isSelecting]);

            // 使用 useMemo 创建 nodes Map，优化节点查找性能（O(1) 查找）
            const nodesMap = useMemo(() => {
                const map = new Map();
                nodes.forEach(node => {
                    map.set(node.id, node);
                });
                return map;
            }, [nodes]);

            // 使用 useMemo 创建 apiConfigs Map，优化配置查找性能（O(1) 查找）
            const apiConfigsMap = useMemo(() => {
                const map = new Map();
                apiConfigs.forEach(config => {
                    map.set(config.id, config);
                });
                return map;
            }, [apiConfigs]);

            // 使用 useMemo 创建 history Map，优化历史记录查找性能（O(1) 查找）
            const historyMap = useMemo(() => {
                const map = new Map();
                history.forEach(item => {
                    map.set(item.id, item);
                });
                return map;
            }, [history]);

            // 性能优化：计算可见节点（视口裁剪）
            const visibleNodes = useMemo(() => {
                if (!canvasRef.current) return nodes;
                
                const rect = canvasRef.current.getBoundingClientRect();
                const padding = 200; // 额外的渲染区域，避免边缘闪烁
                const currentView = viewRef.current;
                
                // 计算视口在世界坐标系中的范围
                const viewportLeft = (-currentView.x - padding) / currentView.zoom;
                const viewportRight = (rect.width - currentView.x + padding) / currentView.zoom;
                const viewportTop = (-currentView.y - padding) / currentView.zoom;
                const viewportBottom = (rect.height - currentView.y + padding) / currentView.zoom;
                
                // 过滤出在视口内或附近的节点
                return nodes.filter(node => {
                    const nodeRight = node.x + (node.width || 0);
                    const nodeBottom = node.y + (node.height || 0);
                    
                    // 检查节点是否与视口相交
                    return node.x < viewportRight && 
                           nodeRight > viewportLeft && 
                           node.y < viewportBottom && 
                           nodeBottom > viewportTop;
                });
            }, [nodes, view.x, view.y, view.zoom]);

            // 性能优化：根据 zoom 计算 LOD 细节等级
            const getDetailLevel = useCallback((zoom) => {
                if (zoom >= 0.8) return 'high';
                if (zoom >= 0.4) return 'medium';
                return 'low';
            }, []);

            // 同步 viewRef 和 view state
            useEffect(() => {
                viewRef.current = view;
            }, [view]);

            // 使用 useMemo 缓存连接相关的计算，避免重复计算
            const connectionsByNode = useMemo(() => {
                const byNode = {
                    to: new Map(), // nodeId -> connections[]
                    from: new Map() // nodeId -> connections[]
                };
                connections.forEach(conn => {
                    if (!byNode.to.has(conn.to)) {
                        byNode.to.set(conn.to, []);
                    }
                    byNode.to.get(conn.to).push(conn);
                    
                    if (!byNode.from.has(conn.from)) {
                        byNode.from.set(conn.from, []);
                    }
                    byNode.from.get(conn.from).push(conn);
                });
                return byNode;
            }, [connections]);
            
            // 实时更新节点计时器
            useEffect(() => {
                const interval = setInterval(() => {
                    const now = Date.now();
                    const activeTasks = history.filter(h => 
                        h.sourceNodeId && 
                        h.status === 'generating' && 
                        h.startTime
                    );
                    
                    const newTimers = {};
                    activeTasks.forEach(task => {
                        const elapsed = Math.floor((now - task.startTime) / 100);
                        newTimers[task.sourceNodeId] = elapsed / 10; // 转换为秒，保留1位小数
                    });
                    
                    setNodeTimers(newTimers);
                }, 100); // 每100ms更新一次
                
                return () => clearInterval(interval);
            }, [history]);
            
            // 检查并重新切割需要切割的Midjourney图片（使用useRef避免重复切割）
            const splittingRef = useRef(new Set());
            useEffect(() => {
                history.forEach(item => {
                    if (item.mjNeedsSplit && item.mjOriginalUrl && item.apiConfig?.modelId?.includes('mj') && item.status === 'completed') {
                        // 避免重复切割
                        if (splittingRef.current.has(item.id)) {
                            return;
                        }
                        splittingRef.current.add(item.id);
                        
                        // 延迟切割，避免阻塞UI
                        setTimeout(() => {
                            // 获取比例信息
                            let ratio = item.mjRatio || '1:1';
                            if (item.prompt && item.prompt.includes('--ar ')) {
                                const arMatch = item.prompt.match(/--ar\s+([\d:]+)/);
                                if (arMatch && arMatch[1]) {
                                    ratio = arMatch[1];
                                }
                            }
                            
                            console.log(`Midjourney: 开始重新切割图片，任务ID: ${item.id}, 比例: ${ratio}`);
                            
                            // 重新切割图片
                            splitMidjourneyImage(item.mjOriginalUrl, ratio).then((splitImages) => {
                                const imageUrls = splitImages.map(img => typeof img === 'string' ? img : img.url);
                                const firstImage = splitImages[0];
                                const firstUrl = typeof firstImage === 'string' ? firstImage : firstImage.url;
                                
                                setHistory((prev) => prev.map((hItem) => 
                                    hItem.id === item.id 
                                        ? { 
                                            ...hItem, 
                                            mjImages: imageUrls, 
                                            url: firstUrl, 
                                            selectedMjImageIndex: 0,
                                            mjRatio: ratio,
                                            mjNeedsSplit: false, // 标记已切割
                                            mjImageInfo: splitImages.map(img => typeof img === 'string' ? null : { width: img.width, height: img.height, ratio: img.ratio })
                                        } 
                                        : hItem
                                ));
                                
                                splittingRef.current.delete(item.id);
                                console.log(`Midjourney: 重新切割完成，任务ID: ${item.id}`);
                            }).catch((err) => {
                                console.error('Midjourney: 重新切割图片失败:', err);
                                splittingRef.current.delete(item.id);
                                // 保持原图显示，标记需要重新切割
                                setHistory((prev) => prev.map((hItem) => 
                                    hItem.id === item.id 
                                        ? { ...hItem, mjNeedsSplit: true } 
                                        : hItem
                                ));
                            });
                        }, 500); // 延迟500ms，确保UI已完全渲染
                    }
                });
            }, [history]);

            const handleChatResizeStart = (e) => { e.preventDefault(); setIsResizingChat(true); }; 
            const [isResizingChat, setIsResizingChat] = useState(false);

            const handleChatResizeMove = useCallback((e) => {
                if (!isResizingChat) return;
                const newWidth = window.innerWidth - e.clientX;
                setChatWidth(Math.max(300, Math.min(newWidth, 800)));
            }, [isResizingChat]);

            const handleChatResizeEnd = useCallback(() => {
                setIsResizingChat(false);
            }, []);

            // 屏蔽滚轮事件相关的控制台错误（passive 事件监听器错误）- 双重保护
            useEffect(() => {
                const originalError = console.error;
                const originalWarn = console.warn;
                
                const shouldFilter = (args) => {
                    const msg = args.map(arg => {
                        if (typeof arg === 'string') return arg;
                        if (arg && arg.toString) return arg.toString();
                        return '';
                    }).join(' ');
                    return msg.includes('Unable to preventDefault') || 
                           msg.includes('passive event listener') ||
                           (msg.includes('preventDefault') && msg.includes('passive'));
                };
                
                console.error = function(...args) {
                    if (shouldFilter(args)) return;
                    originalError.apply(console, args);
                };
                
                console.warn = function(...args) {
                    if (shouldFilter(args)) return;
                    originalWarn.apply(console, args);
                };
                
                return () => {
                    console.error = originalError;
                    console.warn = originalWarn;
                };
            }, []);

            // 全局禁止 Ctrl+滚轮 缩放（捕获阶段，阻止浏览器缩放）；使用 try-catch 避免控制台报错
            useEffect(() => {
                const preventCtrlZoom = (e) => {
                    if (!e.ctrlKey) return;
                    try {
                        if (e.cancelable) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    } catch (err) {
                        // 静默处理 passive 事件监听器的错误
                    }
                };

                const opts = { passive: false, capture: true };
                window.addEventListener('wheel', preventCtrlZoom, opts);
                document.addEventListener('wheel', preventCtrlZoom, opts);
                window.addEventListener('mousewheel', preventCtrlZoom, opts);
                document.addEventListener('mousewheel', preventCtrlZoom, opts);

                return () => {
                    window.removeEventListener('wheel', preventCtrlZoom, opts);
                    document.removeEventListener('wheel', preventCtrlZoom, opts);
                    window.removeEventListener('mousewheel', preventCtrlZoom, opts);
                    document.removeEventListener('mousewheel', preventCtrlZoom, opts);
                };
            }, []);

            // 使用原生事件监听器绑定 handleWheel，避免 React 合成事件的 passive 问题
            useEffect(() => {
                const canvasElement = canvasRef.current;
                if (!canvasElement) return;

                const wheelHandler = (e) => {
                    // 如果按下了 Ctrl 键，直接阻止默认行为并不执行任何操作；使用 try-catch 避免控制台报错
                    if (e.ctrlKey) {
                        try {
                            if (e.cancelable) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        } catch (err) {
                            // 静默处理 passive 事件监听器的错误
                        }
                        return;
                    }

                    // 检查鼠标是否在视频输入、视频拆解或智能分镜表节点内
                    const target = e.target;
                    let isInsideNode = false;
                    let scrollableElement = null;
                    
                    // 向上查找父元素，检查是否在 video-input、video-analyze 或 storyboard-node 节点内
                    let current = target;
                    while (current && current !== canvasElement) {
                        if (current.classList) {
                            // 检查是否是智能分镜表容器（通过检查是否有特定的类组合）
                            const isStoryboardContainer = current.classList.contains('flex') && 
                                                         current.classList.contains('flex-col') && 
                                                         current.classList.contains('h-full') && 
                                                         current.classList.contains('rounded-xl') &&
                                                         current.classList.contains('overflow-hidden');
                            
                            // 检查当前元素或父元素是否包含节点容器类
                            if (current.classList.contains('video-input-container') || 
                                current.classList.contains('video-analyze-container') ||
                                isStoryboardContainer) {
                                isInsideNode = true;
                                
                                // 如果是智能分镜表，查找特定的滚动容器
                                if (isStoryboardContainer) {
                                    scrollableElement = current.querySelector('.flex-1.overflow-y-auto.custom-scrollbar');
                                    if (!scrollableElement) {
                                        scrollableElement = current.querySelector('.flex-1.overflow-y-auto');
                                    }
                                } else {
                                // 在当前容器内查找可滚动的元素
                                scrollableElement = current.querySelector('.overflow-y-auto, .custom-scrollbar, [class*="overflow-y"]');
                                if (!scrollableElement) {
                                    // 如果没找到，检查当前元素本身是否可滚动
                                    const style = window.getComputedStyle(current);
                                    if (style.overflowY === 'auto' || style.overflowY === 'scroll' || 
                                        current.classList.contains('custom-scrollbar')) {
                                        scrollableElement = current;
                                        }
                                    }
                                }
                                break;
                            }
                            
                            // 使用 closest 方法查找最近的容器
                            const container = current.closest('.video-input-container, .video-analyze-container');
                            if (container) {
                                isInsideNode = true;
                                scrollableElement = container.querySelector('.overflow-y-auto, .custom-scrollbar, [class*="overflow-y"]');
                                if (!scrollableElement) {
                                    const style = window.getComputedStyle(container);
                                    if (style.overflowY === 'auto' || style.overflowY === 'scroll') {
                                        scrollableElement = container;
                                    }
                                }
                                break;
                            }
                            
                            // 检查是否是智能分镜表容器
                            const storyboardContainer = current.closest('.flex.flex-col.h-full.rounded-xl.overflow-hidden');
                            if (storyboardContainer) {
                                isInsideNode = true;
                                scrollableElement = storyboardContainer.querySelector('.flex-1.overflow-y-auto.custom-scrollbar');
                                if (!scrollableElement) {
                                    scrollableElement = storyboardContainer.querySelector('.flex-1.overflow-y-auto');
                                }
                                break;
                            }
                        }
                        current = current.parentElement;
                    }
                    
                    // 如果在节点内且找到可滚动元素，则滚动该元素而不是缩放画布
                    if (isInsideNode && scrollableElement) {
                        try {
                            if (e.cancelable) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        } catch (err) {
                            // 静默处理 passive 事件监听器的错误
                        }
                        const maxScroll = scrollableElement.scrollHeight - scrollableElement.clientHeight;
                        const currentScroll = scrollableElement.scrollTop;
                        const newScroll = Math.max(0, Math.min(maxScroll, currentScroll + e.deltaY));
                        scrollableElement.scrollTop = newScroll;
                        return;
                    }
                    
                    // 否则正常缩放画布
                    try {
                        if (e.cancelable) {
                            e.preventDefault();
                        }
                    } catch (err) {
                        // 静默处理 passive 事件监听器的错误
                    }
                    const rect = canvasElement.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    setView((prev) => {
                        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                        let newZoom = Math.min(Math.max(prev.zoom * zoomFactor, 0.2), 3);
                        const scale = newZoom / prev.zoom;
                        return { zoom: newZoom, x: mouseX - (mouseX - prev.x) * scale, y: mouseY - (mouseY - prev.y) * scale };
                    });
                };

                // 使用 { passive: false } 确保可以调用 preventDefault
                canvasElement.addEventListener('wheel', wheelHandler, { passive: false });

                return () => {
                    canvasElement.removeEventListener('wheel', wheelHandler);
                };
            }, [view]);

            useEffect(() => {
                if (isResizingChat) {
                    window.addEventListener('mousemove', handleChatResizeMove);
                    window.addEventListener('mouseup', handleChatResizeEnd);
                } else {
                    window.removeEventListener('mousemove', handleChatResizeMove);
                    window.removeEventListener('mouseup', handleChatResizeEnd);
                }
                return () => {
                    window.removeEventListener('mousemove', handleChatResizeMove);
                    window.removeEventListener('mouseup', handleChatResizeEnd);
                };
            }, [isResizingChat, handleChatResizeMove, handleChatResizeEnd]);

            const screenToWorld = useCallback((sx, sy) => {
                const rect = canvasRef.current?.getBoundingClientRect();
                const localX = rect ? sx - rect.left : sx;
                const localY = rect ? sy - rect.top : sy;
                return { x: (localX - view.x) / view.zoom, y: (localY - view.y) / view.zoom };
            }, [view]);

            const handleWheel = (e) => {
                // 如果按下了 Ctrl 键，直接阻止默认行为并不执行任何操作；使用 try-catch 避免控制台报错
                if (e.ctrlKey) {
                    try {
                        if (e.cancelable) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    } catch (err) {
                        // 静默处理 passive 事件监听器的错误
                    }
                    return;
                }

                // 检查鼠标是否在视频输入或视频拆解节点内
                const target = e.target;
                let isInsideNode = false;
                let scrollableElement = null;
                
                // 向上查找父元素，检查是否在 video-input 或 video-analyze 节点内
                let current = target;
                while (current && current !== e.currentTarget) {
                    if (current.classList) {
                        // 检查当前元素或父元素是否包含节点容器类
                        if (current.classList.contains('video-input-container') || 
                            current.classList.contains('video-analyze-container')) {
                            isInsideNode = true;
                            // 在当前容器内查找可滚动的元素
                            scrollableElement = current.querySelector('.overflow-y-auto, .custom-scrollbar, [class*="overflow-y"]');
                            if (!scrollableElement) {
                                // 如果没找到，检查当前元素本身是否可滚动
                                const style = window.getComputedStyle(current);
                                if (style.overflowY === 'auto' || style.overflowY === 'scroll' || 
                                    current.classList.contains('custom-scrollbar')) {
                                    scrollableElement = current;
                                }
                            }
                            break;
                        }
                        // 使用 closest 方法查找最近的容器
                        const container = current.closest('.video-input-container, .video-analyze-container');
                        if (container) {
                            isInsideNode = true;
                            scrollableElement = container.querySelector('.overflow-y-auto, .custom-scrollbar, [class*="overflow-y"]');
                            if (!scrollableElement) {
                                const style = window.getComputedStyle(container);
                                if (style.overflowY === 'auto' || style.overflowY === 'scroll') {
                                    scrollableElement = container;
                                }
                            }
                            break;
                        }
                    }
                    current = current.parentElement;
                }
                
                // 如果在节点内且找到可滚动元素，则滚动该元素而不是缩放画布
                if (isInsideNode && scrollableElement) {
                    try {
                        if (e.cancelable) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    } catch (err) {
                        // 静默处理 passive 事件监听器的错误
                    }
                    const maxScroll = scrollableElement.scrollHeight - scrollableElement.clientHeight;
                    const currentScroll = scrollableElement.scrollTop;
                    const newScroll = Math.max(0, Math.min(maxScroll, currentScroll + e.deltaY));
                    scrollableElement.scrollTop = newScroll;
                    return;
                }
                
                // 否则正常缩放画布
                try {
                    if (e.cancelable) {
                        e.preventDefault();
                    }
                } catch (err) {
                    // 静默处理 passive 事件监听器的错误
                }
                const rect = e.currentTarget.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                setView((prev) => {
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    let newZoom = Math.min(Math.max(prev.zoom * zoomFactor, 0.2), 3);
                    const scale = newZoom / prev.zoom;
                    return { zoom: newZoom, x: mouseX - (mouseX - prev.x) * scale, y: mouseY - (mouseY - prev.y) * scale };
                });
            };

            const handleMouseDown = (e) => {
                if (e.button === 0 || e.button === 1) {
                    if (e.currentTarget.id === 'canvas-bg') {
                        // 检查是否有文本选择，如果有则不启动拖动
                        const selection = window.getSelection();
                        if (selection && selection.toString().length > 0) {
                            return; // 如果有文本选择，不处理拖动
                        }
                        
                        // 检查是否点击在可交互元素上（input, textarea, select, button等）
                        const target = e.target;
                        if (target && (
                            target.tagName === 'INPUT' ||
                            target.tagName === 'TEXTAREA' ||
                            target.tagName === 'SELECT' ||
                            target.tagName === 'BUTTON' ||
                            target.isContentEditable ||
                            target.closest('input, textarea, select, button, [contenteditable="true"]')
                        )) {
                            return; // 如果点击在可交互元素上，不处理拖动
                        }
                        
                        // 检测Ctrl+鼠标左键，开始框选
                        if (e.button === 0 && (e.ctrlKey || e.metaKey)) {
                            e.preventDefault();
                            setIsSelecting(true);
                            isSelectingRef.current = true; // 设置ref标志
                            setIsPanning(false);
                            const rect = canvasRef.current?.getBoundingClientRect();
                            const startX = e.clientX - (rect?.left || 0);
                            const startY = e.clientY - (rect?.top || 0);
                            setSelectionBox({ startX, startY, endX: startX, endY: startY });
                            setSelectedNodeIds(new Set()); // 清空之前的选择
                            setSelectedNodeId(null);
                            return;
                        }
                        // 普通拖动画布（只有在不是框选状态时才能拖拽）
                        if (!isSelectingRef.current) {
                            setIsPanning(true);
                            setIsDragging(false);
                            lastMousePos.current = { x: e.clientX, y: e.clientY };
                        }
                    }
                }
            };

            const nodeUpdateRef = useRef(null);
            const nodeUpdateRaf = useRef(null);
            const multiNodeUpdateRef = useRef(null); // 多节点更新ref

            const flushNodeUpdate = useCallback(() => {
                // 优先处理多节点更新
                if (multiNodeUpdateRef.current) {
                    const updates = multiNodeUpdateRef.current;
                    setNodes((prev) => {
                        const next = [...prev];
                        let hasChanges = false;
                        updates.forEach(({ nodeId, updater }) => {
                            const idx = next.findIndex((n) => n.id === nodeId);
                            if (idx !== -1) {
                                const updatedNode = updater(next[idx]);
                                if (updatedNode !== next[idx]) {
                                    next[idx] = updatedNode;
                                    hasChanges = true;
                                }
                            }
                        });
                        return hasChanges ? next : prev;
                    });
                    multiNodeUpdateRef.current = null;
                    nodeUpdateRaf.current = null;
                    return;
                }
                
                if (!nodeUpdateRef.current) {
                    nodeUpdateRaf.current = null;
                    return;
                }
                const { nodeId, updater } = nodeUpdateRef.current;
                setNodes((prev) => {
                    const idx = prev.findIndex((n) => n.id === nodeId);
                    if (idx === -1) return prev;
                    // 使用函数式更新，避免创建新数组的开销
                    const updatedNode = updater(prev[idx]);
                    // 如果节点没有变化，直接返回原数组（引用相等检查）
                    if (updatedNode === prev[idx]) return prev;
                    const next = [...prev];
                    next[idx] = updatedNode;
                    return next;
                });
                nodeUpdateRef.current = null;
                nodeUpdateRaf.current = null;
            }, []);

            const scheduleNodeUpdate = useCallback((nodeId, updater) => {
                nodeUpdateRef.current = { nodeId, updater };
                if (!nodeUpdateRaf.current) {
                    nodeUpdateRaf.current = requestAnimationFrame(flushNodeUpdate);
                }
            }, [flushNodeUpdate]);

            const scheduleMultiNodeUpdate = useCallback((updates) => {
                multiNodeUpdateRef.current = updates;
                if (!nodeUpdateRaf.current) {
                    nodeUpdateRaf.current = requestAnimationFrame(flushNodeUpdate);
                }
            }, [flushNodeUpdate]);

            useEffect(() => {
                return () => {
                    if (nodeUpdateRaf.current) {
                        cancelAnimationFrame(nodeUpdateRaf.current);
                    }
                };
            }, []);

            // 使用 requestAnimationFrame 节流框选逻辑
            const selectionRafRef = useRef(null);
            const pendingSelectionUpdate = useRef(null);

            const handleMouseMove = useCallback((e) => {
                const { clientX, clientY } = e;
                const worldPos = screenToWorld(clientX, clientY);
                setMousePos(worldPos);

                // 框选模式 - 使用 requestAnimationFrame 节流
                // 使用ref检查，确保即使Ctrl松开也能继续框选
                if (isSelecting || isSelectingRef.current) {
                    // 如果isSelecting为false但ref为true，说明Ctrl松开了，但框选应该继续
                    if (!isSelecting) {
                        setIsSelecting(true);
                    }
                    const rect = canvasRef.current?.getBoundingClientRect();
                    const endX = clientX - (rect?.left || 0);
                    const endY = clientY - (rect?.top || 0);
                    
                    // 立即更新框选框位置（视觉反馈）
                    setSelectionBox(prev => {
                        if (!prev) return null;
                        return { ...prev, endX, endY };
                    });
                    
                    // 节流节点选择计算
                    pendingSelectionUpdate.current = { endX, endY, rect };
                    
                    if (!selectionRafRef.current) {
                        selectionRafRef.current = requestAnimationFrame(() => {
                            if (!pendingSelectionUpdate.current) {
                                selectionRafRef.current = null;
                                return;
                            }
                            
                            const { endX, endY, rect } = pendingSelectionUpdate.current;
                            const currentSelectionBox = selectionBox;
                            if (!currentSelectionBox) {
                                selectionRafRef.current = null;
                                return;
                            }
                            
                            // 计算被框选的节点
                            const boxStartX = Math.min(currentSelectionBox.startX, endX);
                            const boxStartY = Math.min(currentSelectionBox.startY, endY);
                            const boxEndX = Math.max(currentSelectionBox.startX, endX);
                            const boxEndY = Math.max(currentSelectionBox.startY, endY);
                            
                            // 将屏幕坐标转换为世界坐标
                            const worldStart = screenToWorld(boxStartX + (rect?.left || 0), boxStartY + (rect?.top || 0));
                            const worldEnd = screenToWorld(boxEndX + (rect?.left || 0), boxEndY + (rect?.top || 0));
                            
                            // 使用 ref 获取最新的 nodes，避免闭包问题
                            const currentNodes = nodesRef.current;
                            const selected = new Set();
                            currentNodes.forEach(node => {
                                const nodeRight = node.x + node.width;
                                const nodeBottom = node.y + node.height;
                                // 检查节点是否与框选框相交
                                if (node.x < worldEnd.x && nodeRight > worldStart.x &&
                                    node.y < worldEnd.y && nodeBottom > worldStart.y) {
                                    selected.add(node.id);
                                }
                            });
                            setSelectedNodeIds(selected);
                            
                            pendingSelectionUpdate.current = null;
                            selectionRafRef.current = null;
                        });
                    }
                    return;
                }

                // 只有在不是框选状态时才能拖拽画布
                if (isPanning && !isSelectingRef.current) {
                    setIsDragging(true);
                    const dx = clientX - lastMousePos.current.x;
                    const dy = clientY - lastMousePos.current.y;
                    // 使用函数式更新，避免依赖 view
                    setView((prev) => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
                    lastMousePos.current = { x: clientX, y: clientY };
                    return;
                }

                if (resizingNodeId) {
                    scheduleNodeUpdate(resizingNodeId, (node) => ({
                        ...node,
                        width: Math.max(250, worldPos.x - node.x),
                        height: Math.max(250, worldPos.y - node.y)
                    }));
                } else if (dragNodeId) {
                    // 使用 movementX/Y 更流畅，避免频繁计算
                    const deltaX = e.movementX / view.zoom;
                    const deltaY = e.movementY / view.zoom;
                    // 添加阈值，避免微小移动触发更新
                    if (Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
                        // 使用 ref 获取最新的多选节点集合，避免闭包问题
                        const currentSelectedNodeIds = selectedNodeIdsRef.current;
                        // 如果有多选节点（大于1个）且被拖动的节点在选中集合中，同时拖动所有选中的节点
                        if (currentSelectedNodeIds && currentSelectedNodeIds.size > 1 && currentSelectedNodeIds.has(dragNodeId)) {
                            // 拖动多个节点时，使用批量更新
                            const updates = Array.from(currentSelectedNodeIds).map(nodeId => ({
                                nodeId,
                                updater: (node) => ({
                                    ...node,
                                    x: node.x + deltaX,
                                    y: node.y + deltaY
                                })
                            }));
                            scheduleMultiNodeUpdate(updates);
                        } else {
                            scheduleNodeUpdate(dragNodeId, (node) => ({
                                ...node,
                                x: node.x + deltaX,
                                y: node.y + deltaY
                            }));
                        }
                    }
                }
            }, [isPanning, isSelecting, selectionBox, dragNodeId, resizingNodeId, screenToWorld, view.zoom, scheduleNodeUpdate, scheduleMultiNodeUpdate]);

            const handleMouseUp = () => {
                // 结束框选
                if (isSelecting) {
                    setIsSelecting(false);
                    setSelectionBox(null);
                    // 如果只选中一个节点，设置selectedNodeId
                    if (selectedNodeIds.size === 1) {
                        const nodeId = Array.from(selectedNodeIds)[0];
                        setSelectedNodeId(nodeId);
                    } else if (selectedNodeIds.size === 0) {
                        setSelectedNodeId(null);
                    }
                    // 确保清理拖动状态
                    setIsDragging(false);
                    setIsPanning(false);
                    return;
                }
                
                if (isPanning) {
                    setIsPanning(false);
                    setIsDragging(false); // 确保清理拖动状态
                    if (!connectingSource && !connectingTarget && !dragNodeId && !resizingNodeId) {
                        setSelectedNodeId(null);
                        setSelectedNodeIds(new Set());
                        setContextMenu(prev => ({ ...prev, visible: false }));
                        setActiveDropdown(null);
                        setHistoryContextMenu(prev => ({ ...prev, visible: false }));
                    }
                }
                if (!connectingSource && !connectingTarget) { 
                    setDragNodeId(null); 
                    setResizingNodeId(null); 
                }
                // 确保在所有情况下都清理拖动状态
                setIsDragging(false);
            };

            // 优化后的全局鼠标事件监听：解决拖动中断和连线不跟随的问题
            useEffect(() => {
                // 定义需要全局监听的状态
                const isInteracting = isPanning || isDragging || dragNodeId || resizingNodeId || isSelecting || connectingSource || connectingTarget;

                if (!isInteracting) return;

                const handleGlobalMouseMove = (e) => {
                    // 确保在任何交互状态下都更新鼠标位置
                    handleMouseMove(e);
                };

                const handleGlobalMouseUp = (e) => {
                    handleMouseUp(e);
                };

                // 绑定到 window，确保鼠标移出浏览器或 canvas 区域也能响应
                window.addEventListener('mousemove', handleGlobalMouseMove, { passive: false });
                window.addEventListener('mouseup', handleGlobalMouseUp, { passive: false });

                return () => {
                    window.removeEventListener('mousemove', handleGlobalMouseMove);
                    window.removeEventListener('mouseup', handleGlobalMouseUp);
                };
            }, [isPanning, isDragging, dragNodeId, resizingNodeId, isSelecting, connectingSource, connectingTarget, handleMouseMove, handleMouseUp]);

            const handleNodeMouseUp = useCallback((targetId, e, inputType = 'default') => {
                e.stopPropagation();
                // 从输出端口连接到输入端口（原有逻辑）
                if (connectingSource && connectingSource !== targetId) {
                    // 检查是否已存在相同输入点的连接
                    const exists = connections.some((c) => 
                        c.from === connectingSource && 
                        c.to === targetId && 
                        (c.inputType || 'default') === inputType
                    );
                    if (!exists) {
                        // 如果连接到特定输入点，先删除该输入点的旧连接
                        if (inputType !== 'default') {
                            setConnections((prev) => prev.filter((c) => 
                                !(c.to === targetId && (c.inputType || 'default') === inputType)
                            ));
                        }
                        setConnections((prev) => [...prev, { 
                            id: `conn-${Date.now()}`, 
                            from: connectingSource, 
                            to: targetId,
                            inputType: inputType !== 'default' ? inputType : undefined
                        }]);
                    }
                }
                // 从输入端口连接到输出端口（新功能）
                else if (connectingTarget && connectingTarget !== targetId) {
                    // 使用connectingInputType而不是inputType参数（因为是从输入端口开始的连接）
                    const actualInputType = connectingInputType || inputType;
                    // 检查是否已存在相同输入点的连接
                    const exists = connections.some((c) => 
                        c.from === targetId && 
                        c.to === connectingTarget && 
                        (c.inputType || 'default') === actualInputType
                    );
                    if (!exists) {
                        // 如果连接到特定输入点，先删除该输入点的旧连接
                        if (actualInputType !== 'default') {
                            setConnections((prev) => prev.filter((c) => 
                                !(c.to === connectingTarget && (c.inputType || 'default') === actualInputType)
                            ));
                        }
                        setConnections((prev) => [...prev, { 
                            id: `conn-${Date.now()}`, 
                            from: targetId, 
                            to: connectingTarget,
                            inputType: actualInputType !== 'default' ? actualInputType : undefined
                        }]);
                    }
                }
                setConnectingSource(null);
                setConnectingTarget(null);
                setConnectingInputType(null);
                setHoverTargetId(null);
                setIsPanning(false);
                setDragNodeId(null);
                setResizingNodeId(null);
            }, [connectingSource, connectingTarget, connectingInputType, connections]);

            const handleBackgroundClick = (e) => {
                if (connectingSource) {
                    const world = screenToWorld(e.clientX, e.clientY);
                    setContextMenu({ visible: true, x: e.clientX, y: e.clientY, worldX: world.x, worldY: world.y, sourceNodeId: connectingSource });
                    setConnectingSource(null);
                } else if (connectingTarget) {
                    // 从输入端口开始的连接，点击背景时弹出参考图窗口
                    const world = screenToWorld(e.clientX, e.clientY);
                    setContextMenu({ visible: true, x: e.clientX, y: e.clientY, worldX: world.x, worldY: world.y, targetNodeId: connectingTarget, inputType: connectingInputType });
                    setConnectingTarget(null);
                    setConnectingInputType(null);
                }
            };

            const handleDoubleClick = (e) => {
                if (e.currentTarget.id === 'canvas-bg') {
                    const world = screenToWorld(e.clientX, e.clientY);
                    setContextMenu({ visible: true, x: e.clientX, y: e.clientY, worldX: world.x, worldY: world.y, sourceNodeId: undefined });
                }
            };
            
            // 使用 useMemo 缓存连接图片的计算结果，避免重复计算
            const connectedImagesCache = useMemo(() => {
                const cache = new Map(); // nodeId -> { inputType -> images[] }
                connections.forEach(conn => {
                    const inputType = conn.inputType || 'default';
                    if (!cache.has(conn.to)) {
                        cache.set(conn.to, new Map());
                    }
                    const nodeConnections = cache.get(conn.to);
                    if (!nodeConnections.has(inputType)) {
                        nodeConnections.set(inputType, []);
                    }
                    const sourceNode = nodesMap.get(conn.from);
                    if (sourceNode && ((sourceNode.type === 'input-image') || (sourceNode.type === 'video-input'))) {
                        let images = [];
                        if (sourceNode.type === 'video-input') {
                            const selected = sourceNode.selectedKeyframes && sourceNode.selectedKeyframes.length > 0 
                                ? sourceNode.selectedKeyframes.map(f => f.url) 
                                : [];
                            if (selected.length > 0) {
                                images = selected;
                            } else if (sourceNode.frames && sourceNode.frames.length > 0) {
                                images = [sourceNode.frames[0].url];
                            }
                        } else if (sourceNode.content) {
                            images = [sourceNode.content];
                        }
                        nodeConnections.get(inputType).push(...images);
                    }
                });
                return cache;
            }, [connections, nodesMap, nodes.length, nodes.map(n => `${n.id}:${n.type}:${n.content ? 'hasContent' : ''}:${n.selectedKeyframes?.length || 0}:${n.frames?.length || 0}`).join('|')]);

            const getConnectedInputImages = useCallback((targetNodeId, inputType = 'default') => {
                const nodeCache = connectedImagesCache.get(targetNodeId);
                if (!nodeCache) return [];
                return nodeCache.get(inputType) || [];
            }, [connectedImagesCache]);

            // 使用 useMemo 缓存 video-input 节点查找结果
            const connectedVideoInputCache = useMemo(() => {
                const cache = new Map(); // nodeId -> videoInputNode
                connections.forEach(conn => {
                    if (!cache.has(conn.to)) {
                        const sourceNode = nodesMap.get(conn.from);
                        if (sourceNode && sourceNode.type === 'video-input') {
                            cache.set(conn.to, sourceNode);
                        }
                    }
                });
                return cache;
            }, [connections, nodesMap]);

            // 获取连接的 video-input 节点（用于 video-analyze 节点）
            const getConnectedVideoInputNode = useCallback((targetNodeId) => {
                return connectedVideoInputCache.get(targetNodeId) || null;
            }, [connectedVideoInputCache]);

            // 获取连接的 video-analyze 节点（用于 storyboard-node 节点）
            const getConnectedVideoAnalyzeNode = useCallback((targetNodeId) => {
                for (const conn of connections) {
                    if (conn.to === targetNodeId) {
                        const sourceNode = nodesMap.get(conn.from);
                        if (sourceNode && sourceNode.type === 'video-analyze') {
                            return sourceNode;
                        }
                    }
                }
                return null;
            }, [connections, nodesMap]);

            // 功能2：获取连接的文字节点内容
            const getConnectedTextNodes = useCallback((targetNodeId) => {
                const texts = [];
                connections.forEach(conn => {
                    if (conn.to === targetNodeId) {
                        const sourceNode = nodesMap.get(conn.from);
                        if (sourceNode && sourceNode.type === 'text-node') {
                            const text = sourceNode.settings?.text || '';
                            if (text) texts.push(text);
                        }
                    }
                });
                return texts;
            }, [connections, nodesMap]);

            // 使用 useMemo 缓存特定输入点的图片URL
            const connectedImageForInputCache = useMemo(() => {
                const cache = new Map(); // `${nodeId}:${inputType}` -> imageUrl
                connections.forEach(conn => {
                    const inputType = conn.inputType || 'default';
                    const key = `${conn.to}:${inputType}`;
                    if (!cache.has(key)) {
                        const sourceNode = nodesMap.get(conn.from);
                        if (sourceNode) {
                            let imageUrl = null;
                            if (sourceNode.type === 'video-input') {
                                const selected = sourceNode.selectedKeyframes && sourceNode.selectedKeyframes.length > 0 
                                    ? sourceNode.selectedKeyframes[0].url 
                                    : null;
                                if (selected) {
                                    imageUrl = selected;
                                } else if (sourceNode.frames && sourceNode.frames[0]) {
                                    imageUrl = sourceNode.frames[0].url;
                                }
                            } else if (sourceNode.type === 'input-image' && sourceNode.content) {
                                imageUrl = sourceNode.content;
                            }
                            if (imageUrl) {
                                cache.set(key, imageUrl);
                            }
                        }
                    }
                });
                return cache;
            }, [connections, nodesMap, nodes.length, nodes.map(n => `${n.id}:${n.type}:${n.content ? 'hasContent' : ''}:${n.selectedKeyframes?.[0]?.url || ''}:${n.frames?.[0]?.url || ''}`).join('|')]);

            // 获取连接到特定输入点的图片URL
            const getConnectedImageForInput = useCallback((targetNodeId, inputType) => {
                const key = `${targetNodeId}:${inputType || 'default'}`;
                return connectedImageForInputCache.get(key) || null;
            }, [connectedImageForInputCache]);


            // 将生成结果同步到连接的预览节点
            const updatePreviewFromTask = (taskId, url, contentType = 'image', sourceNodeIdOverride = null, mjImages = null) => {
                if (!url && (!mjImages || mjImages.length === 0)) return;
                // 找到对应的源节点ID
                let sourceNodeId = sourceNodeIdOverride;
                if (!sourceNodeId) {
                    const historyItem = historyMap.get(taskId);
                    sourceNodeId = historyItem?.sourceNodeId;
                }
                if (!sourceNodeId) {
                    console.warn('[Tapnow] updatePreviewFromTask: 未找到 sourceNodeId for taskId:', taskId);
                    return;
                }

                // 检查是否是从分镜表触发的生成，如果是则回填到分镜表
                // 使用 setTimeout 确保在下一个事件循环中执行，此时 nodes 和 connections 已更新
                setTimeout(() => {
                    const sourceNode = nodesMap.get(sourceNodeId);
                    if (sourceNode && (sourceNode.type === 'gen-image' || sourceNode.type === 'gen-video')) {
                        // 查找连接到该生成节点的分镜表节点
                        const storyboardConnections = connections.filter(c => c.to === sourceNodeId);
                        for (const conn of storyboardConnections) {
                            const fromNode = nodesMap.get(conn.from);
                            const storyboardNode = fromNode && fromNode.type === 'storyboard-node' ? fromNode : null;
                            if (storyboardNode && storyboardNode.settings?.shots) {
                                // 查找状态为 generating 的 shot，回填结果
                                const generatingShot = storyboardNode.settings.shots.find(s => s.status === 'generating');
                                if (generatingShot) {
                                    const finalUrl = url || (mjImages && mjImages.length > 0 ? mjImages[0] : null);
                                    if (finalUrl) {
                                        updateShot(storyboardNode.id, generatingShot.id, {
                                            image_url: finalUrl,
                                            status: 'done'
                                        });
                                        break; // 只回填第一个找到的
                                    }
                                }
                            }
                        }
                    }
                }, 0);

                // 使用 ref 获取最新的 connections 状态，避免闭包问题
                const latestConnections = connectionsRef.current;
                console.log('[Tapnow] updatePreviewFromTask: 更新预览窗口', { taskId, url, contentType, sourceNodeId, mjImages, connectionsCount: latestConnections.length });
                
                // 使用函数式更新，确保获取最新的 connections 状态
                setNodes((prevNodes) => {
                    // 使用 ref 中的最新 connections
                    const targetIds = latestConnections
                        .filter((c) => c.from === sourceNodeId)
                        .map((c) => c.to);
                    
                    console.log('[Tapnow] updatePreviewFromTask: 检查连接', { 
                        sourceNodeId, 
                        allConnectionsFromSource: latestConnections.filter(c => c.from === sourceNodeId),
                        targetIds,
                        allNodes: prevNodes.map(n => ({ id: n.id, type: n.type }))
                    });
                    
                    if (!targetIds.length) {
                        console.warn('[Tapnow] updatePreviewFromTask: 未找到连接到预览窗口的连接', { 
                            sourceNodeId, 
                            connectionsFromSource: latestConnections.filter(c => c.from === sourceNodeId),
                            allConnections: latestConnections
                        });
                        return prevNodes;
                    }
                    
                    const previewNodes = prevNodes.filter(n => targetIds.includes(n.id) && n.type === 'preview');
                    console.log('[Tapnow] updatePreviewFromTask: 找到预览节点', { 
                        targetIds, 
                        previewNodes: previewNodes.map(n => ({ id: n.id, type: n.type }))
                    });
                    
                    return prevNodes.map((n) => 
                        targetIds.includes(n.id) && n.type === 'preview'
                            ? { ...n, content: url || (mjImages && mjImages.length > 0 ? mjImages[0] : url), previewType: contentType, previewMjImages: mjImages }
                            : n
                    );
                });
            };

            const deleteHistoryItem = (id) => {
                setHistory(prev => {
                    const filtered = prev.filter(item => item.id !== id);
                    // 立即保存到 localStorage，不等待防抖
                    try {
                        localStorage.setItem('tapnow_history', JSON.stringify(filtered));
                    } catch (e) {
                        console.error('立即保存历史记录失败:', e);
                    }
                    return filtered;
                });
                if (historyContextMenu.item && historyContextMenu.item.id === id) {
                    setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
                }
            };

            const addNewModel = () => {
                const newConfig = { id: `custom-${Date.now()}`, provider: 'New Model', modelName: 'new-model-id', type: 'Chat', key: '', url: DEFAULT_BASE_URL, isCustom: true };
                setApiConfigs([...apiConfigs, newConfig]);
            };
            const updateApiConfig = (id, updates) => setApiConfigs((prev) => prev.map((c) => (c.id === id ? { ...c, ...updates } : c)));
            const deleteApiConfig = (id) => setApiConfigs((prev) => prev.filter((c) => c.id !== id));

            const testApiConnection = async (id) => {
                setApiTesting(id);
                setApiStatus((prev) => ({ ...prev, [id]: 'idle' }));
                const config = apiConfigsMap.get(id);
                const apiKey = config?.key || globalApiKey;

                if (!apiKey) {
                    setApiStatus((prev) => ({ ...prev, [id]: 'error' }));
                    setApiTesting(null);
                    return;
                }

                try {
                    const response = await fetch(`${config?.url || DEFAULT_BASE_URL}/v1/models`, {
                        method: 'GET',
                        headers: { Authorization: `Bearer ${apiKey}` },
                    });
                    if (response.ok) setApiStatus((prev) => ({ ...prev, [id]: 'success' }));
                    else setApiStatus((prev) => ({ ...prev, [id]: 'error' }));
                } catch {
                    setApiStatus((prev) => ({ ...prev, [id]: 'error' }));
                }
                setApiTesting(null);
            };

            const getStatusColor = (modelId) => {
                if (!modelId) return 'bg-zinc-600';
                const status = apiStatus[modelId];
                if (status === 'success') return 'bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.8)]';
                if (status === 'error') return 'bg-red-500';
                const config = apiConfigsMap.get(modelId);
                return (config?.key || globalApiKey) ? 'bg-zinc-400' : 'bg-zinc-700';
            };

            const currentSession = useMemo(() => chatSessions.find(s => s.id === currentChatId) || chatSessions[0], [chatSessions, currentChatId]);

            const scrollToBottom = () => {
                chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
            };

            useEffect(() => {
                scrollToBottom();
            }, [currentSession?.messages, isChatOpen]);

            const createNewChat = () => {
                const newId = `chat-${Date.now()}`;
                const newSession = { id: newId, title: '新对话', messages: [] };
                setChatSessions(prev => [newSession, ...prev]);
                setCurrentChatId(newId);
            };

            const deleteChatSession = (e, id) => {
                e.stopPropagation();
                const newSessions = chatSessions.filter(s => s.id !== id);
                if (newSessions.length === 0) {
                    const defaultSession = { id: 'default', title: '新对话', messages: [] };
                    setChatSessions([defaultSession]);
                    setCurrentChatId('default');
                } else {
                    setChatSessions(newSessions);
                    if (currentChatId === id) setCurrentChatId(newSessions[0].id);
                }
            };

            const handleChatFileUpload = (e) => {
                const files = Array.from(e.target.files);
                files.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const content = ev.target.result;
                        const fileExt = file.name.split('.').pop()?.toLowerCase() || '';
                        
                        // 判断文件类型
                        const isImage = file.type.startsWith('image/');
                        const isVideo = file.type.startsWith('video/');
                        const isAudio = file.type.startsWith('audio/');
                        const isPDF = file.type === 'application/pdf' || fileExt === 'pdf';
                        const isDoc = ['doc', 'docx'].includes(fileExt) || file.type.includes('word');
                        const isExcel = ['xls', 'xlsx'].includes(fileExt) || file.type.includes('excel') || file.type.includes('spreadsheet');
                        const isCode = ['js', 'jsx', 'ts', 'tsx', 'py', 'java', 'cpp', 'c', 'html', 'css', 'json', 'xml', 'yaml', 'yml', 'md', 'txt', 'sh', 'bash'].includes(fileExt);
                        
                        setChatFiles(prev => [...prev, {
                            name: file.name,
                            type: file.type,
                            content: content, 
                            isImage,
                            isVideo,
                            isAudio,
                            isPDF,
                            isDoc,
                            isExcel,
                            isCode,
                            fileExt
                        }]);
                    };
                    
                    // 根据文件类型选择读取方式
                    if (file.type.startsWith('image/') || file.type.startsWith('video/') || file.type.startsWith('audio/')) {
                        reader.readAsDataURL(file);
                    } else if (file.type === 'application/pdf') {
                        // PDF 也转换为 data URL
                        reader.readAsDataURL(file);
                    } else if (file.name.match(/\.(txt|md|js|jsx|ts|tsx|py|html|css|json|csv|xml|yaml|yml|sh|bash|java|cpp|c)$/i)) {
                        // 代码和文本文件读取为文本
                        reader.readAsText(file);
                    } else {
                        // 其他文件（如 Word、Excel）也尝试读取为 data URL
                        reader.readAsDataURL(file);
                    }
                });
                e.target.value = '';
            };

            const removeChatFile = (index) => {
                setChatFiles(prev => prev.filter((_, i) => i !== index));
            };

            const sendChatMessage = async () => {
                if ((!chatInput.trim() && chatFiles.length === 0) || isChatSending) return;

                const config = apiConfigsMap.get(chatModel);
                const apiKey = config?.key || globalApiKey;
                const baseUrl = (config?.url || DEFAULT_BASE_URL).replace(/\/+$/, '');

                if (!apiKey) {
                    alert('请先在 API 设置中配置 Key');
                    setSettingsOpen(true);
                    return;
                }

                // 确保使用当前激活的会话（避免新建对话后第一条消息被写入旧会话）
                const chatIdToUse = currentChatId || chatSessions[0]?.id;
                const sessionToUse = chatSessions.find(s => s.id === chatIdToUse) || chatSessions[0];
                const currentSessionMessages = sessionToUse?.messages || [];
                if (sessionToUse && sessionToUse.id !== currentChatId) setCurrentChatId(sessionToUse.id);

                setIsChatSending(true);

                const newUserMsg = {
                    id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    role: 'user',
                    content: chatInput,
                    files: [...chatFiles], 
                    timestamp: Date.now(),
                    modelId: chatModel // 保存发送消息时使用的模型ID
                };
                
                setChatSessions(prev => prev.map(s => {
                    if (s.id === chatIdToUse) {
                        return { ...s, messages: [...s.messages, newUserMsg], title: s.messages.length === 0 ? chatInput.slice(0, 20) : s.title };
                    }
                    return s;
                }));
                setChatInput('');
                setChatFiles([]);

                // 构建带上下文的对话历史，帮助模型回顾上下文
                // 使用当前会话的消息加上新消息
                const allMessages = [...currentSessionMessages, newUserMsg];
                const MAX_HISTORY_MESSAGES = 20;
                const recentMessages = allMessages.length > MAX_HISTORY_MESSAGES
                    ? allMessages.slice(-MAX_HISTORY_MESSAGES)
                    : allMessages;

                let apiMessages = [
                    {
                        role: 'system',
                        content: '你是一名多模态AI助手，需要结合整个对话的上下文进行连续回答。'
                    },
                    ...recentMessages.map(m => ({
                        role: m.role,
                        content: m.content
                    }))
                ];

                const currentContent = [];
                if (newUserMsg.content) currentContent.push({ type: "text", text: newUserMsg.content });
                
                newUserMsg.files.forEach(f => {
                    const isGeminiLike = (config?.modelName ?? '').toLowerCase().includes('gemini');

                    if (f.isImage) {
                        currentContent.push({
                            type: "image_url",
                            image_url: { url: f.content }
                        });
                    } else if (f.isVideo) {
                        if (isGeminiLike) {
                            // Gemini 视频分析：按官方规范也走 image_url，url 直接指向 mp4
                            currentContent.push({
                                type: "image_url",
                                image_url: { url: f.content }
                            });
                        } else {
                            currentContent.push({
                                type: "text",
                                text: `\n[User attached video: ${f.name}]\n`
                            });
                        }
                    } else if (f.isAudio) {
                        currentContent.push({
                            type: "text",
                            text: `\n[User attached audio: ${f.name}]\n`
                        });
                    } else if (f.isPDF || f.isDoc || f.isExcel) {
                        // PDF、Word、Excel 等文档文件，发送文件名和类型信息
                        currentContent.push({
                            type: "text",
                            text: `\n[User attached document: ${f.name} (${f.isPDF ? 'PDF' : f.isDoc ? 'Word' : 'Excel'})]\n`
                        });
                    } else if (f.isCode || (f.content && typeof f.content === 'string' && f.content.length < 50000)) {
                        // 代码文件或文本文件，直接发送内容
                        currentContent.push({
                            type: "text",
                            text: `\n[File: ${f.name}]\n\`\`\`${f.fileExt || 'text'}\n${f.content}\n\`\`\`\n`
                        });
                    } else {
                        // 其他文件或二进制文件
                        currentContent.push({
                            type: "text",
                            text: `\n[User attached file: ${f.name}]\n`
                        });
                    }
                });

                apiMessages.push({ role: 'user', content: currentContent });

                try {
                    const response = await fetch(`${baseUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: config?.modelName || 'gemini-3-pro-preview',
                            messages: apiMessages,
                            stream: false 
                        })
                    });

                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(errText || `API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    // 支持多种响应格式
                    let aiContent = null;
                    if (data.choices && data.choices.length > 0) {
                        // OpenAI 格式: data.choices[0].message.content
                        aiContent = data.choices[0]?.message?.content;
                    } else if (data.content) {
                        // 直接 content 字段
                        aiContent = data.content;
                    } else if (data.text) {
                        // text 字段
                        aiContent = data.text;
                    } else if (data.message) {
                        // message 字段
                        aiContent = typeof data.message === 'string' ? data.message : data.message.content;
                    } else if (data.result) {
                        // result 字段
                        aiContent = typeof data.result === 'string' ? data.result : data.result.content;
                    } else if (data.data?.choices?.[0]?.message?.content) {
                        // 嵌套 data.choices 格式
                        aiContent = data.data.choices[0].message.content;
                    } else if (data.data?.content) {
                        // 嵌套 data.content 格式
                        aiContent = data.data.content;
                    } else if (data.data?.text) {
                        // 嵌套 data.text 格式
                        aiContent = data.data.text;
                    } else if (data.data?.message) {
                        // 嵌套 data.message 格式
                        aiContent = typeof data.data.message === 'string' ? data.data.message : data.data.message.content;
                    } else if (data.data?.result) {
                        // 嵌套 data.result 格式
                        aiContent = typeof data.data.result === 'string' ? data.data.result : data.data.result.content;
                    }
                    
                    if (!aiContent || aiContent.trim() === '') {
                        console.error('[聊天] API 响应内容为空:', data);
                        aiContent = "No response";
                    }

                    const newAssistantMsg = {
                        id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        role: 'assistant',
                        content: aiContent,
                        timestamp: Date.now(),
                        modelId: chatModel // 保存回复消息时使用的模型ID
                    };

                    setChatSessions(prev => prev.map(s => {
                        if (s.id === currentChatId) {
                            return { ...s, messages: [...s.messages, newAssistantMsg] };
                        }
                        return s;
                    }));

                } catch (error) {
                    console.error("Chat Error", error);
                    const errorMsg = {
                        id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        role: 'assistant',
                        content: `Error: ${error.message}`,
                        isError: true,
                        timestamp: Date.now()
                    };

                    setChatSessions(prev => prev.map(s => {
                        if (s.id === currentChatId) {
                            return { ...s, messages: [...s.messages, errorMsg] };
                        }
                        return s;
                    }));
                } finally {
                    setIsChatSending(false);
                }
            };

            // 获取 Blob 对象（兼容 HTTP URL 和 Blob URL）
            const getBlobFromUrl = async (url) => {
                const res = await fetch(url);
                return await res.blob();
            };

            // 获取 Base64 字符串（自动识别 Data URL 或 Blob URL 并转换）
            const getBase64FromUrl = async (url) => {
                if (url.startsWith('data:')) {
                    return url.split(',')[1];
                }
                const blob = await getBlobFromUrl(url);
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const res = reader.result;
                        // 返回纯 Base64 部分
                        resolve(res.split(',')[1]); 
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            };

            const blobToDataURL = (blob) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            };

            // 辅助函数：将 Base64 Data URL 转换为 Blob URL
            const base64ToBlobUrl = async (base64Data) => {
                try {
                    if (!base64Data || typeof base64Data !== 'string') {
                        return base64Data;
                    }
                    // 如果已经是 Blob URL 或 HTTP URL，直接返回
                    if (base64Data.startsWith('blob:') || base64Data.startsWith('http://') || base64Data.startsWith('https://')) {
                        return base64Data;
                    }
                    // 如果是 Base64 Data URL，转换为 Blob URL
                    if (base64Data.startsWith('data:')) {
                        const res = await fetch(base64Data);
                        const blob = await res.blob();
                        return URL.createObjectURL(blob);
                    }
                    // 其他情况直接返回
                    return base64Data;
                } catch (e) {
                    console.error('Base64转Blob失败', e);
                    return base64Data; // 失败则返回原数据
                }
            };

            // 压缩/缩放图片用于Midjourney上传（Discord对图片有尺寸和大小限制）
            const prepareImageForMidjourneyUpload = async (imageUrl, maxSize = 2048, maxFileSizeMB = 8) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        const originalWidth = img.width;
                        const originalHeight = img.height;
                        
                        // 计算缩放后的尺寸，保持宽高比
                        let newWidth = originalWidth;
                        let newHeight = originalHeight;
                        
                        if (originalWidth > maxSize || originalHeight > maxSize) {
                            const scale = maxSize / Math.max(originalWidth, originalHeight);
                            newWidth = Math.floor(originalWidth * scale);
                            newHeight = Math.floor(originalHeight * scale);
                            console.log(`Midjourney: 缩放图片 ${originalWidth}x${originalHeight} -> ${newWidth}x${newHeight}`);
                        }
                        
                        // 创建canvas并绘制
                        const canvas = document.createElement('canvas');
                        canvas.width = newWidth;
                        canvas.height = newHeight;
                        const ctx = canvas.getContext('2d');
                        
                        // 使用高质量绘制
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, newWidth, newHeight);
                        
                        // 转换为base64，使用JPEG格式压缩
                        // 从高质量开始，如果文件太大则降低质量
                        let quality = 0.92;
                        let dataUrl = canvas.toDataURL('image/jpeg', quality);
                        
                        // 检查文件大小（base64编码后的大小约为原始大小的133%）
                        const base64Length = dataUrl.split(',')[1]?.length || 0;
                        const fileSizeMB = (base64Length * 3 / 4) / (1024 * 1024);
                        
                        // 如果文件太大，降低质量
                        if (fileSizeMB > maxFileSizeMB) {
                            console.log(`Midjourney: 图片文件大小 ${fileSizeMB.toFixed(2)}MB 超过限制，降低质量...`);
                            quality = 0.75;
                            dataUrl = canvas.toDataURL('image/jpeg', quality);
                            const newBase64Length = dataUrl.split(',')[1]?.length || 0;
                            const newFileSizeMB = (newBase64Length * 3 / 4) / (1024 * 1024);
                            console.log(`Midjourney: 降低质量后文件大小 ${newFileSizeMB.toFixed(2)}MB`);
                        }
                        
                        resolve(dataUrl);
                    };
                    
                    img.onerror = (error) => {
                        console.error('Midjourney: 图片加载失败', error);
                        // 如果加载失败，返回原图
                        resolve(imageUrl);
                    };
                    
                    img.src = imageUrl;
                });
            };

            // 上传图片到Midjourney并获取HTTP URL（用于oref和sref指令）
            const uploadMidjourneyImages = async (base64Array, baseUrl, apiKey) => {
                try {
                    // 先处理所有图片：压缩/缩放
                    console.log(`Midjourney: 准备上传 ${base64Array.length} 张图片，先进行压缩/缩放处理...`);
                    const processedImages = await Promise.all(
                        base64Array.map(async (imageUrl, index) => {
                            // 如果是data URL，先压缩/缩放
                            if (imageUrl.startsWith('data:')) {
                                try {
                                    const processed = await prepareImageForMidjourneyUpload(imageUrl, 2048, 8);
                                    console.log(`Midjourney: 图片[${index}]处理完成`);
                                    return processed;
                                } catch (error) {
                                    console.error(`Midjourney: 图片[${index}]处理失败，使用原图`, error);
                                    return imageUrl;
                                }
                            } else {
                                // 如果是HTTP URL，需要先转换为data URL再处理
                                try {
                                    const blob = await getBlobFromUrl(imageUrl);
                                    const dataUrl = await blobToDataURL(blob);
                                    const processed = await prepareImageForMidjourneyUpload(dataUrl, 2048, 8);
                                    console.log(`Midjourney: 图片[${index}]从URL处理完成`);
                                    return processed;
                                } catch (error) {
                                    console.error(`Midjourney: 图片[${index}]从URL处理失败`, error);
                                    throw error;
                                }
                            }
                        })
                    );
                    
                    // 清理base64数组，确保每个元素都是纯base64字符串
                    const cleanedBase64Array = processedImages.map((base64, index) => {
                        // 如果是data URL，提取base64部分
                        let cleaned = base64;
                        if (typeof cleaned !== 'string') {
                            throw new Error(`base64[${index}]不是字符串类型`);
                        }
                        
                        // 如果是data URL，提取base64部分
                        if (cleaned.includes(',')) {
                            // 直接提取逗号后的部分（base64数据）
                            cleaned = cleaned.split(',')[1];
                        } else if (cleaned.startsWith('data:')) {
                            // 如果没有逗号但有data:前缀，使用正则提取
                            cleaned = cleaned.replace(/^data:[^;]*;base64,?/i, '');
                        }
                        
                        // 严格清理：移除所有非base64字符（包括空白字符和不可见字符）
                        // 只保留有效的base64字符：A-Z, a-z, 0-9, +, /, =
                        const beforeClean = cleaned.length;
                        cleaned = cleaned.replace(/[^A-Za-z0-9+/=]/g, '');
                        const afterClean = cleaned.length;
                        if (beforeClean !== afterClean) {
                            console.log(`Midjourney: base64[${index}]清理了 ${beforeClean - afterClean} 个非法字符`);
                        }
                        
                        if (!cleaned || cleaned.length < 100) {
                            throw new Error(`base64[${index}]无效或太短，长度: ${cleaned?.length || 0}`);
                        }
                        
                        // 验证base64格式：只包含 base64 字符（A-Z, a-z, 0-9, +, /, =）
                        // 注意：base64字符串可能以0-2个=结尾作为填充
                        const base64Regex = /^[A-Za-z0-9+/]+={0,2}$/;
                        if (!base64Regex.test(cleaned)) {
                            console.error(`Midjourney: base64[${index}]格式验证失败，长度: ${cleaned.length}, 前50字符: ${cleaned.substring(0, 50)}`);
                            throw new Error(`invalid_base64_format: base64[${index}]格式无效`);
                        }
                        
                        // 验证base64长度是否为4的倍数（base64编码要求）
                        // 如果不是4的倍数，添加填充
                        const padding = cleaned.length % 4;
                        if (padding !== 0) {
                            // 移除现有的填充字符，然后重新添加正确的填充
                            cleaned = cleaned.replace(/=+$/, '');
                            cleaned += '='.repeat(4 - padding);
                            
                            // 填充后再次验证
                            if (!base64Regex.test(cleaned)) {
                                console.error(`Midjourney: base64[${index}]填充后验证失败，长度: ${cleaned.length}`);
                                throw new Error(`invalid_base64_format: base64[${index}]填充后格式无效`);
                            }
                        }
                        
                        // 测试base64是否能正确解码（确保base64有效）
                        try {
                            const testDecode = atob(cleaned);
                            if (!testDecode || testDecode.length === 0) {
                                throw new Error('base64解码结果为空');
                            }
                            console.log(`Midjourney: base64[${index}]解码测试通过，解码后长度: ${testDecode.length}`);
                        } catch (decodeError) {
                            console.error(`Midjourney: base64[${index}]解码测试失败:`, decodeError);
                            throw new Error(`invalid_base64_format: base64[${index}]无法解码`);
                        }
                        
                        // 根据API文档，base64Array需要完整的data URL格式：data:image/png;base64,xxx
                        // 而不是纯base64字符串
                        const dataUrl = `data:image/jpeg;base64,${cleaned}`;
                        console.log(`Midjourney: base64[${index}]清理完成，长度: ${cleaned.length}, 前20字符: ${cleaned.substring(0, 20)}`);
                        return dataUrl;
                    });
                    
                    // 使用Midjourney的上传接口：/mj/submit/upload-discord-images
                    const uploadEndpoint = `${baseUrl}/mj/submit/upload-discord-images`;
                    
                    console.log('Midjourney: 上传图片，base64数组长度:', cleanedBase64Array.length, '第一个data URL长度:', cleanedBase64Array[0]?.length, '前50字符:', cleanedBase64Array[0]?.substring(0, 50));
                    
                    // 最终验证所有data URL字符串（现在返回的是完整的data URL格式）
                    cleanedBase64Array.forEach((dataUrl, idx) => {
                        if (!dataUrl || typeof dataUrl !== 'string') {
                            throw new Error(`base64[${idx}]无效或不是字符串`);
                        }
                        // 验证是否是data URL格式：data:image/xxx;base64,xxx
                        if (!dataUrl.startsWith('data:image/')) {
                            throw new Error(`base64[${idx}]不是有效的data URL格式`);
                        }
                        // 提取base64部分进行验证
                        let base64Part = '';
                        if (dataUrl.includes(',')) {
                            base64Part = dataUrl.split(',')[1];
                        } else {
                            throw new Error(`base64[${idx}]data URL格式不正确，缺少逗号`);
                        }
                        
                        if (!base64Part || base64Part.length < 100) {
                            throw new Error(`base64[${idx}]无效或太短`);
                        }
                        // 验证base64格式
                        const base64Regex = /^[A-Za-z0-9+/]+={0,2}$/;
                        if (!base64Regex.test(base64Part)) {
                            console.error(`Midjourney: base64[${idx}]最终验证失败，包含非法字符`);
                            throw new Error(`base64[${idx}]格式无效`);
                        }
                        // 验证长度是4的倍数
                        if (base64Part.length % 4 !== 0) {
                            throw new Error(`base64[${idx}]长度不是4的倍数: ${base64Part.length}`);
                        }
                        // 再次测试解码
                        try {
                            atob(base64Part);
                        } catch (e) {
                            throw new Error(`base64[${idx}]无法解码: ${e.message}`);
                        }
                    });
                    
                    // 构建请求体
                    const requestBody = {
                        base64Array: cleanedBase64Array
                    };
                    
                    // 验证JSON序列化后的数据
                    const jsonString = JSON.stringify(requestBody);
                    console.log('Midjourney: 请求体JSON长度:', jsonString.length, 'base64数组长度:', cleanedBase64Array.length);
                    
                    const uploadResp = await fetch(uploadEndpoint, {
                        method: 'POST',
                        headers: {
                            Authorization: `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: jsonString
                    });
                    
                    if (!uploadResp.ok) {
                        let errorText = '';
                        try {
                            errorText = await uploadResp.text();
                            // 尝试解析为JSON
                            try {
                                const errorJson = JSON.parse(errorText);
                                throw new Error(`上传失败: ${uploadResp.status} - ${errorJson.description || errorJson.message || errorText}`);
                            } catch {
                                throw new Error(`上传失败: ${uploadResp.status} - ${errorText}`);
                            }
                        } catch (error) {
                            throw new Error(`上传失败: ${uploadResp.status} - ${error.message || errorText}`);
                        }
                    }
                    
                    const uploadData = await uploadResp.json();
                    console.log('Midjourney: 上传响应:', uploadData);
                    
                    // 检查响应格式
                    if (uploadData.code === 1 && uploadData.result && Array.isArray(uploadData.result)) {
                        console.log('Midjourney: 图片上传成功，获取URLs:', uploadData.result);
                        return uploadData.result; // 返回URL数组
                    } else {
                        const errorMsg = uploadData.description || uploadData.message || '上传失败：响应格式错误';
                        console.error('Midjourney: 上传失败，响应:', uploadData);
                        throw new Error(errorMsg);
                    }
                } catch (error) {
                    console.error('Midjourney: 图片上传失败:', error);
                    throw error;
                }
            };

            // 上传单个图片到图床并获取HTTP URL（用于Midjourney的oref和sref指令，以及拓展图片）
            const uploadImageToGetHttpUrl = async (imageUrl, baseUrl, apiKey) => {
                try {
                    // 如果是HTTP/HTTPS URL，直接返回
                    if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                        return imageUrl;
                    }

                    // 如果是 Blob URL，需要转换为 Base64 再上传
                    if (imageUrl.startsWith('blob:')) {
                        const base64Data = await getBase64FromUrl(imageUrl);
                        // 继续使用 data URL 的处理逻辑
                        imageUrl = `data:image/png;base64,${base64Data}`;
                    }

                    // 如果是data URL，需要上传
                    if (imageUrl.startsWith('data:')) {
                        // 提取base64数据（去掉 data:image/png;base64, 前缀）
                        // 确保正确提取纯base64字符串
                        let base64Data = imageUrl;
                        if (base64Data.includes(',')) {
                            base64Data = base64Data.split(',')[1];
                        } else {
                            // 如果没有逗号，尝试去掉 data: 前缀
                            base64Data = base64Data.replace(/^data:[^;]*;base64,?/i, '');
                        }
                        // 先清理所有非base64字符（包括所有空白字符和不可见字符）
                        // 这是最严格的方式：只保留有效的base64字符
                        base64Data = base64Data.replace(/[^A-Za-z0-9+/=]/g, '');
                        
                        if (!base64Data || base64Data.length < 100) {
                            console.error('拓展图片: base64数据无效或太短，长度:', base64Data?.length);
                            return null;
                        }
                        
                        // 验证base64格式：只包含 base64 字符（A-Z, a-z, 0-9, +, /, =）
                        const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
                        if (!base64Regex.test(base64Data)) {
                            console.error('拓展图片: base64数据格式验证失败，包含非法字符');
                            // 再次清理（理论上不应该到这里）
                            base64Data = base64Data.replace(/[^A-Za-z0-9+/=]/g, '');
                            if (!base64Regex.test(base64Data)) {
                                console.error('拓展图片: 清理后仍无效，放弃上传');
                                return null;
                            }
                        }
                        
                        // 验证base64长度是否为4的倍数（base64编码要求）
                        const padding = base64Data.length % 4;
                        if (padding !== 0) {
                            console.warn('拓展图片: base64长度不是4的倍数，添加填充:', padding);
                            base64Data += '='.repeat(4 - padding);
                        }
                        
                        // 最终验证
                        if (!base64Regex.test(base64Data)) {
                            console.error('拓展图片: 最终验证失败');
                            return null;
                        }
                        
                        console.log('拓展图片: 提取的base64数据长度:', base64Data.length, '前50字符:', base64Data.substring(0, 50), '后10字符:', base64Data.substring(base64Data.length - 10), '格式验证通过:', base64Regex.test(base64Data));
                        
                        // 优先使用 Midjourney 官方上传接口
                        try {
                            // 确保 baseUrl 格式正确（移除末尾斜杠）
                            const cleanBaseUrl = baseUrl.replace(/\/+$/, '');
                            const uploadEndpoint = `${cleanBaseUrl}/mj/submit/upload-discord-images`;
                            const uploadPayload = {
                                base64Array: [base64Data]
                            };

                            console.log('拓展图片: 使用 Midjourney 上传接口上传图片...', uploadEndpoint, 'base64长度:', base64Data.length);
                            
                            const uploadResp = await fetch(uploadEndpoint, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKey}`
                                },
                                body: JSON.stringify(uploadPayload)
                            });

                            const responseText = await uploadResp.text();
                            console.log('拓展图片: Midjourney 上传响应状态:', uploadResp.status, '响应长度:', responseText.length);

                            if (uploadResp.ok) {
                                let uploadData;
                                try {
                                    uploadData = JSON.parse(responseText);
                                } catch (parseError) {
                                    console.error('拓展图片: Midjourney 上传响应解析失败', parseError, '响应内容:', responseText.substring(0, 200));
                                    throw new Error('响应不是有效的JSON格式');
                                }

                                console.log('拓展图片: Midjourney 上传响应数据:', uploadData);
                                console.log('拓展图片: 响应详细信息:', {
                                    code: uploadData.code,
                                    description: uploadData.description,
                                    result: uploadData.result,
                                    resultType: typeof uploadData.result,
                                    isArray: Array.isArray(uploadData.result),
                                    hasData: !!uploadData.data,
                                    hasUrl: !!uploadData.url
                                });

                                // 检查响应格式
                                if (uploadData.code === 1) {
                                    // 尝试多种可能的响应格式
                                    let httpUrl = null;
                                    
                                    // 格式1: result 是数组
                                    if (uploadData.result && Array.isArray(uploadData.result) && uploadData.result.length > 0) {
                                        httpUrl = uploadData.result[0];
                                    }
                                    // 格式2: result 是字符串
                                    else if (uploadData.result && typeof uploadData.result === 'string') {
                                        httpUrl = uploadData.result;
                                    }
                                    // 格式3: data 字段
                                    else if (uploadData.data && Array.isArray(uploadData.data) && uploadData.data.length > 0) {
                                        httpUrl = uploadData.data[0];
                                    }
                                    // 格式4: url 字段
                                    else if (uploadData.url) {
                                        httpUrl = uploadData.url;
                                    }
                                    
                                    if (httpUrl && (httpUrl.startsWith('http://') || httpUrl.startsWith('https://'))) {
                                        console.log('拓展图片: Midjourney 上传成功，获取HTTP URL:', httpUrl);
                                        return httpUrl;
                                    } else {
                                        console.warn('拓展图片: Midjourney 返回的URL格式不正确或为空', {
                                            httpUrl,
                                            code: uploadData.code,
                                            description: uploadData.description,
                                            result: uploadData.result,
                                            data: uploadData.data,
                                            url: uploadData.url
                                        });
                                    }
                                } else {
                                    console.warn('拓展图片: Midjourney 上传失败', {
                                        code: uploadData.code,
                                        description: uploadData.description,
                                        fullResponse: uploadData
                                    });
                                }
                            } else {
                                console.warn('拓展图片: Midjourney 上传失败', uploadResp.status, '响应内容:', responseText.substring(0, 200));
                            }
                        } catch (e) {
                            console.error('拓展图片: Midjourney 上传接口调用失败', e);
                        }

                        // 如果 Midjourney 上传失败，尝试使用图床服务作为备选
                        const mimeMatch = imageUrl.match(/data:([^;]+);base64/);
                        const mimeType = mimeMatch ? mimeMatch[1] : 'image/png';
                        
                        // 将base64转换为Blob
                        const byteCharacters = atob(base64Data);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const blob = new Blob([byteArray], { type: mimeType });

                        const imageBedServices = [
                            // sm.ms图床
                            {
                                name: 'sm.ms',
                                url: 'https://sm.ms/api/v2/upload',
                                fieldName: 'smfile',
                                parseResponse: (data) => data.success && data.data?.url ? data.data.url : null
                            }
                        ];

                        for (const service of imageBedServices) {
                            if (service.skip) continue;
                            
                            try {
                                const formData = new FormData();
                                formData.append(service.fieldName, blob, 'image.png');
                                
                                const resp = await fetch(service.url, {
                                    method: 'POST',
                                    body: formData
                                });
                                
                                if (resp.ok) {
                                    const data = await resp.json();
                                    const httpUrl = service.parseResponse(data);
                                    if (httpUrl && (httpUrl.startsWith('http://') || httpUrl.startsWith('https://'))) {
                                        console.log(`拓展图片: 使用${service.name}图床上传成功，获取HTTP URL:`, httpUrl);
                                        return httpUrl;
                                    }
                                }
                            } catch (e) {
                                console.warn(`拓展图片: ${service.name}图床上传失败:`, e);
                                continue;
                            }
                        }

                        // 如果所有上传方式都失败，返回null
                        console.warn('拓展图片: 所有上传方式都失败，无法获取HTTP URL');
                        return null;
                    }

                    // 其他格式，直接返回
                    return imageUrl;
                } catch (error) {
                    console.error('拓展图片: 上传图片失败:', error);
                    return null;
                }
            };

            // 缩放图片到合理尺寸（用于Veo接口，避免图片过大）
            const resizeImageForVeo = async (imageUrl, maxWidth = 1920, maxHeight = 1920) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        const originalWidth = img.width;
                        const originalHeight = img.height;
                        
                        // 如果图片尺寸已经小于等于目标尺寸，直接返回原图
                        if (originalWidth <= maxWidth && originalHeight <= maxHeight) {
                            console.log(`Veo: 图片尺寸 ${originalWidth}x${originalHeight} 无需缩放`);
                            if (imageUrl.startsWith('data:')) {
                                resolve(imageUrl);
                            } else {
                                // 如果是URL，转换为data URL
                                getBase64FromUrl(imageUrl).then(base64 => {
                                    resolve(`data:image/png;base64,${base64}`);
                                }).catch(reject);
                            }
                            return;
                        }
                        
                        // 计算缩放后的尺寸，保持宽高比
                        let newWidth = originalWidth;
                        let newHeight = originalHeight;
                        
                        if (originalWidth > maxWidth || originalHeight > maxHeight) {
                            const scale = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);
                            newWidth = Math.round(originalWidth * scale);
                            newHeight = Math.round(originalHeight * scale);
                            
                            // 确保尺寸是偶数（某些编码器要求）
                            newWidth = newWidth % 2 === 0 ? newWidth : newWidth - 1;
                            newHeight = newHeight % 2 === 0 ? newHeight : newHeight - 1;
                        }
                        
                        console.log(`Veo: 缩放图片 ${originalWidth}x${originalHeight} -> ${newWidth}x${newHeight}`);
                        
                        // 使用canvas缩放图片
                        const canvas = document.createElement('canvas');
                        canvas.width = newWidth;
                        canvas.height = newHeight;
                        const ctx = canvas.getContext('2d');
                        
                        // 使用高质量缩放
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, newWidth, newHeight);
                        
                        // 转换为data URL
                        const dataUrl = canvas.toDataURL('image/png', 0.95);
                        resolve(dataUrl);
                    };
                    
                    img.onerror = (e) => {
                        console.error('Veo: 图片加载失败', e);
                        reject(new Error('图片加载失败'));
                    };
                    
                    // 设置图片源
                    if (imageUrl.startsWith('data:')) {
                        img.src = imageUrl;
                    } else if (imageUrl.startsWith('blob:')) {
                        img.src = imageUrl;
                    } else {
                        // 对于其他URL，先转换为blob再加载（避免CORS问题）
                        getBlobFromUrl(imageUrl).then(blob => {
                            const blobUrl = URL.createObjectURL(blob);
                            img.src = blobUrl;
                        }).catch(reject);
                    }
                });
            };

            const disconnectConnection = useCallback((connectionId) => {
                setConnections(prev => {
                    const filtered = prev.filter(conn => conn.id !== connectionId);
                    // 触发节点重新渲染，确保引用成功区域正确更新
                    return filtered;
                });
            }, []);

            const handleDrop = (nodeId, e) => {
                e.preventDefault(); e.stopPropagation();
                e.currentTarget.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files);
                const imageFiles = files.filter(file => file.type.startsWith('image/'));
                if (imageFiles.length > 0) {
                    const file = imageFiles[0];
                    const reader = new FileReader();
                    reader.onload = async (ev) => {
                        const content = ev.target.result;
                        let dimensions = { w: 0, h: 0 };
                        try { dimensions = await getImageDimensions(content); } catch (e) {}
                        setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, content: content, dimensions } : n));
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); e.currentTarget.classList.add('drag-over'); };
            const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); e.currentTarget.classList.remove('drag-over'); };

            // 将HTML表格转换为Markdown表格格式
            const convertTableToMarkdown = (table) => {
                const rows = Array.from(table.querySelectorAll('tr'));
                if (rows.length === 0) return '';
                
                const markdownRows = rows.map((row, rowIndex) => {
                    const cells = Array.from(row.querySelectorAll('td, th'));
                    const cellTexts = cells.map(cell => {
                        const text = cell.textContent.trim().replace(/\|/g, '\\|').replace(/\n/g, ' ');
                        return text || ' ';
                    });
                    return '| ' + cellTexts.join(' | ') + ' |';
                });
                
                // 添加分隔行（第二行）
                if (markdownRows.length > 0) {
                    const firstRowCells = markdownRows[0].split('|').filter(c => c.trim()).length - 2;
                    const separator = '| ' + Array(firstRowCells).fill('---').join(' | ') + ' |';
                    markdownRows.splice(1, 0, separator);
                }
                
                return '\n' + markdownRows.join('\n') + '\n';
            };

            // 优化后的复制粘贴逻辑
            useEffect(() => {
                // 复制功能（Ctrl+C / Cmd+C）
                const handleCopy = async (e) => {
                    const target = e.target;
                    const isTextInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;
                    
                    // 优先级1：文本输入框 - 如果有选中文本，使用浏览器默认行为
                    if (isTextInput) {
                        const selection = window.getSelection();
                        if (selection && selection.toString().trim()) {
                            // 有选中文本，让浏览器默认处理
                            return;
                        }
                        // 没有选中文本，不触发任何动作
                        e.preventDefault();
                        return;
                    }
                    
                    // 优先级2和3：节点复制（包括所有类型的节点）
                    const currentSelectedId = selectedNodeIdRef.current;
                    const currentSelectedIds = selectedNodeIdsRef.current;
                    const selectedIds = currentSelectedId ? [currentSelectedId] : (currentSelectedIds && currentSelectedIds.size > 0 ? Array.from(currentSelectedIds) : []);
                    
                    if (selectedIds.length > 0) {
                        e.preventDefault();
                        e.stopPropagation();
                        const selectedNodes = nodesRef.current.filter(n => selectedIds.includes(n.id));
                        const relatedConnections = connectionsRef.current.filter(c => 
                            selectedIds.includes(c.from) || selectedIds.includes(c.to)
                        );
                        
                        // 只保存选中的节点之间的连接
                        const internalConnections = relatedConnections.filter(c => 
                            selectedIds.includes(c.from) && selectedIds.includes(c.to)
                        );
                        
                        copiedNodesRef.current = {
                            nodes: selectedNodes.map(n => ({ ...n })),
                            connections: internalConnections.map(c => ({ ...c })),
                            timestamp: Date.now()
                        };
                        
                        // 可选：给用户反馈
                        console.log(`已复制 ${selectedNodes.length} 个节点`);
                    }
                };
                
                // 粘贴功能（Ctrl+V / Cmd+V）
                const handlePaste = async (e) => {
                    const target = e.target;
                    const isTextInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;
                    
                    // 优先级1：文本输入框 - 使用浏览器默认行为
                    if (isTextInput) {
                        // 让浏览器默认处理文本粘贴
                        return;
                    }
                    
                    // 优先级2：图像节点截图粘贴
                    const currentSelectedId = selectedNodeIdRef.current;
                    let targetNode = null;
                    if (currentSelectedId) {
                        targetNode = nodesRef.current.find(n => n.id === currentSelectedId);
                    }
                    // 如果选中了图像或视频节点，尝试粘贴图像/视频
                    if (targetNode && (targetNode.type === 'input-image' || targetNode.type === 'video-input')) {
                        const items = Array.from(e.clipboardData.items);
                        const imageItem = items.find(item => item.type.startsWith('image/'));
                        const videoItem = items.find(item => item.type.startsWith('video/'));
                        
                        if (imageItem && targetNode.type === 'input-image') {
                            e.preventDefault();
                            const file = imageItem.getAsFile();
                            if (file) {
                                const reader = new FileReader();
                                reader.onload = async (ev) => {
                                    const content = ev.target.result;
                                    let dimensions = { w: 0, h: 0 };
                                    try { 
                                        dimensions = await getImageDimensions(content);
                                    } catch (e) {}
                                    setNodes((prev) => prev.map((n) => 
                                        n.id === targetNode.id 
                                            ? { ...n, content: content, dimensions } 
                                            : n
                                    ));
                                };
                                reader.readAsDataURL(file);
                            }
                            return;
                        } else if (videoItem && targetNode.type === 'video-input') {
                            e.preventDefault();
                            const file = videoItem.getAsFile();
                            if (file) {
                                handleVideoFileUpload(targetNode.id, file);
                            }
                            return;
                        }
                    }
                    
                    // 优先级3：节点粘贴
                    if (copiedNodesRef.current && copiedNodesRef.current.nodes && copiedNodesRef.current.nodes.length > 0) {
                        e.preventDefault();
                        e.stopPropagation();
                        const copied = copiedNodesRef.current;
                        
                        // 计算粘贴位置：使用视图中心或鼠标位置
                        const canvasElement = canvasRef.current;
                        let pasteX = 0, pasteY = 0;
                        if (canvasElement) {
                            const rect = canvasElement.getBoundingClientRect();
                            const centerX = (rect.left + rect.width / 2 - view.x) / view.zoom;
                            const centerY = (rect.top + rect.height / 2 - view.y) / view.zoom;
                            pasteX = centerX;
                            pasteY = centerY;
                        }
                        
                        // 计算原节点的中心点
                        const originalNodes = copied.nodes;
                        if (originalNodes.length === 0) return;
                        
                        const minX = Math.min(...originalNodes.map(n => n.x || 0));
                        const minY = Math.min(...originalNodes.map(n => n.y || 0));
                        const maxX = Math.max(...originalNodes.map(n => (n.x || 0) + (n.width || 0)));
                        const maxY = Math.max(...originalNodes.map(n => (n.y || 0) + (n.height || 0)));
                        const originalCenterX = (minX + maxX) / 2;
                        const originalCenterY = (minY + maxY) / 2;
                        
                        // 计算偏移量，使新节点中心对齐到粘贴位置
                        const offsetX = pasteX - originalCenterX;
                        const offsetY = pasteY - originalCenterY;
                        
                        // 创建新节点ID映射
                        const idMap = new Map();
                        const baseTime = Date.now();
                        copied.nodes.forEach((node, index) => {
                            const newId = `node-${baseTime}-${index}-${Math.random().toString(36).substr(2, 9)}`;
                            idMap.set(node.id, newId);
                        });
                        
                        // 创建新节点
                        const newNodes = copied.nodes.map(node => ({
                            ...node,
                            id: idMap.get(node.id),
                            x: node.x + offsetX,
                            y: node.y + offsetY
                        }));
                        
                        // 创建新连接（只保留两个端点都在新节点中的连接）
                        const newConnections = (copied.connections || [])
                            .filter(conn => conn && idMap.has(conn.from) && idMap.has(conn.to))
                            .map((conn, index) => ({
                                ...conn,
                                id: `conn-${baseTime}-${index}-${Math.random().toString(36).substr(2, 9)}`,
                                from: idMap.get(conn.from),
                                to: idMap.get(conn.to)
                            }));
                        
                        setNodes(prev => [...prev, ...newNodes]);
                        setConnections(prev => [...prev, ...newConnections]);
                        
                        // 选中粘贴的节点
                        if (newNodes.length === 1) {
                            setSelectedNodeId(newNodes[0].id);
                            setSelectedNodeIds(new Set([newNodes[0].id]));
                        } else if (newNodes.length > 1) {
                            setSelectedNodeId(null);
                            setSelectedNodeIds(new Set(newNodes.map(n => n.id)));
                        }
                        
                        console.log(`已粘贴 ${newNodes.length} 个节点`);
                    }
                };
                
                // 添加keydown事件监听，确保Ctrl+V/Cmd+V能触发节点粘贴
                const handleKeyDown = (e) => {
                    const target = e.target;
                    const isTextInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;
                    
                    // 如果不在文本输入框中，且按下了Ctrl+V或Cmd+V
                    if (!isTextInput && (e.ctrlKey || e.metaKey) && e.key === 'v') {
                        // 先检查是否选中了图像节点，如果是，让paste事件处理图像粘贴
                        const currentSelectedId = selectedNodeIdRef.current;
                        if (currentSelectedId) {
                            const targetNode = nodesRef.current.find(n => n.id === currentSelectedId);
                            if (targetNode && (targetNode.type === 'input-image' || targetNode.type === 'video-input')) {
                                // 选中了图像节点，让paste事件处理，不在这里处理
                                return;
                            }
                        }
                        
                        // 检查是否有复制的节点
                        if (copiedNodesRef.current && copiedNodesRef.current.nodes && copiedNodesRef.current.nodes.length > 0) {
                            e.preventDefault();
                            e.stopPropagation();
                            // 直接调用粘贴逻辑
                            const copied = copiedNodesRef.current;
                            
                            // 计算粘贴位置：使用视图中心
                            const canvasElement = canvasRef.current;
                            let pasteX = 0, pasteY = 0;
                            if (canvasElement) {
                                const rect = canvasElement.getBoundingClientRect();
                                const centerX = (rect.left + rect.width / 2 - view.x) / view.zoom;
                                const centerY = (rect.top + rect.height / 2 - view.y) / view.zoom;
                                pasteX = centerX;
                                pasteY = centerY;
                            }
                            
                            // 计算原节点的中心点
                            const originalNodes = copied.nodes;
                            if (originalNodes.length === 0) return;
                            
                            const minX = Math.min(...originalNodes.map(n => n.x || 0));
                            const minY = Math.min(...originalNodes.map(n => n.y || 0));
                            const maxX = Math.max(...originalNodes.map(n => (n.x || 0) + (n.width || 0)));
                            const maxY = Math.max(...originalNodes.map(n => (n.y || 0) + (n.height || 0)));
                            const originalCenterX = (minX + maxX) / 2;
                            const originalCenterY = (minY + maxY) / 2;
                            
                            // 计算偏移量
                            const offsetX = pasteX - originalCenterX;
                            const offsetY = pasteY - originalCenterY;
                            
                            // 创建新节点ID映射
                            const idMap = new Map();
                            const baseTime = Date.now();
                            copied.nodes.forEach((node, index) => {
                                const newId = `node-${baseTime}-${index}-${Math.random().toString(36).substr(2, 9)}`;
                                idMap.set(node.id, newId);
                            });
                            
                            // 创建新节点
                            const newNodes = copied.nodes.map(node => ({
                                ...node,
                                id: idMap.get(node.id),
                                x: node.x + offsetX,
                                y: node.y + offsetY
                            }));
                            
                        // 创建新连接（只保留两个端点都在新节点中的连接）
                        const newConnections = (copied.connections || [])
                            .filter(conn => conn && idMap.has(conn.from) && idMap.has(conn.to))
                            .map((conn, index) => ({
                                ...conn,
                                id: `conn-${baseTime}-${index}-${Math.random().toString(36).substr(2, 9)}`,
                                from: idMap.get(conn.from),
                                to: idMap.get(conn.to)
                            }));
                        
                        setNodes(prev => [...prev, ...newNodes]);
                        setConnections(prev => [...prev, ...newConnections]);
                            
                            // 选中粘贴的节点
                            if (newNodes.length === 1) {
                                setSelectedNodeId(newNodes[0].id);
                                setSelectedNodeIds(new Set([newNodes[0].id]));
                            } else if (newNodes.length > 1) {
                                setSelectedNodeId(null);
                                setSelectedNodeIds(new Set(newNodes.map(n => n.id)));
                            }
                            
                            console.log(`已粘贴 ${newNodes.length} 个节点`);
                        }
                    }
                };
                
                window.addEventListener('copy', handleCopy);
                window.addEventListener('paste', handlePaste);
                window.addEventListener('keydown', handleKeyDown);
                
                return () => {
                    window.removeEventListener('copy', handleCopy);
                    window.removeEventListener('paste', handlePaste);
                    window.removeEventListener('keydown', handleKeyDown);
                };
            }, [updateNodeSettings, handleVideoFileUpload, setNodes, setConnections, setSelectedNodeId, setSelectedNodeIds, view]);

            const pollVeoJob = async (jobId, taskId, baseUrl, apiKey, w, h, attempt = 0) => {
                const maxAttempts = 90; // 增加到90次，支持最长360秒（6分钟）的生成时间
                const delayMs = 4000;

                if (attempt > maxAttempts) {
                    setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: 'Veo 轮询超时' } : hItem));
                    
                    // 检查是否是分镜表的任务，如果是则更新状态为 draft
                    const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                    if (storyboardTask) {
                        console.log('[分镜表] Veo轮询超时，更新状态:', { taskId, nodeId: storyboardTask.nodeId, shotId: storyboardTask.shotId });
                        updateShot(storyboardTask.nodeId, storyboardTask.shotId, { 
                            status: 'draft'
                        });
                        // 清理任务映射
                        storyboardTaskMapRef.current.delete(taskId);
                    }
                    return;
                }

                fetch(`${baseUrl}/v2/videos/generations/${jobId}`, {
                    method: 'GET',
                    headers: { Authorization: `Bearer ${apiKey}` },
                })
                .then(async (resp) => {
                    const text = await resp.text();
                    let data;
                    try { data = JSON.parse(text); } catch (err) { setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs); return; }

                    console.log('[Tapnow] Veo Poll:', data);
                    const status = data?.data?.status || data?.status || data?.data?.task_status;
                    const progress = data?.data?.progress || data?.progress || '0%';
                    const failReason = data?.data?.fail_reason || data?.fail_reason || '';

                    // 处理成功状态
                    if (status === 'SUCCESS' || status === 'succeeded' || status === 'FINISHED' || status === 'completed') {
                        const videoUrl = data?.data?.output || data?.output || data?.data?.video_url || data?.video_url || data?.data?.data?.output;
                        if (!videoUrl) {
                            console.warn('[Tapnow] Veo: 任务成功但未找到视频URL', data);
                            setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: '未找到视频URL' } : hItem));
                            return;
                        }
                        console.log('[Tapnow] Veo: 任务成功，视频URL:', videoUrl);
                        const endTime = Date.now();
                        // 在更新 history 之前，先获取 sourceNodeId 和 ratio
                        // 使用函数式更新来确保获取最新的 historyItem
                        setHistory((prev) => {
                            const historyItem = prev.find(h => h.id === taskId);
                            const sourceNodeId = historyItem?.sourceNodeId;
                            const originalRatio = historyItem?.ratio;
                            const durationMs = endTime - (historyItem?.startTime || endTime);
                            
                            console.log('[Tapnow] Veo: 从历史记录获取信息', { taskId, originalRatio, sourceNodeId, historyItem });
                            
                            // 对于 veo3.1，尝试从实际视频获取真实尺寸
                            let finalW = w, finalH = h;
                            
                            // 异步获取视频尺寸并更新（使用 Promise）
                            (async () => {
                                try {
                                    const videoMeta = await getVideoMetadata(videoUrl);
                                    if (videoMeta && videoMeta.w > 0 && videoMeta.h > 0) {
                                        console.log('[Tapnow] Veo: 获取到视频实际尺寸', { w: videoMeta.w, h: videoMeta.h, requestedRatio: originalRatio });
                                        const actualW = videoMeta.w;
                                        const actualH = videoMeta.h;
                                        
                                        // 验证实际尺寸是否匹配请求的 aspect_ratio
                                        if (originalRatio === '16:9') {
                                            const actualRatio = actualW / actualH;
                                            const expectedRatio = 16/9;
                                            if (Math.abs(actualRatio - expectedRatio) > 0.1) {
                                                console.warn(`[Tapnow] Veo: 视频实际比例 ${actualRatio.toFixed(2)} 不匹配请求的 16:9 (${expectedRatio.toFixed(2)})，后端返回了错误的比例！`);
                                                console.warn(`[Tapnow] Veo: 实际尺寸: ${actualW}x${actualH}, 请求比例: 16:9`);
                                                console.warn(`[Tapnow] Veo: 强制使用请求的 16:9 比例，调整尺寸为: ${w}x${Math.round(w / (16/9))}`);
                                                // 如果后端返回了错误的比例，强制使用请求的比例
                                                finalW = w;
                                                finalH = Math.round(w / (16/9));
                                            } else {
                                                console.log(`[Tapnow] Veo: 视频实际比例匹配 16:9`);
                                                finalW = actualW;
                                                finalH = actualH;
                                            }
                                        } else if (originalRatio === '9:16') {
                                            const actualRatio = actualW / actualH;
                                            const expectedRatio = 9/16;
                                            if (Math.abs(actualRatio - expectedRatio) > 0.1) {
                                                console.warn(`[Tapnow] Veo: 视频实际比例 ${actualRatio.toFixed(2)} 不匹配请求的 9:16 (${expectedRatio.toFixed(2)})，后端返回了错误的比例！`);
                                                console.warn(`[Tapnow] Veo: 实际尺寸: ${actualW}x${actualH}, 请求比例: 9:16`);
                                                console.warn(`[Tapnow] Veo: 强制使用请求的 9:16 比例，调整尺寸为: ${Math.round(h * (9/16))}x${h}`);
                                                // 如果后端返回了错误的比例，强制使用请求的比例
                                                finalW = Math.round(h * (9/16));
                                                finalH = h;
                                            } else {
                                                console.log(`[Tapnow] Veo: 视频实际比例匹配 9:16`);
                                                finalW = actualW;
                                                finalH = actualH;
                                            }
                                        } else {
                                            // 如果没有指定比例，使用实际尺寸
                                            finalW = actualW;
                                            finalH = actualH;
                                        }
                                        
                                        // 更新历史记录
                                        setHistory((prevHistory) => {
                                            return prevHistory.map((hItem) => 
                                                hItem.id === taskId 
                                                    ? { ...hItem, status: 'completed', progress: 100, url: videoUrl, width: finalW, height: finalH, durationMs, ratio: originalRatio || hItem.ratio } 
                                                    : hItem
                                            );
                                        });
                                        
                                        // 检查是否是分镜表的任务，如果是则回填到分镜表
                                        const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                                        if (storyboardTask) {
                                            console.log('[分镜表] Veo任务完成，回填视频:', { taskId, nodeId: storyboardTask.nodeId, shotId: storyboardTask.shotId, videoUrl });
                                            updateShot(storyboardTask.nodeId, storyboardTask.shotId, { 
                                                video_url: videoUrl,
                                                status: 'done'
                                            });
                                            // 清理任务映射
                                            storyboardTaskMapRef.current.delete(taskId);
                                        } else {
                                            // 更新预览窗口（非分镜表任务）
                                        if (sourceNodeId) {
                                            setTimeout(() => {
                                                console.log('[Tapnow] Veo: 准备更新预览窗口', { taskId, videoUrl, sourceNodeId });
                                                updatePreviewFromTask(taskId, videoUrl, 'video', sourceNodeId);
                                            }, 0);
                                            }
                                        }
                                    }
                                } catch (e) {
                                    console.warn('[Tapnow] Veo: 无法获取视频实际尺寸，使用请求尺寸', e);
                                    // 如果无法获取实际尺寸，使用请求的尺寸并根据 aspect_ratio 调整
                                    let fallbackW = w, fallbackH = h;
                                    if (originalRatio === '16:9') {
                                        const aspectRatioValue = fallbackW / fallbackH;
                                        if (Math.abs(aspectRatioValue - 16/9) > 0.1) {
                                            fallbackH = Math.round(fallbackW / (16/9));
                                        }
                                    } else if (originalRatio === '9:16') {
                                        const aspectRatioValue = fallbackW / fallbackH;
                                        if (Math.abs(aspectRatioValue - 9/16) > 0.1) {
                                            fallbackW = Math.round(fallbackH * (9/16));
                                        }
                                    }
                                    
                                    // 更新历史记录
                                    setHistory((prevHistory) => {
                                        return prevHistory.map((hItem) => 
                                            hItem.id === taskId 
                                                ? { ...hItem, status: 'completed', progress: 100, url: videoUrl, width: fallbackW, height: fallbackH, durationMs, ratio: originalRatio || hItem.ratio } 
                                                : hItem
                                        );
                                    });
                                    
                                    // 检查是否是分镜表的任务，如果是则回填到分镜表
                                    const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                                    if (storyboardTask) {
                                        console.log('[分镜表] Veo任务完成（fallback），回填视频:', { taskId, nodeId: storyboardTask.nodeId, shotId: storyboardTask.shotId, videoUrl });
                                        updateShot(storyboardTask.nodeId, storyboardTask.shotId, { 
                                            video_url: videoUrl,
                                            status: 'done'
                                        });
                                        // 清理任务映射
                                        storyboardTaskMapRef.current.delete(taskId);
                                    } else {
                                        // 更新预览窗口（非分镜表任务）
                                    if (sourceNodeId) {
                                        setTimeout(() => {
                                            console.log('[Tapnow] Veo: 准备更新预览窗口', { taskId, videoUrl, sourceNodeId });
                                            updatePreviewFromTask(taskId, videoUrl, 'video', sourceNodeId);
                                        }, 0);
                                        }
                                    }
                                }
                            })();
                            
                            // 先返回原始状态，等待异步操作完成后再更新
                            return prev;
                        });
                        return;
                    }

                    // 处理失败状态
                    if (status === 'FAILED' || status === 'ERROR' || status === 'CANCELLED') {
                        let errorMsg = `任务失败: ${status}`;
                        if (failReason) {
                            try {
                                const reasonObj = typeof failReason === 'string' ? JSON.parse(failReason) : failReason;
                                errorMsg = reasonObj?.message || reasonObj?.code || failReason;
                            } catch (e) {
                                errorMsg = failReason || errorMsg;
                            }
                        }
                        console.error('[Tapnow] Veo: 任务失败', { status, failReason, errorMsg });
                        setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg } : hItem));
                        return;
                    }

                    // 处理 NOT_START 状态：可能是任务还在队列中，继续等待
                    if (status === 'NOT_START' || status === 'PENDING' || status === 'QUEUED') {
                        console.log(`[Tapnow] Veo: 任务状态 ${status}，进度 ${progress}，继续等待...`);
                        // 对于 NOT_START 状态，进度更新更慢一些，避免频繁更新
                        const currentProgress = parseInt(progress) || 0;
                        setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { 
                            ...hItem, 
                            status: 'generating', 
                            progress: Math.max(5, currentProgress),
                            errorMsg: status === 'NOT_START' ? '任务已创建，等待处理中...' : undefined
                        } : hItem));
                        setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs);
                        return;
                    }

                    // 其他状态（如 PROCESSING、GENERATING 等）：继续轮询
                    const currentProgress = parseInt(progress) || Math.min(95, (attempt * 2) + 10);
                    console.log(`[Tapnow] Veo: 任务状态 ${status}，进度 ${progress}，继续轮询...`);
                    setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'generating', progress: currentProgress } : hItem));
                    setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs);
                })
                .catch((err) => setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs));
            };

            const pollSoraJob = (jobId, taskId, baseUrl, apiKey, w, h, modelId = '', attempt = 0) => {
                // Sora 2 Pro 需要更长的等待时间（30分钟），其他模型保持原有设置（约6.5分钟）
                const maxAttempts = modelId === 'sora-2-pro' ? 360 : 80;
                const delayMs = 5000;

                if (attempt > maxAttempts) {
                    setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: 'Sora 轮询超时' } : hItem));
                    
                    // 检查是否是分镜表的任务，如果是则更新状态为 draft
                    const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                    if (storyboardTask) {
                        console.log('[分镜表] Sora轮询超时，更新状态:', { taskId, nodeId: storyboardTask.nodeId, shotId: storyboardTask.shotId });
                        updateShot(storyboardTask.nodeId, storyboardTask.shotId, { 
                            status: 'draft'
                        });
                        // 清理任务映射
                        storyboardTaskMapRef.current.delete(taskId);
                    }
                    return;
                }

                const pollEndpoint = modelId?.includes('grok')
                    ? `${baseUrl}/v2/videos/generations/${encodeURIComponent(jobId)}`
                    : `${baseUrl}/v1/videos/${encodeURIComponent(jobId)}`;

                fetch(pollEndpoint, {
                    method: 'GET',
                    headers: { Authorization: `Bearer ${apiKey}` },
                })
                .then(resp => {
                    if (!resp.ok) {
                        throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
                    }
                    return resp.text();
                })
                .then((text) => {
                    let data;
                    try { 
                        data = JSON.parse(text); 
                    } catch (err) { 
                        console.error('[Tapnow] Sora/Grok Poll JSON 解析失败:', err, text);
                        setTimeout(() => pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId, attempt + 1), delayMs); 
                        return; 
                    }

                    console.log('[Tapnow] Sora/Grok Poll:', data);
                    const status = data?.data?.status || data?.status || data?.data?.task_status || data?.task_status;

                    if (status === 'SUCCESS' || status === 'succeeded' || status === 'FINISHED' || status === 'completed') {
                        const videoUrl = data?.data?.output || data?.output || data?.data?.video_url || data?.data?.url || data?.video_url || data?.url;
                        if (!videoUrl) {
                            setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: '未找到视频URL' } : hItem));
                            return;
                        }
                        const endTime = Date.now();
                        // 在更新 history 之前，先获取 sourceNodeId
                        const historyItem = historyMap.get(taskId);
                        const sourceNodeId = historyItem?.sourceNodeId;
                        const durationMs = endTime - (historyItem?.startTime || endTime);
                        // 使用 setHistory 的回调来确保获取最新的 historyItem
                        setHistory((prev) => {
                            const updated = prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'completed', progress: 100, url: videoUrl, width: w, height: h, durationMs } : hItem);
                            // 检查是否是分镜表的任务，如果是则回填到分镜表
                            const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                            if (storyboardTask) {
                                console.log('[分镜表] Sora任务完成，回填视频:', { taskId, nodeId: storyboardTask.nodeId, shotId: storyboardTask.shotId, videoUrl });
                                updateShot(storyboardTask.nodeId, storyboardTask.shotId, { 
                                    video_url: videoUrl,
                                    status: 'done'
                                });
                                // 清理任务映射
                                storyboardTaskMapRef.current.delete(taskId);
                            } else {
                                // 更新预览窗口（非分镜表任务）
                            const updatedItem = updated.find(h => h.id === taskId);
                            if (updatedItem?.sourceNodeId) {
                                setTimeout(() => {
                                    console.log('[Tapnow] Sora: 准备更新预览窗口', { taskId, videoUrl, sourceNodeId: updatedItem.sourceNodeId });
                                    updatePreviewFromTask(taskId, videoUrl, 'video', updatedItem.sourceNodeId);
                                }, 0);
                            } else {
                                console.warn('[Tapnow] Sora: 未找到 sourceNodeId', { taskId, updatedItem });
                                }
                            }
                            return updated;
                        });
                        return;
                    }

                    if (status === 'FAILED' || status === 'ERROR' || status === 'CANCELLED') {
                        setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: `任务失败: ${status}` } : hItem));
                        return;
                    }

                    setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'generating', progress: Math.min(95, (hItem.progress || 10) + 2) } : hItem));
                    setTimeout(() => pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId, attempt + 1), delayMs);
                })
                .catch(err => {
                    console.error('[Tapnow] Sora/Grok Poll 请求失败:', err);
                    // 如果是网络错误，继续重试；如果是其他错误，标记为失败
                    if (attempt < maxAttempts - 5) {
                        // 前75次尝试继续重试
                        setTimeout(() => pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId, attempt + 1), delayMs);
                    } else {
                        // 最后5次尝试失败后，标记为失败
                        setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: `轮询失败: ${err.message || '网络错误'}` } : hItem));
                    }
                });
            };

            // 切割Midjourney返回的4张图（2x2网格）
            // 压缩图片以减少存储大小
            const compressImage = (dataUrl, maxWidth = 1024, quality = 0.8) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // 计算压缩后的尺寸
                        let width = img.width;
                        let height = img.height;
                        if (width > maxWidth || height > maxWidth) {
                            const scale = maxWidth / Math.max(width, height);
                            width = Math.floor(width * scale);
                            height = Math.floor(height * scale);
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        // 绘制并压缩
                        ctx.drawImage(img, 0, 0, width, height);
                        // 使用JPEG格式压缩，减少文件大小
                        const compressed = canvas.toDataURL('image/jpeg', quality);
                        resolve(compressed);
                    };
                    img.onerror = () => resolve(dataUrl); // 如果压缩失败，返回原图
                    img.src = dataUrl;
                });
            };

            const splitMidjourneyImage = async (imageUrl, ratio = '1:1') => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    // 设置超时，防止图片加载卡死
                    const timeout = setTimeout(() => {
                        reject(new Error('图片加载超时'));
                    }, 30000); // 30秒超时
                    
                    img.onload = () => {
                        clearTimeout(timeout);
                        try {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // Midjourney返回的是2x2网格，每张图是原图的1/4
                            // 计算每张图的尺寸（使用Math.floor确保整数像素）
                            const singleWidth = Math.floor(img.width / 2);
                            const singleHeight = Math.floor(img.height / 2);
                            
                            // 计算实际每张图的比例
                            const actualRatio = singleWidth / singleHeight;
                            
                            const images = [];
                            
                            // 切割4张图：左上、右上、左下、右下
                            for (let row = 0; row < 2; row++) {
                                for (let col = 0; col < 2; col++) {
                                    // 计算裁剪区域（确保不超出边界）
                                    const cropX = Math.max(0, Math.min(col * singleWidth, img.width - singleWidth));
                                    const cropY = Math.max(0, Math.min(row * singleHeight, img.height - singleHeight));
                                    const cropW = Math.min(singleWidth, img.width - cropX);
                                    const cropH = Math.min(singleHeight, img.height - cropY);
                                    
                                    // 设置canvas尺寸
                                    canvas.width = cropW;
                                    canvas.height = cropH;
                                    
                                    // 清空canvas并设置白色背景（防止透明区域）
                                    ctx.fillStyle = '#ffffff';
                                    ctx.fillRect(0, 0, cropW, cropH);
                                    
                                    // 提取图片区域
                                    ctx.drawImage(
                                        img,
                                        cropX, cropY, cropW, cropH,
                                        0, 0, cropW, cropH
                                    );
                                    
                                    // 使用PNG格式，保持图片质量
                                    const dataUrl = canvas.toDataURL('image/png');
                                    images.push({
                                        url: dataUrl,
                                        width: cropW,
                                        height: cropH,
                                        ratio: actualRatio
                                    });
                                }
                            }
                            
                            console.log(`Midjourney: 切割图片完成，原图尺寸 ${img.width}x${img.height}，每张图尺寸 ${singleWidth}x${singleHeight}，比例 ${actualRatio.toFixed(2)}`);
                            resolve(images);
                        } catch (error) {
                            console.error('Midjourney: 切割图片时出错:', error);
                            reject(error);
                        }
                    };
                    
                    img.onerror = (e) => {
                        clearTimeout(timeout);
                        console.error('Midjourney: Failed to load image for splitting:', e);
                        reject(new Error('图片加载失败'));
                    };
                    
                    img.src = imageUrl;
                });
            };

            // 异步图像生成任务轮询函数
            const pollImageTask = (taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, attempt = 0, isBananaModel = false) => {
                // banana模型使用800秒超时（160次 * 5秒），其他模型使用25分钟（300次 * 5秒）
                const maxAttempts = isBananaModel ? 160 : 300;
                const baseDelayMs = 5000; // 基础轮询间隔5秒

                if (attempt > maxAttempts) {
                    const timeoutSeconds = isBananaModel ? 800 : 1500;
                    setHistory((prev) => prev.map((hItem) => 
                        hItem.id === taskId 
                            ? { ...hItem, status: 'failed', errorMsg: `图像生成轮询超时（已等待${timeoutSeconds}秒）` } 
                            : hItem
                    ));
                    return;
                }

                const cleanBaseUrl = baseUrl.replace(/\/+$/, '');
                const pollUrl = `${cleanBaseUrl}/v1/images/tasks/${taskIdForPoll}`;

                fetch(pollUrl, {
                    method: 'GET',
                    headers: { 
                        Authorization: `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                })
                .then((resp) => resp.text())
                .then((text) => {
                    let data;
                    try { 
                        data = JSON.parse(text); 
                    } catch (err) { 
                        console.error('[Async Image] Failed to parse response:', err);
                        setTimeout(() => pollImageTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, attempt + 1, isBananaModel), delayMs); 
                        return; 
                    }

                    console.log('[Async Image] Poll:', data);
                    
                    // 根据API规范，响应格式可能有多种：
                    // 1. { code, message, data: { status, images: [...] } }
                    // 2. { status: "SUCCESS", data: { data: [{ url: "..." }] } }
                    // 3. { task_id: "...", status: "SUCCESS", data: { data: [{ url: "..." }] } }
                    const status = (data?.data?.status || data?.status || '').toUpperCase();
                    console.log('[Async Image] 提取的状态:', status, '原始数据:', { 
                        hasData: !!data?.data, 
                        hasDataData: !!data?.data?.data,
                        hasDataStatus: !!data?.data?.status,
                        hasStatus: !!data?.status,
                        dataKeys: data ? Object.keys(data) : []
                    });
                    
                    let images = [];
                    
                    // 尝试多种方式提取图片数据（按优先级顺序）
                    // 方式1：data.data.data（嵌套格式，最常见）
                    if (data?.data?.data && Array.isArray(data.data.data) && data.data.data.length > 0) {
                        images = data.data.data;
                        console.log('[Async Image] 从 data.data.data 提取到图片:', images.length, '张');
                    }
                    // 方式2：data.data.images
                    else if (data?.data?.images && Array.isArray(data.data.images) && data.data.images.length > 0) {
                        images = data.data.images;
                        console.log('[Async Image] 从 data.data.images 提取到图片:', images.length, '张');
                    }
                    // 方式3：data.images
                    else if (data?.images && Array.isArray(data.images) && data.images.length > 0) {
                        images = data.images;
                        console.log('[Async Image] 从 data.images 提取到图片:', images.length, '张');
                    }
                    // 方式4：data.data（标准OpenAI格式）
                    else if (data?.data && Array.isArray(data.data) && data.data.length > 0) {
                        images = data.data;
                        console.log('[Async Image] 从 data.data 提取到图片:', images.length, '张');
                    }
                    
                    // 如果还是没有找到图片，尝试从revised_prompt中提取URL（备用方案）
                    if (images.length === 0) {
                        // 尝试从data.data.data[0].revised_prompt中提取
                        if (data?.data?.data && Array.isArray(data.data.data) && data.data.data.length > 0) {
                            const firstItem = data.data.data[0];
                            if (firstItem?.revised_prompt) {
                                const urlMatch = firstItem.revised_prompt.match(/!\[.*?\]\((https?:\/\/[^\s\)]+)\)/);
                                if (urlMatch && urlMatch[1]) {
                                    images = [{ url: urlMatch[1] }];
                                    console.log('[Async Image] 从 revised_prompt 中提取到图片URL:', urlMatch[1]);
                                }
                            }
                        }
                        // 尝试从data.data.revised_prompt中提取
                        if (images.length === 0 && data?.data?.revised_prompt) {
                            const urlMatch = data.data.revised_prompt.match(/!\[.*?\]\((https?:\/\/[^\s\)]+)\)/);
                            if (urlMatch && urlMatch[1]) {
                                images = [{ url: urlMatch[1] }];
                                console.log('[Async Image] 从 data.data.revised_prompt 中提取到图片URL:', urlMatch[1]);
                            }
                        }
                        // 最后尝试：如果data.data.data存在但images为空，可能是数据结构问题，直接使用data.data.data
                        if (images.length === 0 && data?.data?.data && Array.isArray(data.data.data) && data.data.data.length > 0) {
                            // 检查每个元素是否有url字段
                            const itemsWithUrl = data.data.data.filter(item => item?.url || item?.image_url || item?.imageUrl);
                            if (itemsWithUrl.length > 0) {
                                images = itemsWithUrl;
                                console.log('[Async Image] 从 data.data.data 中重新提取到图片（二次尝试）:', images.length, '张');
                            }
                        }
                        
                        // 如果任务状态是SUCCESS但还没找到图片，立即执行深度搜索（不等待后续处理）
                        if (images.length === 0 && (status === 'COMPLETED' || status === 'SUCCESS' || status === 'FINISHED' || status === 'DONE')) {
                            console.log('[Async Image] 任务状态为成功但图片数量为0，立即执行深度搜索');
                            // 优化后的深度搜索函数：优先检查常见路径，减少递归深度
                            const deepSearchForUrl = (obj, depth = 0, visited = new WeakSet()) => {
                                if (depth > 5) return null; // 防止无限递归
                                if (!obj || typeof obj !== 'object') return null;
                                
                                // 防止循环引用
                                if (visited.has(obj)) return null;
                                visited.add(obj);
                                
                                // 优先检查当前对象的常见字段（避免不必要的递归）
                                const urlFields = ['url', 'image_url', 'imageUrl', 'image', 'src', 'link', 'href'];
                                for (const field of urlFields) {
                                    if (obj[field] && typeof obj[field] === 'string' && obj[field].startsWith('http')) {
                                        return obj[field];
                                    }
                                }
                                
                                // 如果是数组，优先检查第一个元素
                                if (Array.isArray(obj) && obj.length > 0) {
                                    const result = deepSearchForUrl(obj[0], depth + 1, visited);
                                    if (result) return result;
                                }
                                
                                // 递归搜索所有属性（但跳过已检查的常见字段）
                                for (const key in obj) {
                                    if (obj.hasOwnProperty(key) && !urlFields.includes(key)) {
                                        const result = deepSearchForUrl(obj[key], depth + 1, visited);
                                        if (result) return result;
                                    }
                                }
                                
                                return null;
                            };
                            
                            const foundUrl = deepSearchForUrl(data);
                            if (foundUrl) {
                                images = [{ url: foundUrl }];
                                console.log('[Async Image] 通过立即深度搜索找到图片URL:', foundUrl);
                            } else {
                                console.warn('[Async Image] 深度搜索未找到图片URL，响应数据结构:', JSON.stringify(data, null, 2).substring(0, 500));
                            }
                        }
                    }
                    
                    const errorMsg = data?.message || data?.error || data?.fail_reason || '';

                    // 更新历史记录
                    setHistory((prev) => {
                        const updated = prev.map((hItem) => {
                            if (hItem.id === taskId) {
                                // 支持多种成功状态值
                                if (status === 'COMPLETED' || status === 'SUCCESS' || status === 'FINISHED' || status === 'DONE') {
                                    console.log('[Async Image] 任务状态为成功:', status, '图片数量:', images.length);
                                    
                                    // 保存sourceNodeId，用于后续更新预览窗口
                                    const savedSourceNodeId = hItem.sourceNodeId || sourceNodeId;
                                    
                                    // 任务完成
                                    if (images && images.length > 0) {
                                        // 提取图片URL，支持多种字段名和格式
                                        const imageUrls = images.map(img => {
                                            if (typeof img === 'string') return img;
                                            return img?.url || img?.image_url || img?.imageUrl || '';
                                        }).filter(Boolean);
                                        
                                        console.log('[Async Image] 提取到的图片URLs:', imageUrls);
                                        
                                        if (imageUrls.length > 0) {
                                            const primaryUrl = imageUrls[0];
                                            
                                            // 优先使用后端返回的实际花费时间（如果存在）
                                            // 后端可能返回的字段：duration, cost_time, elapsed_time, time_cost, spent_time 等（单位可能是秒或毫秒）
                                            let durationMs = null;
                                            const backendDuration = data?.data?.duration || data?.data?.cost_time || data?.data?.elapsed_time || 
                                                                  data?.data?.time_cost || data?.data?.spent_time || data?.duration || 
                                                                  data?.cost_time || data?.elapsed_time || data?.time_cost || data?.spent_time;
                                            
                                            if (backendDuration !== null && backendDuration !== undefined) {
                                                // 如果后端返回的是秒（数字<10000），转换为毫秒；否则认为是毫秒
                                                if (typeof backendDuration === 'number') {
                                                    durationMs = backendDuration < 10000 ? backendDuration * 1000 : backendDuration;
                                                } else if (typeof backendDuration === 'string') {
                                                    // 尝试解析字符串格式的时间（如 "49.0s", "107.0s"）
                                                    const match = backendDuration.match(/(\d+\.?\d*)\s*(s|ms|秒|毫秒)/i);
                                                    if (match) {
                                                        const value = parseFloat(match[1]);
                                                        const unit = match[2].toLowerCase();
                                                        durationMs = (unit === 's' || unit === '秒') ? value * 1000 : value;
                                                    } else {
                                                        const parsed = parseFloat(backendDuration);
                                                        if (!isNaN(parsed)) {
                                                            durationMs = parsed < 10000 ? parsed * 1000 : parsed;
                                                        }
                                                    }
                                                }
                                            }
                                            
                                            // 如果后端没有返回时间，使用前端计算的时间
                                            if (durationMs === null) {
                                                const endTime = Date.now();
                                                durationMs = endTime - (hItem.startTime || endTime);
                                            }
                                            
                                            console.log('[Async Image] 任务完成，准备更新UI:', { 
                                                taskId, 
                                                url: primaryUrl, 
                                                sourceNodeId: savedSourceNodeId, 
                                                imageCount: imageUrls.length,
                                                durationMs,
                                                backendDuration,
                                                frontendCalculated: durationMs === null ? null : (Date.now() - (hItem.startTime || Date.now()))
                                            });
                                            
                                            // 更新预览窗口（立即执行，不等待）
                                            // 即使savedSourceNodeId为空，也尝试调用updatePreviewFromTask，它会从history中查找
                                            const nodeIdToUse = savedSourceNodeId || hItem.sourceNodeId;
                                            console.log('[Async Image] 准备更新预览窗口', { 
                                                taskId, 
                                                url: primaryUrl, 
                                                sourceNodeId: nodeIdToUse, 
                                                savedSourceNodeId,
                                                hItemSourceNodeId: hItem.sourceNodeId,
                                                imageCount: imageUrls.length 
                                            });
                                            // 使用requestAnimationFrame确保在下一个渲染周期更新，但比setTimeout更快
                                            requestAnimationFrame(() => {
                                                updatePreviewFromTask(taskId, primaryUrl, 'image', nodeIdToUse, imageUrls.length > 1 ? imageUrls : null);
                                            });
                                            
                                            return { 
                                                ...hItem, 
                                                status: 'completed', 
                                                progress: 100, 
                                                url: primaryUrl,
                                                width: w,
                                                height: h,
                                                durationMs,
                                                errorMsg: null,
                                                sourceNodeId: savedSourceNodeId || hItem.sourceNodeId, // 确保sourceNodeId被保留
                                                ...(imageUrls.length > 1 ? { mjImages: imageUrls, selectedMjImageIndex: 0 } : {})
                                            };
                                        } else {
                                            console.error('[Async Image] 图片数组为空或无法提取URL:', images);
                                        }
                                    } else {
                                        console.error('[Async Image] 任务完成但未找到图片数据，尝试最后备用方案:', {
                                            status,
                                            hasData: !!data?.data,
                                            hasDataData: !!data?.data?.data,
                                            fullData: JSON.stringify(data, null, 2).substring(0, 1000)
                                        });
                                        
                                        // 最后备用方案：深度搜索整个响应对象，查找任何包含url的字段
                                        const deepSearchForUrl = (obj, depth = 0) => {
                                            if (depth > 5) return null; // 防止无限递归
                                            if (!obj || typeof obj !== 'object') return null;
                                            
                                            // 检查当前对象是否有url字段
                                            if (obj.url && typeof obj.url === 'string' && obj.url.startsWith('http')) {
                                                return obj.url;
                                            }
                                            if (obj.image_url && typeof obj.image_url === 'string' && obj.image_url.startsWith('http')) {
                                                return obj.image_url;
                                            }
                                            if (obj.imageUrl && typeof obj.imageUrl === 'string' && obj.imageUrl.startsWith('http')) {
                                                return obj.imageUrl;
                                            }
                                            
                                            // 递归搜索所有属性
                                            for (const key in obj) {
                                                if (obj.hasOwnProperty(key)) {
                                                    const result = deepSearchForUrl(obj[key], depth + 1);
                                                    if (result) return result;
                                                }
                                            }
                                            
                                            return null;
                                        };
                                        
                                        const foundUrl = deepSearchForUrl(data);
                                        if (foundUrl) {
                                            console.log('[Async Image] 通过深度搜索找到图片URL:', foundUrl);
                                            
                                            // 优先使用后端返回的实际花费时间（如果存在）
                                            let durationMs = null;
                                            const backendDuration = data?.data?.duration || data?.data?.cost_time || data?.data?.elapsed_time || 
                                                                  data?.data?.time_cost || data?.data?.spent_time || data?.duration || 
                                                                  data?.cost_time || data?.elapsed_time || data?.time_cost || data?.spent_time;
                                            
                                            if (backendDuration !== null && backendDuration !== undefined) {
                                                if (typeof backendDuration === 'number') {
                                                    durationMs = backendDuration < 10000 ? backendDuration * 1000 : backendDuration;
                                                } else if (typeof backendDuration === 'string') {
                                                    const match = backendDuration.match(/(\d+\.?\d*)\s*(s|ms|秒|毫秒)/i);
                                                    if (match) {
                                                        const value = parseFloat(match[1]);
                                                        const unit = match[2].toLowerCase();
                                                        durationMs = (unit === 's' || unit === '秒') ? value * 1000 : value;
                                                    } else {
                                                        const parsed = parseFloat(backendDuration);
                                                        if (!isNaN(parsed)) {
                                                            durationMs = parsed < 10000 ? parsed * 1000 : parsed;
                                                        }
                                                    }
                                                }
                                            }
                                            
                                            // 如果后端没有返回时间，使用前端计算的时间
                                            if (durationMs === null) {
                                                const endTime = Date.now();
                                                durationMs = endTime - (hItem.startTime || endTime);
                                            }
                                            
                                            // 更新预览窗口（立即执行，不等待）
                                            // 即使savedSourceNodeId为空，也尝试调用updatePreviewFromTask，它会从history中查找
                                            const nodeIdToUse = savedSourceNodeId || hItem.sourceNodeId;
                                            console.log('[Async Image] 准备更新预览窗口（深度搜索）', { 
                                                taskId, 
                                                url: foundUrl, 
                                                sourceNodeId: nodeIdToUse,
                                                savedSourceNodeId,
                                                hItemSourceNodeId: hItem.sourceNodeId
                                            });
                                            // 使用requestAnimationFrame确保在下一个渲染周期更新，但比setTimeout更快
                                            requestAnimationFrame(() => {
                                                updatePreviewFromTask(taskId, foundUrl, 'image', nodeIdToUse, null);
                                            });
                                            
                                            return { 
                                                ...hItem, 
                                                status: 'completed', 
                                                progress: 100, 
                                                url: foundUrl,
                                                width: w,
                                                height: h,
                                                durationMs,
                                                errorMsg: null,
                                                sourceNodeId: savedSourceNodeId || hItem.sourceNodeId // 确保sourceNodeId被保留
                                            };
                                        }
                                    }
                                    
                                    // 如果所有方法都失败，标记为失败
                                    return { 
                                        ...hItem, 
                                        status: 'failed', 
                                        errorMsg: errorMsg || '任务完成但未返回图片，请检查控制台日志查看详细响应数据' 
                                    };
                                } else if (status === 'FAILED' || status === 'ERROR' || status === 'CANCELLED' || status === 'FAILURE') {
                                // 任务失败
                                return { 
                                    ...hItem, 
                                    status: 'failed', 
                                    errorMsg: errorMsg || `任务失败: ${status}` 
                                };
                            } else if (status === 'PENDING' || status === 'PROCESSING' || status === 'GENERATING' || status === 'IN_PROGRESS' || status === 'RUNNING') {
                                // 任务进行中，根据轮询次数和进度信息计算进度
                                let progress = 10 + (attempt * 2); // 基础进度
                                
                                // 如果有进度百分比，使用实际进度
                                if (data?.data?.progress) {
                                    const progressStr = String(data.data.progress);
                                    if (progressStr.includes('%')) {
                                        progress = parseInt(progressStr.replace('%', ''), 10) || progress;
                                    } else if (typeof data.data.progress === 'number') {
                                        progress = data.data.progress;
                                    }
                                } else if (data?.progress) {
                                    const progressStr = String(data.progress);
                                    if (progressStr.includes('%')) {
                                        progress = parseInt(progressStr.replace('%', ''), 10) || progress;
                                    } else if (typeof data.progress === 'number') {
                                        progress = data.progress;
                                    }
                                }
                                
                                progress = Math.min(95, Math.max(10, progress)); // 限制在10-95%之间
                                
                                return { 
                                    ...hItem, 
                                    status: 'generating', 
                                    progress,
                                    errorMsg: null
                                };
                            } else {
                                // 未知状态，继续轮询，但进度缓慢增加
                                const progress = Math.min(90, 10 + (attempt * 1.5));
                                return { 
                                    ...hItem, 
                                    status: 'generating', 
                                    progress,
                                    errorMsg: null
                                };
                            }
                        }
                        return hItem;
                    });
                    
                    // 获取更新后的进度，用于动态调整轮询间隔
                    const updatedItem = updated.find(h => h.id === taskId);
                    const currentProgress = updatedItem?.progress || 10;
                    
                    return updated;
                });

                    // 如果任务未完成，继续轮询
                    // 动态调整轮询间隔：任务接近完成时缩短间隔，确保能快速检测到完成状态
                    const currentStatus = (data?.data?.status || data?.status || '').toUpperCase();
                    const isCompleted = currentStatus === 'COMPLETED' || currentStatus === 'SUCCESS' || currentStatus === 'FINISHED' || currentStatus === 'DONE';
                    const isFailed = currentStatus === 'FAILED' || currentStatus === 'ERROR' || currentStatus === 'CANCELLED' || currentStatus === 'FAILURE';
                    
                    if (!isCompleted && !isFailed) {
                        // 动态轮询间隔策略：
                        // 1. 任务进度>90%：1秒间隔（快速检测完成）
                        // 2. 任务进度>70%：2秒间隔（加快检测）
                        // 3. 任务进度>50%：3秒间隔（中等速度）
                        // 4. 任务进行中（<50%）：5秒间隔（基础间隔）
                        // 5. 长时间运行（>50次轮询且非banana模型）：10秒间隔（节省资源）
                        
                        // 从更新后的history中获取最新进度来计算延迟
                        setHistory((prev) => {
                            const latestItem = prev.find(h => h.id === taskId);
                            const progress = latestItem?.progress || 10;
                            
                            let adjustedDelay = baseDelayMs;
                            if (progress >= 90) {
                                adjustedDelay = 1000; // 1秒：任务接近完成，快速检测
                            } else if (progress >= 70) {
                                adjustedDelay = 2000; // 2秒：任务进行中后期，加快检测
                            } else if (progress >= 50) {
                                adjustedDelay = 3000; // 3秒：任务进行中，中等速度
                            } else if (attempt > 50 && !isBananaModel) {
                                adjustedDelay = 10000; // 10秒：长时间运行，节省资源
                            }
                            
                            // 在回调外执行setTimeout，避免闭包问题
                            setTimeout(() => {
                                pollImageTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, attempt + 1, isBananaModel);
                            }, adjustedDelay);
                            
                            return prev; // 不修改，只是读取
                        });
                    }
                })
                .catch((err) => {
                    console.error('[Async Image] Poll error:', err);
                    setTimeout(() => pollImageTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, attempt + 1, isBananaModel), baseDelayMs);
                });
            };

            // Midjourney任务轮询函数
            const pollMidjourneyJob = (jobId, taskId, baseUrl, apiKey, mjMode = 'fast', w, h, attempt = 0) => {
                const maxAttempts = 120; // 最多轮询120次（约10分钟，假设每次5秒）
                const delayMs = 5000; // 每5秒轮询一次

                if (attempt > maxAttempts) {
                    setHistory((prev) => prev.map((hItem) => 
                        hItem.id === taskId 
                            ? { ...hItem, status: 'failed', errorMsg: 'Midjourney 轮询超时' } 
                            : hItem
                    ));
                    return;
                }

                fetch(`${baseUrl}/${mjMode}/mj/task/${jobId}/fetch`, {
                    method: 'GET',
                    headers: { 
                        Authorization: `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                })
                .then((resp) => resp.text())
                .then((text) => {
                    let data;
                    try { 
                        data = JSON.parse(text); 
                    } catch (err) { 
                        console.error('Midjourney: Failed to parse response:', err);
                        setTimeout(() => pollMidjourneyJob(jobId, taskId, baseUrl, apiKey, mjMode, w, h, attempt + 1), delayMs); 
                        return; 
                    }

                    console.log('[Tapnow] Midjourney Poll:', data);
                    
                    const status = data?.status || '';
                    const progress = data?.progress || '0%';
                    const imageUrl = data?.imageUrl || '';
                    const failReason = data?.failReason || '';
                    const buttons = data?.buttons || [];

                    // 解析进度百分比
                    let progressNum = 0;
                    if (typeof progress === 'string' && progress.includes('%')) {
                        progressNum = parseInt(progress.replace('%', ''), 10) || 0;
                    } else if (typeof progress === 'number') {
                        progressNum = progress;
                    }

                    // 更新历史记录
                    setHistory((prev) => prev.map((hItem) => {
                        if (hItem.id === taskId) {
                            let newStatus = hItem.status;
                            let newErrorMsg = hItem.errorMsg;
                            let newProgress = progressNum;

                            if (status === 'SUCCESS' || status === 'FINISHED') {
                                newStatus = 'completed';
                                newProgress = 100;
                                newErrorMsg = null;
                                
                                // 如果是Midjourney任务且有图片URL，切割成4张图（拓展图片任务不需要切割）
                                if (imageUrl && hItem.apiConfig?.modelId?.includes('mj') && hItem.apiConfig?.modelId !== 'mj-zoom') {
                                    // 获取比例信息（从prompt中提取或使用默认值）
                                    let ratio = '1:1';
                                    if (hItem.prompt && hItem.prompt.includes('--ar ')) {
                                        const arMatch = hItem.prompt.match(/--ar\s+([\d:]+)/);
                                        if (arMatch && arMatch[1]) {
                                            ratio = arMatch[1];
                                        }
                                    }
                                    
                                    // 异步切割图片，不阻塞状态更新
                                    // 先更新状态，显示原图，避免白屏
                                    setHistory((prev) => prev.map((hItem) => 
                                        hItem.id === taskId 
                                            ? { ...hItem, url: imageUrl, mjRatio: ratio, mjOriginalUrl: imageUrl, mjNeedsSplit: true } 
                                            : hItem
                                    ));
                                    
                                    // 立即将完整原图同步到预览窗口（不裁剪）
                                    // 直接传入 sourceNodeId，避免依赖可能未更新的 history 状态
                                    // 使用 setTimeout 确保在下一个事件循环中执行，避免状态更新冲突
                                    const sourceNodeIdForPreview = hItem.sourceNodeId;
                                    if (sourceNodeIdForPreview) {
                                        setTimeout(() => {
                                            console.log('[Tapnow] Midjourney: 准备更新预览窗口', { taskId, imageUrl, sourceNodeId: sourceNodeIdForPreview });
                                            updatePreviewFromTask(taskId, imageUrl, 'image', sourceNodeIdForPreview);
                                        }, 0);
                                    } else {
                                        console.warn('[Tapnow] Midjourney: 未找到 sourceNodeId，无法更新预览窗口', { taskId, hItem });
                                    }
                                    
                                    // 延迟切割，确保UI先更新显示原图，避免白屏
                                    setTimeout(() => {
                                        splitMidjourneyImage(imageUrl, ratio).then((splitImages) => {
                                            // 提取URL数组（兼容新旧格式）
                                            const imageUrls = splitImages.map(img => typeof img === 'string' ? img : img.url);
                                            const firstImage = splitImages[0];
                                            const firstUrl = typeof firstImage === 'string' ? firstImage : firstImage.url;
                                            
                                            setHistory((prev) => prev.map((hItem) => 
                                                hItem.id === taskId 
                                                    ? { 
                                                        ...hItem, 
                                                        mjImages: imageUrls, 
                                                        url: firstUrl, 
                                                        selectedMjImageIndex: 0,
                                                        mjRatio: ratio,
                                                        mjOriginalUrl: imageUrl, // 保存原图URL
                                                        mjNeedsSplit: false, // 标记已切割
                                                        mjImageInfo: splitImages.map(img => typeof img === 'string' ? null : { width: img.width, height: img.height, ratio: img.ratio })
                                                    } 
                                                    : hItem
                                            ));
                                        }).catch((err) => {
                                            console.error('Midjourney: Failed to split image:', err);
                                            // 如果切割失败，保持原图显示，标记需要重新切割
                                            setHistory((prev) => prev.map((hItem) => 
                                                hItem.id === taskId 
                                                    ? { ...hItem, url: imageUrl, mjRatio: ratio, mjOriginalUrl: imageUrl, mjNeedsSplit: true } 
                                                    : hItem
                                            ));
                                        });
                                    }, 300); // 延迟300ms，确保原图已完全显示
                                    
                                    // 计算并保存用时
                                    const endTime = Date.now();
                                    const durationMs = endTime - (hItem.startTime || endTime);
                                    
                                    // 先更新状态，图片切割异步进行
                                    return { 
                                        ...hItem, 
                                        status: newStatus, 
                                        progress: newProgress, 
                                        errorMsg: newErrorMsg,
                                        url: imageUrl, // 临时使用原图，切割完成后会更新
                                        width: w,
                                        height: h,
                                        mjButtons: buttons,
                                        mjOriginalUrl: imageUrl, // 保存完整原图URL
                                        durationMs: durationMs
                                    };
                                }
                            } else if (status === 'FAILURE' || status === 'ERROR' || status === 'CANCELLED') {
                                newStatus = 'failed';
                                newErrorMsg = failReason || `任务失败: ${status}`;
                            } else if (status === 'NOT_START' || status === 'SUBMITTED' || status === 'IN_PROGRESS' || status === 'MODAL') {
                                newStatus = 'generating';
                                newErrorMsg = null;
                                // 如果进度为0%，至少显示5%
                                if (newProgress === 0) newProgress = 5;
                            } else {
                                newStatus = 'generating';
                                newErrorMsg = null;
                                // 渐进式更新进度
                                newProgress = Math.min(95, (hItem.progress || 5) + 2);
                            }

                                console.log(`[Tapnow] Midjourney Poll Status Update: Task ${taskId}, Status: ${newStatus}, Progress: ${newProgress}%, ImageUrl: ${imageUrl ? 'Yes' : 'No'}`);
                            
                            const updatedItem = { 
                                ...hItem, 
                                status: newStatus, 
                                progress: newProgress, 
                                errorMsg: newErrorMsg,
                                url: imageUrl || hItem.url,
                                width: w,
                                height: h,
                                mjButtons: buttons // 保存按钮信息，用于后续操作
                            };

                            // 如果任务成功且有图片URL，将结果同步到预览节点（使用完整原图，不裁剪）
                            // 注意：Midjourney任务已经在切割逻辑中处理了预览窗口更新，这里只处理非Midjourney任务
                            // 拓展图片任务（mj-zoom）也需要同步到节点
                            if ((status === 'SUCCESS' || status === 'FINISHED') && imageUrl && (!hItem.apiConfig?.modelId?.includes('mj') || hItem.apiConfig?.modelId === 'mj-zoom')) {
                                // 直接传入 sourceNodeId，避免依赖可能未更新的 history 状态
                                if (hItem.sourceNodeId) {
                                    console.log('[Tapnow] 图片生成: 准备更新节点', { taskId, imageUrl, sourceNodeId: hItem.sourceNodeId, modelId: hItem.apiConfig?.modelId });
                                    // 如果是拓展图片任务，更新拓展图片节点；否则更新预览窗口
                                    if (hItem.apiConfig?.modelId === 'mj-zoom') {
                                        setNodes((prev) => prev.map((n) => 
                                            n.id === hItem.sourceNodeId && n.type === 'expand-image'
                                                ? { ...n, content: imageUrl }
                                                : n
                                        ));
                                    } else {
                                        updatePreviewFromTask(taskId, imageUrl, 'image', hItem.sourceNodeId);
                                    }
                                } else {
                                    console.warn('[Tapnow] 图片生成: 未找到 sourceNodeId', { taskId, hItem });
                                }
                                
                                // 计算并保存用时
                                const endTime = Date.now();
                                const durationMs = endTime - (hItem.startTime || endTime);
                                updatedItem.durationMs = durationMs;
                            }

                            return updatedItem;
                        }
                        return hItem;
                    }));

                    // 如果任务完成或失败，停止轮询
                    if (status === 'SUCCESS' || status === 'FINISHED') {
                        return;
                    }

                    if (status === 'FAILURE' || status === 'ERROR' || status === 'CANCELLED') {
                        return;
                    }

                    // 继续轮询
                    setTimeout(() => pollMidjourneyJob(jobId, taskId, baseUrl, apiKey, mjMode, w, h, attempt + 1), delayMs);
                })
                .catch((err) => {
                    console.error(`[Tapnow] Midjourney Poll Fetch Error for task ${taskId}:`, err);
                    setHistory((prev) => prev.map((hItem) => 
                        hItem.id === taskId 
                            ? { ...hItem, status: 'failed', errorMsg: `轮询请求失败: ${err.message}` } 
                            : hItem
                    ));
                    // 即使出错也继续重试（最多重试3次）
                    if (attempt < 3) {
                        setTimeout(() => pollMidjourneyJob(jobId, taskId, baseUrl, apiKey, mjMode, w, h, attempt + 1), delayMs);
                    }
                });
            };

            // 处理蒙版用于 Inpainting：将"透明背景上的白色笔触"转换为"白色背景上的透明区域"
            const processMaskForInpainting = async (maskContent) => {
                if (!maskContent) return null;
                
                try {
                    // 加载蒙版图片
                    const maskImg = new Image();
                    maskImg.crossOrigin = 'anonymous';
                    await new Promise((resolve, reject) => {
                        maskImg.onload = resolve;
                        maskImg.onerror = reject;
                        maskImg.src = maskContent;
                    });
                    
                    // 创建新 Canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = maskImg.width;
                    canvas.height = maskImg.height;
                    const ctx = canvas.getContext('2d');
                    
                    // 填充黑色背景（代表保留区域，不透明 Alpha=1）
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // 使用 destination-out 混合模式：绘制原蒙版，将用户涂抹的区域"挖空"变成透明（代表重绘区域，Alpha=0）
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.drawImage(maskImg, 0, 0);
                    
                    // 将 Canvas 转换为 Blob（PNG 格式保留透明度）
                    return new Promise((resolve, reject) => {
                        canvas.toBlob((blob) => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('蒙版转换失败'));
                            }
                        }, 'image/png');
                    });
                } catch (error) {
                    console.error('[Inpainting] 蒙版处理失败:', error);
                    return null;
                }
            };

            const startGeneration = async (prompt, type, sourceImages, nodeId, options = {}) => {
                const connectedImages = Array.isArray(sourceImages) ? sourceImages : (sourceImages ? [sourceImages] : []);
                const sourceImage = connectedImages.length > 0 ? connectedImages[0] : undefined;

                if (!prompt && !sourceImage) { alert('请输入提示词或连接参考图片'); return; }

                // 检查是否是分镜表的虚拟节点ID（格式：storyboard-${nodeId}-shot-${shotId}）
                let node = null;
                if (nodeId && nodeId.startsWith('storyboard-') && nodeId.includes('-shot-')) {
                    // 这是分镜表的任务，不需要查找实际节点
                    node = null;
                } else {
                    node = nodes.find((n) => n.id === nodeId);
                }
                
                // 处理蒙版：先检查当前节点，如果没有则从上游节点查找
                let finalMaskBlob = null;
                let finalMaskContent = node?.maskContent;
                if (!finalMaskContent) {
                    // 查找连接到当前节点的源节点（优先查找 default 输入，如果没有则查找所有输入）
                    let incomingConn = connections.find(c => c.to === nodeId && (!c.inputType || c.inputType === 'default'));
                    if (!incomingConn) {
                        // 如果没有 default 连接，查找任何连接到该节点的连接
                        incomingConn = connections.find(c => c.to === nodeId);
                    }
                    if (incomingConn) {
                        // 使用 nodesMap 进行 O(1) 查找
                        const sourceNode = nodesMap.get(incomingConn.from);
                        if (sourceNode && sourceNode.maskContent) {
                            finalMaskContent = sourceNode.maskContent;
                            console.log('[Inpainting] 从上游节点获取蒙版:', sourceNode.id);
                        }
                    }
                } else {
                    console.log('[Inpainting] 使用当前节点的蒙版:', nodeId);
                }
                
                // 如果存在蒙版，处理蒙版（反转逻辑）
                if (finalMaskContent) {
                    finalMaskBlob = await processMaskForInpainting(finalMaskContent);
                    if (finalMaskBlob) {
                        console.log('[Inpainting] 蒙版已处理（已反转）');
                    } else {
                        console.warn('[Inpainting] 蒙版处理失败，将使用原始蒙版');
                    }
                }
                
                // 规范化 prompt：确保角色引用 @{username} 前后有空格（仅对 Sora 2 模型）
                const normalizePromptForSora = (text, modelId) => {
                    if (!text || !modelId || (!modelId.includes('sora') && modelId !== 'sora-2' && modelId !== 'sora-2-pro')) {
                        return text;
                    }
                    // 先处理不带大括号的格式 @username，转换为 @{username}
                    text = text.replace(/@([a-zA-Z0-9_\.]+)(?![a-zA-Z0-9_\.])/g, (match, username) => {
                        return `@{${username}}`;
                    });
                    // 然后处理带大括号的格式 @{username}，确保前后有空格
                    return text.replace(/@\{([^\}]+)\}/g, (match, username) => {
                        return ` @{${username}} `;
                    }).replace(/\s{2,}/g, ' ').trim(); // 清理多余空格
                };
                // 优先使用 options 中的 model，其次使用节点设置，最后使用默认值
                const modelId = options.model || node?.settings?.model || (type === 'image' ? 'nano-banana' : 'sora-2');
                const config = apiConfigsMap.get(modelId);
                const apiKey = config?.key || globalApiKey;
                const baseUrl = (config?.url || DEFAULT_BASE_URL).replace(/\/+$/, '');

                if (!apiKey) { alert('请先在设置中配置 API Key'); setSettingsOpen(true); return; }

                // 规范化 prompt（确保角色引用 @{username} 前后有空格，仅对 Sora 2 模型）
                if (prompt && (modelId.includes('sora') || modelId === 'sora-2' || modelId === 'sora-2-pro')) {
                    // 先处理不带大括号的格式 @username，转换为 @{username}
                    prompt = prompt.replace(/@([a-zA-Z0-9_\.]+)(?![a-zA-Z0-9_\.])/g, (match, username) => {
                        return `@{${username}}`;
                    });
                    // 然后处理带大括号的格式 @{username}，确保前后有空格
                    prompt = prompt.replace(/@\{([^\}]+)\}/g, (match, username) => {
                        return ` @{${username}} `;
                    }).replace(/\s{2,}/g, ' ').trim(); // 清理多余空格
                    console.log('[Sora 2] Normalized prompt:', prompt);
                }

                // 优先使用 options 中的 ratio，其次使用节点设置，最后使用默认值
                let ratio = options.ratio || node?.settings?.ratio || (modelId.includes('grok') ? '3:2' : '1:1');
                let resolution = node?.settings?.resolution || (modelId.includes('grok') ? '1080P' : 'Auto');
                let { sizeStr, w, h } = getModelParams(modelId, ratio, resolution);

                // Auto Resolution Logic (Direct Source, No Scaling, Just Alignment)
                // Fix: Only use source dimensions if Ratio is ALSO Auto. If user picks a ratio (e.g. 1:1), respect that.
                if (resolution === 'Auto' && ratio === 'Auto' && sourceImage) {
                    try {
                        const dims = await getImageDimensions(sourceImage);
                        // Force original size (aligned to 64) without downscaling
                        const safeW = Math.round(dims.w / 64) * 64;
                        const safeH = Math.round(dims.h / 64) * 64;
                        
                        w = safeW;
                        h = safeH;
                        sizeStr = `${safeW}x${safeH}`;
                        console.log(`[Auto Res] Using Source Dimensions: ${sizeStr}`);
                    } catch (e) { console.error("Auto Res Error", e); }
                } else {
                    if (!w || !h) {
                         const def = calculateResolution(ratio, resolution);
                         w = def.w;
                         h = def.h;
                         sizeStr = def.str;
                    }
                }

                // 当有参考图且选择了 Auto + (1K/2K/4K) 时：
                // 希望保持原图纵横比，只在原图分辨率基础上等比放大到目标级别（而不是变成固定 1:1 或 16:9）
                if (sourceImage && ratio === 'Auto' && ['1K', '2K', '4K'].includes(resolution)) {
                    try {
                        const dims = await getImageDimensions(sourceImage);
                        const longSideTarget = resolution === '4K'
                            ? 4096
                            : resolution === '2K'
                                ? 2048
                                : 1024;

                        const maxSide = Math.max(dims.w, dims.h) || 1;
                        const scale = longSideTarget / maxSide;
                        let newW = Math.round((dims.w * scale) / 16) * 16;
                        let newH = Math.round((dims.h * scale) / 16) * 16;

                        // 双保险，避免数值异常
                        newW = Math.max(16, newW);
                        newH = Math.max(16, newH);

                        w = newW;
                        h = newH;
                        sizeStr = `${newW}x${newH}`;
                        console.log(`[Auto+${resolution}] Upscale from ${dims.w}x${dims.h} -> ${sizeStr}`);
                    } catch (e) {
                        console.error('Auto+K Upscale Error', e);
                    }
                }

                // 优先使用 options 中的 duration，其次使用节点设置，最后使用默认值
                let duration = options.duration ? options.duration.replace('s', '') : (node?.settings?.duration?.replace('s', '') || '5');
                if (modelId.includes('veo')) duration = '8';

                const taskId = Date.now().toString();

                    // 获取正确的模型显示名称（用于历史记录）
                    const getModelDisplayName = () => {
                        // 如果是jimeng模型，根据modelId确定正确的provider名称
                        if (modelId.includes('jimeng-4.5')) return 'Jimeng 4.5';
                        if (modelId.includes('jimeng-4.1')) return 'Jimeng 4.1';
                        if (modelId.includes('jimeng-3.1')) return 'Jimeng 3.1';
                        // 其他模型使用config中的provider，如果没有则使用modelId
                        return config?.provider || modelId;
                    };
                
                const now = Date.now();
                const actualSourceNodeId = node?.id || nodeId || null;
                
                setHistory((prev) => [{
                    id: taskId, type, url: '',
                    prompt: prompt || (sourceImage ? `Img2${type === 'image' ? 'Img' : 'Vid'}` : 'Untitled'),
                    time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                    status: 'generating', progress: 5, modelName: getModelDisplayName(), width: w, height: h,
                    remoteTaskId: null, 
                    apiConfig: { modelId, baseUrl, apiKey },
                    sourceNodeId: actualSourceNodeId,
                    startTime: now,
                    durationMs: null,
                    ratio: ratio // 保存比例信息，用于后续验证返回结果
                }, ...prev]);
                
                // 检查是否是分镜表的任务（sourceNodeId 格式：storyboard-${nodeId}-shot-${shotId}）
                if (actualSourceNodeId && actualSourceNodeId.startsWith('storyboard-') && actualSourceNodeId.includes('-shot-')) {
                    const parts = actualSourceNodeId.split('-shot-');
                    if (parts.length === 2) {
                        const storyboardNodeId = parts[0].replace('storyboard-', '');
                        const shotId = parts[1];
                        // 记录任务映射
                        storyboardTaskMapRef.current.set(taskId, { nodeId: storyboardNodeId, shotId: shotId });
                        console.log('[分镜表] 任务已记录:', { taskId, nodeId: storyboardNodeId, shotId });
                    }
                }
                
                setHistoryOpen(true);

                try {
                    if (type === 'image') {
                        let endpoint = `${baseUrl}/v1/images/generations`;
                        let payload;
                        let useMultipart = false;

                        const isBananaLike = (modelId.includes('banana') || modelId.includes('edit') || modelId.includes('qwen')) && !(modelId.includes('nano-banana-2') || (config?.modelName ?? '').includes('nano-banana-2'));
                        const isOpenAIImage = modelId.includes('gpt') || (config?.modelName ?? '').includes('gpt-image') || (config?.provider ?? '').toLowerCase().includes('gpt-4o image');
                        const isFluxKontext = modelId.includes('flux') || (config?.modelName ?? '').includes('flux-kontext');
                    const isNanoBanana2 = (config?.modelName ?? '').includes('nano-banana-2') || modelId.includes('nano-banana-2');
                    const isMidjourney = modelId.includes('mj') || (config?.provider ?? '').toLowerCase().includes('midjourney');
                    const isJimeng = modelId.includes('jimeng-4.5') || modelId.includes('jimeng-4.1') || modelId.includes('jimeng-3.1') || (config?.modelName ?? '').includes('jimeng-4.5') || (config?.modelName ?? '').includes('jimeng-4.1') || (config?.modelName ?? '').includes('jimeng-3.1');
                    
                    // 获取jimeng模型名称，优先根据modelId判断（用户当前选择的模型），其次使用config中的modelName
                    const getJimengModelName = () => {
                        // 优先根据modelId判断，因为modelId是用户当前选择的模型
                        if (modelId.includes('jimeng-4.5')) return 'jimeng-4.5';
                        if (modelId.includes('jimeng-4.1')) return 'jimeng-4.1';
                        if (modelId.includes('jimeng-3.1')) return 'jimeng-3.1';
                        // 如果modelId无法判断，再使用config中的modelName
                        if (config?.modelName && (config.modelName.includes('jimeng-4.5') || config.modelName.includes('jimeng-4.1') || config.modelName.includes('jimeng-3.1'))) {
                            return config.modelName;
                        }
                        return 'jimeng-4.5'; // 默认使用4.5
                    };

                    const getImageSizeFlag = () => {
                        if (!isNanoBanana2) return undefined;
                        if (resolution === '4K') return '4K';
                        if (resolution === '2K') return '2K';
                        return '1K';
                    };
                    const imageSizeFlag = getImageSizeFlag();
                    const aspect = ratio === 'Auto' ? undefined : ratio;

                        if (connectedImages.length > 0 && isBananaLike) {
                            endpoint = `${baseUrl}/v1/images/edits`;
                            useMultipart = true;
                            const formData = new FormData();
                            formData.append('model', config?.modelName || 'nano-banana');
                            formData.append('prompt', prompt || 'enhance');
                            formData.append('n', '1');
                            formData.append('size', sizeStr);
                        if (aspect) formData.append('aspect_ratio', aspect);
                        if (imageSizeFlag) formData.append('image_size', imageSizeFlag);
                            
                            const blobPromises = connectedImages.map(url => getBlobFromUrl(url));
                            const blobs = await Promise.all(blobPromises);
                            blobs.forEach((blob, i) => {
                                formData.append('image', blob, `input_${i}.png`);
                            });
                            
                            // 使用已处理的蒙版（如果存在）
                            if (finalMaskBlob) {
                                formData.append('mask', finalMaskBlob, 'mask.png');
                                console.log('[Inpainting] 已添加处理后的蒙版数据');
                                // 确保使用 edits 接口（Inpainting 模式）
                                if (endpoint.includes('/generations')) {
                                    endpoint = `${baseUrl}/v1/images/edits${useAsync ? '?async=true' : ''}`;
                                }
                            }
                            
                            payload = formData;
                        } 
                        else if (isFluxKontext) {
                            // Flux(Dalle3 Edits) 走 multipart /v1/images/edits，支持多参考图
                            endpoint = `${baseUrl}/v1/images/edits`;
                            useMultipart = true;
                            const formData = new FormData();
                            formData.append('model', config?.modelName || 'flux-kontext-pro');
                            formData.append('prompt', prompt || '');
                            if (aspect) formData.append('aspect_ratio', aspect);
                            if (sizeStr) formData.append('size', sizeStr);
                            // 参考图：优先 connectedImages，其次 sourceImage
                            const refs = connectedImages.length > 0 ? connectedImages : (sourceImage ? [sourceImage] : []);
                            if (refs.length > 0) {
                                const blobPromises = refs.map(url => getBlobFromUrl(url));
                                const blobs = await Promise.all(blobPromises);
                                blobs.forEach((blob, i) => formData.append('image', blob, `flux_ref_${i}.png`));
                            }
                            
                            // 使用已处理的蒙版（如果存在）
                            if (finalMaskBlob) {
                                formData.append('mask', finalMaskBlob, 'mask.png');
                                console.log('[Inpainting] 已添加处理后的蒙版数据');
                            }
                            
                            payload = formData;
                        }
                        else if (isOpenAIImage) {
                            let finalPrompt = prompt || '';
                            const jsonBody = { 
                                model: config?.modelName || 'gpt-4o-image', 
                                prompt: finalPrompt, 
                                size: sizeStr, 
                                aspect_ratio: ratio 
                            };
                            
                            if (connectedImages.length > 0) {
                                const b64Promises = connectedImages.map(url => getBase64FromUrl(url));
                                const b64s = await Promise.all(b64Promises);
                                jsonBody.image = b64s.map(b => `data:image/png;base64,${b}`);
                            }
                            payload = jsonBody;
                    } else if (isNanoBanana2) {
                        // Nano-banana-2 根据新API规范：有参考图用edits，无参考图用generations
                        // 支持异步模式：添加async=true查询参数
                        const useAsync = true; // 默认启用异步模式
                        
                        if (connectedImages.length > 0) {
                            // 有参考图：使用 /v1/images/edits (multipart/form-data)
                            endpoint = `${baseUrl}/v1/images/edits${useAsync ? '?async=true' : ''}`;
                            useMultipart = true;
                            const formData = new FormData();
                            formData.append('model', config?.modelName || 'nano-banana-2');
                            formData.append('prompt', prompt || '');
                            formData.append('response_format', 'url');
                            if (aspect) formData.append('aspect_ratio', aspect);
                            if (imageSizeFlag) formData.append('image_size', imageSizeFlag);
                            
                            // 将参考图转换为blob并添加到formData
                            const blobPromises = connectedImages.map(url => getBlobFromUrl(url));
                            const blobs = await Promise.all(blobPromises);
                            blobs.forEach((blob, i) => {
                                formData.append('image', blob, `input_${i}.png`);
                            });
                            
                            // 使用已处理的蒙版（如果存在）
                            if (finalMaskBlob) {
                                formData.append('mask', finalMaskBlob, 'mask.png');
                                console.log('[Inpainting] 已添加处理后的蒙版数据');
                                // 确保使用 edits 接口（Inpainting 模式）
                                if (endpoint.includes('/generations')) {
                                    endpoint = `${baseUrl}/v1/images/edits${useAsync ? '?async=true' : ''}`;
                                }
                            }
                            
                            payload = formData;
                        } else {
                            // 无参考图：使用 /v1/images/generations (application/json)
                            endpoint = `${baseUrl}/v1/images/generations${useAsync ? '?async=true' : ''}`;
                            const jsonBody = {
                                model: config?.modelName || 'nano-banana-2',
                                prompt: prompt || '',
                                response_format: 'url',
                                ...(aspect ? { aspect_ratio: aspect } : {}),
                                ...(imageSizeFlag ? { image_size: imageSizeFlag } : {}),
                            };
                            // 如果有sourceImage，添加到image数组（支持url或b64_json格式）
                            if (sourceImage) {
                                const trimmedImg = sourceImage.trim();
                                // 如果是http/https URL，直接使用
                                if (trimmedImg.startsWith('http://') || trimmedImg.startsWith('https://')) {
                                    jsonBody.image = [trimmedImg];
                                } 
                                // 如果是data URL，直接使用
                                else if (trimmedImg.startsWith('data:')) {
                                    jsonBody.image = [trimmedImg];
                                } 
                                // 其他格式，转换为base64
                                else {
                                    const b64 = await getBase64FromUrl(trimmedImg);
                                    jsonBody.image = [`data:image/png;base64,${b64}`];
                                }
                            }
                            payload = jsonBody;
                        }
                    } else if (isMidjourney) {
                        // Midjourney API: 使用 /mj/submit/imagine 接口
                        // 根据文档，支持fast和relax两种模式，通过URL路径区分
                        // 默认使用fast模式，可以通过配置或设置选择
                        const mjMode = node?.settings?.mjMode || 'fast'; // fast 或 relax
                        const mjVersion = node?.settings?.mjVersion || '--v 7';
                        
                        // 构建prompt，添加版本参数、比例参数和其他指令
                        let mjPrompt = prompt || '';
                        
                        // 添加比例参数 --ar（如果比例不是Auto）
                        if (ratio && ratio !== 'Auto') {
                            // 将比例转换为Midjourney格式，例如 1:1 -> --ar 1:1
                            if (!mjPrompt.includes('--ar ')) {
                                mjPrompt = `${mjPrompt} --ar ${ratio}`.trim();
                            }
                        }
                        
                        // 获取连接的图片（优先使用连接的图片，如果没有连接则使用手动输入的URL）
                        const orefConnected = getConnectedImageForInput(nodeId, 'oref');
                        const srefConnected = getConnectedImageForInput(nodeId, 'sref');
                        
                        // 收集所有需要上传的data URL图片（oref、sref和默认垫图）
                        const imagesToUpload = []; // 需要上传的data URL图片
                        const imageIndexMap = new Map(); // 记录每个图片在数组中的索引，用于映射上传后的URL
                        let orefImageUrl = null; // 用于在prompt中引用的URL
                        let srefImageUrl = null; // 用于在prompt中引用的URL
                        let defaultImageUrls = []; // 默认垫图的URL列表
                        
                        // 处理oref图片
                        const orefUrl = orefConnected || (node?.settings?.mjOref && node.settings.mjOref.trim());
                        if (orefUrl && orefUrl.trim()) {
                            let finalOrefUrl = orefUrl.trim();
                            // 如果是HTTP/HTTPS URL，直接使用
                            if (finalOrefUrl.startsWith('http://') || finalOrefUrl.startsWith('https://')) {
                                orefImageUrl = finalOrefUrl;
                            } 
                            // 如果是data URL，需要先上传获取HTTP URL
                            else if (finalOrefUrl.startsWith('data:')) {
                                imagesToUpload.push(finalOrefUrl);
                                imageIndexMap.set('oref', imagesToUpload.length - 1);
                            } else {
                                // 其他格式，尝试直接使用
                                orefImageUrl = finalOrefUrl;
                            }
                        }
                        
                        // 处理sref图片
                        const srefUrl = srefConnected || (node?.settings?.mjSref && node.settings.mjSref.trim());
                        if (srefUrl && srefUrl.trim()) {
                            let finalSrefUrl = srefUrl.trim();
                            // 如果是HTTP/HTTPS URL，直接使用
                            if (finalSrefUrl.startsWith('http://') || finalSrefUrl.startsWith('https://')) {
                                srefImageUrl = finalSrefUrl;
                            } 
                            // 如果是data URL，需要先上传获取HTTP URL
                            else if (finalSrefUrl.startsWith('data:')) {
                                imagesToUpload.push(finalSrefUrl);
                                imageIndexMap.set('sref', imagesToUpload.length - 1);
                            } else {
                                // 其他格式，尝试直接使用
                                srefImageUrl = finalSrefUrl;
                            }
                        }
                        
                        // 处理默认垫图（非oref/sref连接的图片）
                        if (connectedImages.length > 0) {
                            for (const img of connectedImages) {
                                const isOrefImage = orefConnected && img === orefConnected;
                                const isSrefImage = srefConnected && img === srefConnected;
                                if (!isOrefImage && !isSrefImage) {
                                    if (img.startsWith('http://') || img.startsWith('https://')) {
                                        // HTTP URL直接使用
                                        defaultImageUrls.push(img);
                                    } else if (img.startsWith('data:')) {
                                        // data URL需要上传
                                        imagesToUpload.push(img);
                                        imageIndexMap.set(`default_${defaultImageUrls.length}`, imagesToUpload.length - 1);
                                        // 先占位，上传后会替换
                                        defaultImageUrls.push(null);
                                    } else {
                                        // 其他格式，尝试直接使用
                                        defaultImageUrls.push(img);
                                    }
                                }
                            }
                        }
                        
                        // 如果有需要上传的图片，先上传获取URL
                        if (imagesToUpload.length > 0) {
                            try {
                                console.log(`Midjourney: 正在上传 ${imagesToUpload.length} 张图片获取URL...`);
                                const uploadedUrls = await uploadMidjourneyImages(imagesToUpload, baseUrl, apiKey);
                                
                                // 映射上传后的URL
                                if (imageIndexMap.has('oref')) {
                                    const index = imageIndexMap.get('oref');
                                    if (uploadedUrls[index]) {
                                        orefImageUrl = uploadedUrls[index];
                                        console.log('Midjourney: oref图片上传成功，获取URL:', orefImageUrl);
                                    }
                                }
                                
                                if (imageIndexMap.has('sref')) {
                                    const index = imageIndexMap.get('sref');
                                    if (uploadedUrls[index]) {
                                        srefImageUrl = uploadedUrls[index];
                                        console.log('Midjourney: sref图片上传成功，获取URL:', srefImageUrl);
                                    }
                                }
                                
                                // 更新默认垫图的URL
                                for (let i = 0; i < defaultImageUrls.length; i++) {
                                    if (defaultImageUrls[i] === null) {
                                        const key = `default_${i}`;
                                        if (imageIndexMap.has(key)) {
                                            const index = imageIndexMap.get(key);
                                            if (uploadedUrls[index]) {
                                                defaultImageUrls[i] = uploadedUrls[index];
                                                console.log(`Midjourney: 默认垫图${i}上传成功，获取URL:`, defaultImageUrls[i]);
                                            }
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('Midjourney: 图片上传失败:', error);
                                setHistory((prev) => prev.map((hItem) => 
                                    hItem.id === taskId 
                                        ? { ...hItem, status: 'failed', progress: 0, errorMsg: `图片上传失败: ${error.message}` } 
                                        : hItem
                                ));
                                return;
                            }
                        }
                        
                        // 过滤掉null值（上传失败的图片）
                        defaultImageUrls = defaultImageUrls.filter(url => url !== null);
                        
                        // 构建prompt：按照Midjourney格式
                        // 格式：默认垫图URL（在提示词前面，空格分隔）+ 文本提示词 + 版本 + 尺寸 + --oref [URL] + --ow [数值] + --sref [URL]
                        let finalMjPrompt = '';
                        
                        // 1. 首先添加默认垫图的URL（在提示词前面，用空格分隔）
                        if (defaultImageUrls.length > 0) {
                            finalMjPrompt = defaultImageUrls.join(' ') + ' ';
                        }
                        
                        // 2. 添加文本提示词
                        finalMjPrompt += mjPrompt.trim();
                        
                        // 3. 添加版本参数 --v（在提示词后面）
                        if (!finalMjPrompt.includes('--v ') && !finalMjPrompt.includes('--niji ')) {
                            finalMjPrompt = `${finalMjPrompt} ${mjVersion}`.trim();
                        }
                        
                        // 4. 添加比例参数 --ar（在版本后面）
                        if (ratio && ratio !== 'Auto') {
                            if (!finalMjPrompt.includes('--ar ')) {
                                finalMjPrompt = `${finalMjPrompt} --ar ${ratio}`.trim();
                            }
                        }
                        
                        // 5. 添加oref指令和图片URL（在尺寸后面）
                        if (orefImageUrl) {
                            if (!finalMjPrompt.includes('--oref ')) {
                                finalMjPrompt = `${finalMjPrompt} --oref ${orefImageUrl}`.trim();
                            }
                        }
                        
                        // 6. 添加ow指令
                        if (node?.settings?.mjOw && node.settings.mjOw > 0) {
                            const owValue = Math.min(1000, Math.max(1, node.settings.mjOw));
                            if (!finalMjPrompt.includes('--ow ')) {
                                finalMjPrompt = `${finalMjPrompt} --ow ${owValue}`.trim();
                            }
                        }
                        
                        // 7. 添加sref指令和图片URL（在最后）
                        if (srefImageUrl) {
                            if (!finalMjPrompt.includes('--sref ')) {
                                finalMjPrompt = `${finalMjPrompt} --sref ${srefImageUrl}`.trim();
                            }
                        }
                        
                        endpoint = `${baseUrl}/${mjMode}/mj/submit/imagine`;
                        payload = {
                            prompt: finalMjPrompt,
                            base64Array: [] // 不再使用base64Array，所有图片都已上传为URL
                        };
                        
                        // 提交Midjourney任务
                        const mjResp = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 
                                Authorization: `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(payload),
                        });
                        
                        const mjText = await mjResp.text();
                        if (!mjResp.ok) throw new Error(mjText || `Midjourney API error: ${mjResp.status}`);
                        let mjData = JSON.parse(mjText);
                        
                        // 检查响应状态码
                        if (mjData.code !== 1 && mjData.code !== 22) {
                            throw new Error(mjData.description || `Midjourney提交失败: code ${mjData.code}`);
                        }
                        
                        const remoteTaskId = mjData.result;
                        if (!remoteTaskId) throw new Error('未获取到任务ID');
                        
                        // 更新历史记录，保存远程任务ID
                        setHistory((prev) => prev.map((hItem) => 
                            hItem.id === taskId 
                                ? { ...hItem, remoteTaskId, status: mjData.code === 22 ? 'generating' : 'generating', progress: 5 } 
                                : hItem
                        ));
                        
                        // 开始轮询Midjourney任务状态
                        pollMidjourneyJob(remoteTaskId, taskId, baseUrl, apiKey, mjMode, w, h);
                        return;
                    } else if (isJimeng) {
                        // 即梦API处理
                        // 注意：即梦 API 不支持 /v1/images/edits 接口，即使有蒙版也使用 compositions 接口
                        if (connectedImages.length > 0) {
                            // 如果检测到蒙版，提示用户
                            if (finalMaskBlob) {
                                console.warn('[即梦API] 检测到蒙版，但即梦 API 暂不支持局部重绘，将执行全图参考生成');
                            }
                            
                            // 强制使用 compositions 接口（图生图模式）
                            endpoint = `${baseUrl}/v1/images/compositions`;
                            
                            // 确保prompt不为空（图生图也需要prompt）
                            if (!prompt || prompt.trim() === '') {
                                throw new Error('图生图功能需要提供提示词');
                            }
                            
                            // 智能尺寸处理：图生图时，如果ratio为Auto，以输入图片尺寸为准
                            let jimengRatio = ratio;
                            let jimengResolution = '2k'; // 默认2k
                            
                            if (ratio === 'Auto' && sourceImage) {
                                try {
                                    // 获取输入图片的尺寸
                                    const sourceDims = await getImageDimensions(sourceImage);
                                    const sourceW = sourceDims.w;
                                    const sourceH = sourceDims.h;
                                    
                                    // 计算宽高比（简化到常见比例）
                                    const calculateRatio = (w, h) => {
                                        const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
                                        const divisor = gcd(w, h);
                                        const ratioW = w / divisor;
                                        const ratioH = h / divisor;
                                        
                                        // 映射到常见比例
                                        if (ratioW === 1 && ratioH === 1) return '1:1';
                                        if (ratioW === 4 && ratioH === 3) return '4:3';
                                        if (ratioW === 3 && ratioH === 4) return '3:4';
                                        if (ratioW === 16 && ratioH === 9) return '16:9';
                                        if (ratioW === 9 && ratioH === 16) return '9:16';
                                        if (ratioW === 3 && ratioH === 2) return '3:2';
                                        if (ratioW === 2 && ratioH === 3) return '2:3';
                                        if (ratioW === 21 && ratioH === 9) return '21:9';
                                        // 如果无法匹配，返回最接近的常见比例
                                        const aspectRatio = w / h;
                                        if (Math.abs(aspectRatio - 1) < 0.1) return '1:1';
                                        if (Math.abs(aspectRatio - 4/3) < 0.1) return '4:3';
                                        if (Math.abs(aspectRatio - 3/4) < 0.1) return '3:4';
                                        if (Math.abs(aspectRatio - 16/9) < 0.1) return '16:9';
                                        if (Math.abs(aspectRatio - 9/16) < 0.1) return '9:16';
                                        // 默认返回计算出的比例
                                        return `${ratioW}:${ratioH}`;
                                    };
                                    
                                    jimengRatio = calculateRatio(sourceW, sourceH);
                                    console.log(`[即梦API] 图生图Auto尺寸: 输入图片 ${sourceW}x${sourceH}, 计算比例 ${jimengRatio}`);
                                    
                                    // 处理分辨率
                                    if (resolution === 'Auto') {
                                        // Auto时，使用输入图片的实际尺寸，不进行放大
                                        // 但需要转换为jimeng API支持的分辨率格式
                                        // 根据输入图片的长边确定分辨率
                                        const maxSide = Math.max(sourceW, sourceH);
                                        if (maxSide <= 1024) {
                                            jimengResolution = '1k';
                                        } else if (maxSide <= 2048) {
                                            jimengResolution = '2k';
                                        } else {
                                            jimengResolution = '4k';
                                        }
                                        console.log(`[即梦API] 图生图Auto分辨率: 输入图片最大边 ${maxSide}, 使用分辨率 ${jimengResolution}`);
                                    } else {
                                        // 2K或4K时，在输入图片尺寸基础上进行放大
                                        if (resolution === '1K') jimengResolution = '1k';
                                        else if (resolution === '2K') jimengResolution = '2k';
                                        else if (resolution === '4K') jimengResolution = '4k';
                                        
                                        // 计算放大后的尺寸（保持宽高比）
                                        const longSideTarget = resolution === '4K' ? 4096 : resolution === '2K' ? 2048 : 1024;
                                        const maxSide = Math.max(sourceW, sourceH);
                                        const scale = longSideTarget / maxSide;
                                        const scaledW = Math.round((sourceW * scale) / 16) * 16;
                                        const scaledH = Math.round((sourceH * scale) / 16) * 16;
                                        
                                        console.log(`[即梦API] 图生图${resolution}放大: ${sourceW}x${sourceH} -> ${scaledW}x${scaledH}, 比例 ${jimengRatio}, 分辨率 ${jimengResolution}`);
                                    }
                                } catch (e) {
                                    console.error('[即梦API] 获取输入图片尺寸失败，使用默认值:', e);
                                    // 如果获取尺寸失败，使用默认值
                                    jimengRatio = '1:1';
                                    if (resolution === '1K') jimengResolution = '1k';
                                    else if (resolution === '2K') jimengResolution = '2k';
                                    else if (resolution === '4K') jimengResolution = '4k';
                                }
                            } else {
                                // ratio不是Auto，使用用户选择的值
                                jimengRatio = ratio;
                                
                                // 转换分辨率格式
                                if (resolution === '1K') jimengResolution = '1k';
                                else if (resolution === '2K') jimengResolution = '2k';
                                else if (resolution === '4K') jimengResolution = '4k';
                            }
                            
                            // 即梦图生图：参考测试文件格式，使用JSON格式发送Base64图片数组
                            // 将所有图片（包括URL）都转换为Base64字符串，使用JSON格式发送
                            const imagePromises = connectedImages.map(async (imgUrl, index) => {
                                let base64String;
                                
                                if (imgUrl.startsWith('http://') || imgUrl.startsWith('https://')) {
                                    // HTTP URL，下载并转换为Base64
                                    try {
                                        console.log(`[即梦API] 正在下载URL图片 [${index + 1}/${connectedImages.length}]:`, imgUrl);
                                        const response = await fetch(imgUrl);
                                        if (!response.ok) {
                                            throw new Error(`下载图片失败: ${response.status} ${response.statusText}`);
                                        }
                                        
                                        const blob = await response.blob();
                                        // 转换为Base64
                                        base64String = await new Promise((resolve, reject) => {
                                            const reader = new FileReader();
                                            reader.onloadend = () => {
                                                // 获取完整的data URL，然后提取base64部分
                                                const dataUrl = reader.result;
                                                resolve(dataUrl);
                                            };
                                            reader.onerror = reject;
                                            reader.readAsDataURL(blob);
                                        });
                                        
                                        console.log(`[即梦API] URL图片下载并转换为Base64成功 [${index + 1}/${connectedImages.length}]`);
                                        return base64String;
                                    } catch (err) {
                                        console.error(`[即梦API] URL图片处理失败 [${index + 1}/${connectedImages.length}]:`, err);
                                        throw new Error(`无法处理URL图片: ${imgUrl}。错误: ${err.message}`);
                                    }
                                } else if (imgUrl.startsWith('data:')) {
                                    // Data URL，直接使用（已经是Base64格式）
                                    console.log(`[即梦API] Data URL图片 [${index + 1}/${connectedImages.length}]`);
                                    return imgUrl;
                                } else {
                                    // 其他情况，尝试作为URL处理并下载
                                    try {
                                        const response = await fetch(imgUrl);
                                        const blob = await response.blob();
                                        base64String = await new Promise((resolve, reject) => {
                                            const reader = new FileReader();
                                            reader.onloadend = () => resolve(reader.result);
                                            reader.onerror = reject;
                                            reader.readAsDataURL(blob);
                                        });
                                        return base64String;
                                    } catch (err) {
                                        throw new Error(`无法处理图片: ${imgUrl}`);
                                    }
                                }
                            });
                            
                            const base64Images = await Promise.all(imagePromises);
                            
                            const jimengModelName = getJimengModelName();
                            console.log('[即梦API] 图生图请求参数:', { 
                                endpoint, 
                                model: jimengModelName,
                                modelId,
                                configModelName: config?.modelName,
                                promptLength: prompt.trim().length,
                                promptPreview: prompt.trim().substring(0, 50),
                                ratio: jimengRatio,
                                resolution: jimengResolution,
                                imageCount: connectedImages.length,
                                base64ImageCount: base64Images.length,
                                useJsonFormat: true // 使用JSON格式
                            });
                            
                            // 即梦图生图：使用JSON格式发送Base64图片数组（参考测试文件格式）
                            // 根据参考文件，使用application/json格式，images字段为Base64字符串数组
                            useMultipart = false;
                            payload = {
                                model: jimengModelName,
                                prompt: prompt.trim(),
                                images: base64Images, // Base64字符串数组
                                ratio: jimengRatio,
                                resolution: jimengResolution,
                                response_format: 'url'
                            };
                            
                            console.log('[即梦API] JSON格式请求构建完成，准备发送请求');
                            }
                        } else {
                            // 文本生成图片
                            endpoint = `${baseUrl}/v1/images/generations`;
                            
                            // 转换比例格式：Auto -> "1:1" (默认)
                            const jimengRatio = ratio === 'Auto' ? '1:1' : ratio;
                            
                            // 转换分辨率格式：Auto -> "2k" (默认)
                            let jimengResolution = '2k'; // 默认2k
                            if (resolution === '1K') jimengResolution = '1k';
                            else if (resolution === '2K') jimengResolution = '2k';
                            else if (resolution === '4K') jimengResolution = '4k';
                            
                            // 确保prompt不为空
                            if (!prompt || prompt.trim() === '') {
                                throw new Error('提示词不能为空');
                            }
                            
                            const jimengModelName = getJimengModelName();
                            payload = {
                                model: jimengModelName,
                                prompt: prompt.trim(),
                                ratio: jimengRatio,
                                resolution: jimengResolution,
                                response_format: 'url'
                            };
                            
                            console.log('[即梦API] 请求参数:', { 
                                endpoint, 
                                model: payload.model,
                                modelId,
                                configModelName: config?.modelName,
                                ratio: payload.ratio, 
                                resolution: payload.resolution,
                                promptLength: payload.prompt?.length || 0,
                                promptPreview: payload.prompt?.substring(0, 50) || ''
                            });
                        }

                        // 即梦API使用sessionid作为Bearer token
                        // 注意：使用FormData时，不要手动设置Content-Type，让浏览器自动设置（包含boundary）
                        const headers = useMultipart 
                            ? { Authorization: `Bearer ${apiKey}` } 
                            : { Authorization: `Bearer ${apiKey}`, 'Content-Type': 'application/json' };
                        
                        // 确保endpoint是完整的URL
                        // endpoint可能已经是完整URL（包含baseUrl），也可能只是路径
                        let fullUrl;
                        if (endpoint.startsWith('http://') || endpoint.startsWith('https://')) {
                            fullUrl = endpoint;
                        } else {
                            // 如果endpoint只是路径，需要拼接baseUrl
                            const cleanBaseUrl = baseUrl.replace(/\/+$/, '');
                            fullUrl = `${cleanBaseUrl}${endpoint.startsWith('/') ? endpoint : '/' + endpoint}`;
                        }
                        
                        // 检查payload大小（Base64图片可能很大）
                        const requestBody = useMultipart ? payload : JSON.stringify(payload);
                        const bodySize = typeof requestBody === 'string' ? requestBody.length : 'FormData';
                        
                        console.log('[即梦API] 发送请求:', {
                            url: fullUrl,
                            method: 'POST',
                            headers: { ...headers, Authorization: 'Bearer ***' }, // 隐藏敏感信息
                            useMultipart,
                            bodySize: typeof bodySize === 'number' ? `${(bodySize / 1024 / 1024).toFixed(2)}MB` : bodySize,
                            imageCount: payload.images ? payload.images.length : 0,
                            model: payload.model, // 显示实际发送的模型名称
                            modelId, // 显示用户选择的modelId
                            configModelName: config?.modelName // 显示配置中的modelName
                        });
                        
                        let resp;
                        try {
                            resp = await fetch(fullUrl, {
                                method: 'POST',
                                headers: headers,
                                body: requestBody,
                            });
                        } catch (fetchError) {
                            // 根据模型类型显示不同的错误信息
                            const isJimengModel = isJimeng;
                            const isBanana2Model = isNanoBanana2;
                            const logPrefix = isJimengModel ? '[即梦API]' : isBanana2Model ? '[Nano Banana 2]' : '[Image API]';
                            const serviceName = isJimengModel ? '即梦API服务' : isBanana2Model ? 'Nano Banana 2 API服务' : '图像生成服务';
                            
                            console.error(`${logPrefix} Fetch请求失败:`, {
                                error: fetchError,
                                url: fullUrl,
                                baseUrl: baseUrl,
                                endpoint: endpoint
                            });
                            
                            // 提供更详细的错误信息
                            let errorMessage = `网络请求失败：无法连接到${serviceName}`;
                            
                            if (fetchError.message && fetchError.message.includes('Failed to fetch')) {
                                errorMessage += `\n\nURL: ${fullUrl}\n\n请检查：\n1. ${serviceName}是否正在运行 (${baseUrl})\n2. 服务地址配置是否正确\n3. 网络连接是否正常\n4. 是否有防火墙阻止连接`;
                                
                                // 检查是否是CORS问题
                                if (fullUrl.includes('localhost') || fullUrl.includes('127.0.0.1')) {
                                    errorMessage += `\n5. 如果是本地服务，请确认服务正在运行并监听正确端口`;
                                }
                            } else {
                                errorMessage += `\n\n错误详情: ${fetchError.message || fetchError}`;
                            }
                            
                            throw new Error(errorMessage);
                        }
                        const text = await resp.text();
                        
                        // 先尝试解析响应
                        let data;
                        try {
                            data = JSON.parse(text);
                        } catch (e) {
                            throw new Error(`响应解析失败: ${text.substring(0, 100)}`);
                        }
                        
                        // 检查HTTP状态码错误
                        if (!resp.ok) {
                            // 尝试解析错误信息
                            let errorMsg = text || `Image API error: ${resp.status}`;
                            if (data?.error?.message) {
                                errorMsg = data.error.message;
                            } else if (data?.error) {
                                errorMsg = typeof data.error === 'string' ? data.error : JSON.stringify(data.error);
                            } else if (data?.message) {
                                errorMsg = data.message;
                            } else if (data?.code && data?.message) {
                                errorMsg = data.message;
                            }
                            
                            // 检查是否是后端服务模块缺失错误，优化错误信息显示（仅对即梦模型）
                            if (isJimeng && (errorMsg.includes('Cannot find module') || errorMsg.includes('octetstream') || errorMsg.includes('MODULE_NOT_FOUND'))) {
                                // 提取原始错误信息（去掉可能的重复前缀）
                                const originalError = errorMsg.replace(/后端服务错误[：:].*?错误详情[：:]/g, '').trim();
                                errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n错误：${originalError}\n\n🔧 解决方案：\n1. 停止当前的jimeng-api.exe进程\n2. 重新下载最新版本的jimeng-api\n3. 如果使用Docker，请运行：\n   docker pull ghcr.io/iptag/jimeng-api:latest\n   docker run -d --name jimeng-api -p 5100:5100 ghcr.io/iptag/jimeng-api:latest\n4. 如果直接运行exe，请确保所有文件完整`;
                            }
                            
                            throw new Error(errorMsg);
                        }
                        
                        // 检查即梦API的错误码（即梦API使用code字段表示错误）
                        // code: 0或1表示成功，200表示HTTP成功，其他为错误
                        // 注意：即梦API可能返回负数错误码，如-2001, -1000
                        // 但banana2使用OpenAI格式，不使用code字段
                        if (isJimeng && data?.code !== undefined) {
                            // 成功码：0, 1, 200
                            const isSuccess = data.code === 0 || data.code === 1 || data.code === 200;
                            if (!isSuccess) {
                                let errorMsg = data?.message || data?.error || `API错误: code ${data.code}`;
                                
                                // 检查是否是后端服务模块缺失错误，优化错误信息显示
                                if (errorMsg.includes('Cannot find module') || errorMsg.includes('octetstream') || errorMsg.includes('MODULE_NOT_FOUND')) {
                                    // 提取原始错误信息
                                    const originalError = errorMsg.replace(/后端服务错误[：:].*?错误详情[：:]/g, '').trim();
                                    errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n错误：${originalError}\n\n🔧 解决方案：\n1. 停止当前的jimeng-api.exe进程\n2. 重新下载最新版本的jimeng-api\n3. 如果使用Docker，请运行：\n   docker pull ghcr.io/iptag/jimeng-api:latest\n   docker run -d --name jimeng-api -p 5100:5100 ghcr.io/iptag/jimeng-api:latest\n4. 如果直接运行exe，请确保所有文件完整`;
                                } else if (data.code === -1000) {
                                    // 简化-1000错误信息
                                    const originalMsg = errorMsg.replace(/后端服务错误[：:].*?错误详情[：:]/g, '').trim();
                                    if (originalMsg.includes('Cannot find module') || originalMsg.includes('octetstream') || originalMsg.includes('MODULE_NOT_FOUND')) {
                                        errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n错误：${originalMsg}\n\n🔧 解决方案：\n1. 停止当前的jimeng-api.exe进程\n2. 重新下载最新版本的jimeng-api\n3. 如果使用Docker，请运行：\n   docker pull ghcr.io/iptag/jimeng-api:latest`;
                                    } else {
                                        errorMsg = `即梦API服务错误 (错误码: ${data.code})\n\n${originalMsg}`;
                                    }
                                }
                                
                                console.error('[即梦API] 错误响应:', JSON.stringify(data, null, 2));
                                throw new Error(errorMsg);
                            }
                        }
                        
                        // 检查是否是异步模式响应（返回task_id）
                        // 异步模式响应格式可能有多种：
                        // 1. { code, message, data: "task_id" }
                        // 2. { code: 0, data: "task_id" }
                        // 3. { task_id: "...", status: "pending" }
                        // 4. { task_id: "..." } (只有task_id，没有其他字段)
                        if (isNanoBanana2) {
                            let taskIdForPoll = null;
                            
                            // 方式1：data是字符串task_id
                            if (data?.data && typeof data.data === 'string' && (data.code === '0' || data.code === 0 || data.code === '200' || data.code === 200)) {
                                taskIdForPoll = data.data;
                            }
                            // 方式2：直接有task_id字段
                            else if (data?.task_id) {
                                // 如果status是SUCCESS且有data.data，说明是同步任务已完成，不需要轮询
                                if (data.status === 'SUCCESS' && data?.data?.data && Array.isArray(data.data.data) && data.data.data.length > 0) {
                                    // 这是同步任务已完成的情况，继续下面的同步处理逻辑
                                    console.log('[Nano Banana 2] 检测到同步任务已完成，直接处理响应');
                                } else {
                                    // 其他情况都视为异步任务，需要轮询
                                    taskIdForPoll = data.task_id;
                                }
                            }
                            
                            if (taskIdForPoll) {
                                // 异步模式：获取task_id并启动轮询
                                console.log('[Nano Banana 2] 异步模式：收到task_id:', taskIdForPoll, '开始轮询');
                                
                                // 更新历史记录状态
                                setHistory((prev) => prev.map((hItem) => 
                                    hItem.id === taskId 
                                        ? { ...hItem, status: 'generating', progress: 10, remoteTaskId: taskIdForPoll } 
                                        : hItem
                                ));
                                
                                // 获取sourceNodeId用于后续更新预览窗口
                                const historyItem = historyMap.get(taskId);
                                const sourceNodeId = historyItem?.sourceNodeId;
                                
                                // 启动轮询（banana模型使用800秒超时）
                                pollImageTask(taskId, taskIdForPoll, baseUrl, apiKey, w, h, sourceNodeId, 0, true);
                                return;
                            }
                        }
                        
                        // 处理响应数据：即梦API和banana2使用不同的响应格式（同步模式）
                        let imageData = [];
                        let imageUrls = [];
                        
                        if (isJimeng) {
                            // 即梦API响应格式：{ "created": ..., "data": [{ "url": "..." }, ...] }
                            // 4.1模型可能返回4张图片，3.1模型返回1张
                            console.log('[即梦API] 响应数据:', data);
                            imageData = data?.data || [];
                            if (!imageData || imageData.length === 0) {
                                console.error('[即梦API] 响应数据:', data);
                                throw new Error('No Image URL found in response');
                            }
                            imageUrls = imageData.map(item => item?.url).filter(Boolean);
                            if (imageUrls.length === 0) {
                                console.error('[即梦API] 响应数据:', data);
                                throw new Error('No Image URL found in response');
                            }
                            console.log('[即梦API] 获取到图片数量:', imageUrls.length, 'URLs:', imageUrls);
                        } else if (isNanoBanana2) {
                            // Nano Banana 2 可能使用多种响应格式：
                            // 1. 标准OpenAI格式：{ "created": ..., "data": [{ "url": "..." }] }
                            // 2. 嵌套格式：{ "status": "SUCCESS", "data": { "data": [{ "url": "..." }] } }
                            // 3. 同步任务格式：{ "task_id": "...", "status": "SUCCESS", "data": { "data": [{ "url": "..." }] } }
                            console.log('[Nano Banana 2] 响应数据:', data);
                            
                            // 检查是否有错误
                            if (data?.error) {
                                const errorMsg = data.error.message || data.error || 'Unknown error';
                                console.error('[Nano Banana 2] 错误响应:', JSON.stringify(data, null, 2));
                                throw new Error(`Nano Banana 2 API错误: ${errorMsg}`);
                            }
                            
                            // 检查是否是同步任务响应（包含task_id和status）
                            if (data?.task_id && data?.status === 'SUCCESS' && data?.data?.data) {
                                // 同步任务格式：data.data 是图片数组
                                imageData = data.data.data || [];
                                console.log('[Nano Banana 2] 检测到同步任务响应格式，从 data.data 提取图片');
                            } else if (data?.data?.data && Array.isArray(data.data.data)) {
                                // 嵌套格式：data.data 是图片数组
                                imageData = data.data.data || [];
                                console.log('[Nano Banana 2] 检测到嵌套响应格式，从 data.data 提取图片');
                            } else if (data?.data && Array.isArray(data.data)) {
                                // 标准OpenAI格式：data 是图片数组
                                imageData = data.data || [];
                                console.log('[Nano Banana 2] 检测到标准OpenAI格式，从 data 提取图片');
                            } else {
                                imageData = [];
                            }
                            
                            if (!imageData || imageData.length === 0) {
                                console.error('[Nano Banana 2] 响应数据:', JSON.stringify(data, null, 2));
                                throw new Error('No Image URL found in response');
                            }
                            
                            // 提取图片URL，支持多种字段名
                            imageUrls = imageData.map(item => {
                                if (typeof item === 'string') return item;
                                return item?.url || item?.image_url || item?.imageUrl || '';
                            }).filter(Boolean);
                            
                            if (imageUrls.length === 0) {
                                console.error('[Nano Banana 2] 响应数据:', JSON.stringify(data, null, 2));
                                throw new Error('No Image URL found in response');
                            }
                            console.log('[Nano Banana 2] 获取到图片数量:', imageUrls.length, 'URLs:', imageUrls);
                        } else {
                            // 其他模型（OpenAI格式）
                            console.log('[Image API] 响应数据:', data);
                            
                            // 检查是否有错误
                            if (data?.error) {
                                const errorMsg = data.error.message || data.error || 'Unknown error';
                                console.error('[Image API] 错误响应:', JSON.stringify(data, null, 2));
                                throw new Error(`Image API错误: ${errorMsg}`);
                            }
                            
                            imageData = data?.data || [];
                            if (!imageData || imageData.length === 0) {
                                console.error('[Image API] 响应数据:', data);
                                throw new Error('No Image URL found in response');
                            }
                            imageUrls = imageData.map(item => item?.url).filter(Boolean);
                            if (imageUrls.length === 0) {
                                console.error('[Image API] 响应数据:', data);
                                throw new Error('No Image URL found in response');
                            }
                            console.log('[Image API] 获取到图片数量:', imageUrls.length, 'URLs:', imageUrls);
                        }
                        
                        // 对于即梦模型，使用第一张图片作为主图片，但保存所有图片
                        const primaryUrl = imageUrls[0];
                        const allUrls = imageUrls.length > 1 ? imageUrls : [primaryUrl];

                        const endTime = Date.now();
                        // 在更新 history 之前，先获取 sourceNodeId
                        const historyItem = historyMap.get(taskId);
                        const sourceNodeId = historyItem?.sourceNodeId;
                        const durationMs = endTime - (historyItem?.startTime || endTime);
                        
                        // 使用 setHistory 的回调来确保获取最新的 historyItem
                        setHistory((prev) => {
                            const updated = prev.map((hItem) => {
                                if (hItem.id === taskId) {
                                    // 获取正确的模型显示名称（确保与发送给后端的模型一致）
                                    const getModelDisplayName = () => {
                                        // 如果是jimeng模型，根据modelId确定正确的provider名称
                                        if (modelId.includes('jimeng-4.5')) return 'Jimeng 4.5';
                                        if (modelId.includes('jimeng-4.1')) return 'Jimeng 4.1';
                                        if (modelId.includes('jimeng-3.1')) return 'Jimeng 3.1';
                                        // 其他模型保持原有的modelName
                                        return hItem.modelName || (config?.provider || modelId);
                                    };
                                    
                                    // 如果是即梦模型且有多张图片，保存所有URL
                                    const updatedItem = {
                                        ...hItem, 
                                        status: 'completed', 
                                        progress: 100, 
                                        url: primaryUrl, 
                                        width: w, 
                                        height: h, 
                                        durationMs,
                                        modelName: isJimeng ? getModelDisplayName() : hItem.modelName // 确保jimeng模型的modelName正确
                                    };
                                    
                                    // 如果是即梦模型，保存所有图片URL（使用mjImages字段以复用显示逻辑）
                                    // 4.1模型返回4张，3.1模型返回1张，但都保存到mjImages中
                                    if (isJimeng) {
                                        if (imageUrls.length > 1) {
                                            updatedItem.mjImages = imageUrls; // 使用mjImages字段，复用Midjourney的显示逻辑
                                            updatedItem.selectedMjImageIndex = 0; // 默认选中第一张
                                        } else if (imageUrls.length === 1) {
                                            // 单张图片也保存，方便统一处理
                                            updatedItem.mjImages = imageUrls;
                                            updatedItem.selectedMjImageIndex = 0;
                                        }
                                    }
                                    
                                    return updatedItem;
                                }
                                return hItem;
                            });
                            
                            // 在状态更新后，立即更新预览窗口
                            const updatedItem = updated.find(h => h.id === taskId);
                            if (updatedItem?.sourceNodeId) {
                                setTimeout(() => {
                                    console.log('[Tapnow] 普通图片生成: 准备更新预览窗口', { taskId, url: primaryUrl, sourceNodeId: updatedItem.sourceNodeId, mjImages: updatedItem.mjImages });
                                    // 如果是即梦模型且有多张图片，传递mjImages数组
                                    updatePreviewFromTask(taskId, primaryUrl, 'image', updatedItem.sourceNodeId, updatedItem.mjImages || null);
                                }, 0);
                            } else {
                                console.warn('[Tapnow] 普通图片生成: 未找到 sourceNodeId', { taskId, updatedItem });
                            }
                            return updated;
                        });
                        return;
                    }

                    if (type === 'video') {
                        // Veo 3.x 图生视频：按 /v2/videos/generations 规范发送 JSON，使用 images 数组而不是 input_image
                        if (modelId.includes('veo')) {
                            const endpoint = `${baseUrl}/v2/videos/generations`;

                            // 根据文档：images 支持 url 或 base64
                            // 对于Veo接口，如果图片过大，自动缩放到合理尺寸（1920x1080等）
                            let images = [];
                            if (connectedImages && connectedImages.length > 0) {
                                // 处理多张图片：先缩放，再转换为data URL
                                images = await Promise.all(connectedImages
                                    .filter(img => img && typeof img === 'string' && img.trim().length > 0)
                                    .map(async (img) => {
                                        const trimmedImg = img.trim();
                                        
                                        // 如果是 http/https URL，先检查尺寸，如果太大就缩放
                                        if (trimmedImg.startsWith('http://') || trimmedImg.startsWith('https://')) {
                                            console.log('Veo: Processing HTTP URL for image');
                                            // 对于URL，先尝试获取尺寸，如果太大就缩放
                                            try {
                                                const dims = await getImageDimensions(trimmedImg);
                                                if (dims.w > 1920 || dims.h > 1920) {
                                                    console.log(`Veo: 图片尺寸 ${dims.w}x${dims.h} 过大，需要缩放`);
                                                    const resized = await resizeImageForVeo(trimmedImg, 1920, 1920);
                                                    return resized;
                                                }
                                                // 尺寸合适，直接使用URL
                                                return trimmedImg;
                                            } catch (e) {
                                                console.warn('Veo: 无法获取图片尺寸，尝试直接使用URL', e);
                                                return trimmedImg;
                                            }
                                        }
                                        
                                        // 对于 data URL、blob URL 或其他格式，统一缩放处理
                                        console.log('Veo: Processing image (data/blob/other format)');
                                        try {
                                            // 先获取尺寸
                                            const dims = await getImageDimensions(trimmedImg);
                                            if (dims.w > 1920 || dims.h > 1920) {
                                                console.log(`Veo: 图片尺寸 ${dims.w}x${dims.h} 过大，需要缩放`);
                                                const resized = await resizeImageForVeo(trimmedImg, 1920, 1920);
                                                return resized;
                                            }
                                            // 尺寸合适，转换为data URL格式
                                            if (trimmedImg.startsWith('data:')) {
                                                return trimmedImg;
                                            } else if (trimmedImg.startsWith('blob:')) {
                                                const base64 = await getBase64FromUrl(trimmedImg);
                                                return `data:image/png;base64,${base64}`;
                                            } else if (trimmedImg.length > 100 && !trimmedImg.includes('://') && !trimmedImg.startsWith('data:')) {
                                                return `data:image/png;base64,${trimmedImg}`;
                                            } else {
                                                const base64 = await getBase64FromUrl(trimmedImg);
                                                return `data:image/png;base64,${base64}`;
                                            }
                                        } catch (e) {
                                            console.error('Veo: Failed to process image:', e);
                                            throw new Error(`无法处理图片格式: ${trimmedImg.substring(0, 50)}...`);
                                        }
                                    }));
                            } else if (sourceImage) {
                                // 单张图片处理：先检查尺寸，如果太大就缩放
                                const trimmedSource = sourceImage.trim();
                                
                                try {
                                    // 先获取图片尺寸
                                    const dims = await getImageDimensions(trimmedSource);
                                    console.log(`Veo: 源图片尺寸 ${dims.w}x${dims.h}`);
                                    
                                    // 如果图片过大，先缩放
                                    if (dims.w > 1920 || dims.h > 1920) {
                                        console.log(`Veo: 图片尺寸 ${dims.w}x${dims.h} 过大，缩放中...`);
                                        const resized = await resizeImageForVeo(trimmedSource, 1920, 1920);
                                        images = [resized];
                                    } else {
                                        // 尺寸合适，根据格式处理
                                        if (trimmedSource.startsWith('http://') || trimmedSource.startsWith('https://')) {
                                            console.log('Veo: Using HTTP URL for source image (尺寸合适)');
                                            images = [trimmedSource];
                                        } else if (trimmedSource.startsWith('data:')) {
                                            console.log('Veo: Using data URL for source image (尺寸合适)');
                                            images = [trimmedSource];
                                        } else if (trimmedSource.startsWith('blob:')) {
                                            console.log('Veo: Converting blob URL to base64 for source image');
                                            const base64 = await getBase64FromUrl(trimmedSource);
                                            images = [`data:image/png;base64,${base64}`];
                                        } else {
                                            if (trimmedSource.length > 100 && !trimmedSource.includes('://') && !trimmedSource.startsWith('data:')) {
                                                images = [`data:image/png;base64,${trimmedSource}`];
                                            } else {
                                                const base64 = await getBase64FromUrl(trimmedSource);
                                                images = [`data:image/png;base64,${base64}`];
                                            }
                                        }
                                    }
                                } catch (e) {
                                    console.error('Veo: Failed to process source image:', e);
                                    throw new Error(`无法处理图片格式: ${e.message}`);
                                }
                            }

                            // 构建 Veo 请求 payload
                            // 根据文档，images 是 required 字段，文生视频时传空数组，图生视频时传图片数据
                            // 图生视频时，确保 images 数组不为空
                            if (images.length === 0 && (connectedImages?.length > 0 || sourceImage)) {
                                console.error('Veo: 图片处理失败，images 数组为空', { connectedImages, sourceImage });
                                throw new Error('图片处理失败：无法获取图片数据');
                            }

                            // 验证图片数据格式：过滤掉无效数据，但不阻止请求发送
                            const validImages = images.filter((img, idx) => {
                                if (!img || typeof img !== 'string') {
                                    console.warn(`Veo: 跳过无效图片（索引 ${idx}）: 不是字符串`);
                                    return false;
                                }
                                if (img === 'base64_data' || img.trim() === 'base64_data') {
                                    console.warn(`Veo: 跳过占位符图片（索引 ${idx}）: base64_data`);
                                    return false;
                                }
                                return true;
                            });

                            if (validImages.length === 0 && (connectedImages?.length > 0 || sourceImage)) {
                                console.error('Veo: 所有图片数据都无效', { images, connectedImages, sourceImage });
                                throw new Error('图片数据格式错误：所有图片数据都无效');
                            }

                            // 对于 veo3.1 系列模型，确保 aspect_ratio 格式正确（只支持 '16:9' 和 '9:16'）
                            let aspectRatio = null;
                            if (ratio && ratio !== 'Auto') {
                                // 确保比例格式符合 API 要求
                                if (ratio === '16:9' || ratio === '9:16') {
                                    aspectRatio = ratio;
                                } else {
                                    // 对于其他比例，根据实际宽高计算最接近的比例
                                    const aspectRatioValue = w / h;
                                    if (Math.abs(aspectRatioValue - 16/9) < Math.abs(aspectRatioValue - 9/16)) {
                                        aspectRatio = '16:9';
                                    } else {
                                        aspectRatio = '9:16';
                                    }
                                }
                            }

                            const veoPayload = {
                                model: config?.modelName || 'veo3.1',
                                prompt,
                                enhance_prompt: false,
                                images: validImages.length > 0 ? validImages : [], // 使用验证后的图片数组
                                // 按接口说明：不传 aspect_ratio 时自动根据参考图匹配；只有非 Auto 时才显式传
                                ...(aspectRatio ? { aspect_ratio: aspectRatio } : {})
                            };

                            // 详细调试日志
                            console.log('Veo: 准备发送请求', {
                                endpoint,
                                model: veoPayload.model,
                                prompt: veoPayload.prompt?.substring(0, 50) + '...',
                                imagesCount: veoPayload.images.length,
                                firstImageType: veoPayload.images[0] ? 
                                    (veoPayload.images[0].startsWith('http') ? 'HTTP URL' : 
                                     veoPayload.images[0].startsWith('data:') ? 'Data URL' : 
                                     'Unknown') : 'empty',
                                firstImagePreview: veoPayload.images[0] ? 
                                    (veoPayload.images[0].startsWith('http') ? 
                                        veoPayload.images[0].substring(0, 80) : 
                                        veoPayload.images[0].substring(0, 100)) : 'empty',
                                aspect_ratio: veoPayload.aspect_ratio,
                                payloadSize: JSON.stringify(veoPayload).length
                            });

                            try {
                                console.log('Veo: 开始发送请求到', endpoint);
                                const resp = await fetch(endpoint, {
                                    method: 'POST',
                                    headers: { 
                                        Authorization: `Bearer ${apiKey}`, 
                                        'Content-Type': 'application/json' 
                                    },
                                    body: JSON.stringify(veoPayload)
                                });
                                
                                console.log('Veo: 收到响应', { status: resp.status, statusText: resp.statusText });
                                const text = await resp.text();
                                console.log('Veo: 响应内容', text.substring(0, 500));
                                
                                if (!resp.ok) {
                                    console.error('Veo: 请求失败', { status: resp.status, text });
                                    throw new Error(text || `Veo error: ${resp.status}`);
                                }
                                
                            const data = JSON.parse(text); 
                                console.log('Veo: 解析后的响应数据', data);
                            const jobId = data?.data?.id || data?.id || data?.task_id || data?.data?.task_id; 
                                
                                if (!jobId) {
                                    console.error('Veo: 未找到 JobId', data);
                                    throw new Error('Veo No JobId');
                                }
                                
                                console.log('Veo: 成功获取 JobId', jobId);
                            setHistory(prev => prev.map(h => h.id === taskId ? { ...h, status: 'generating', progress: 10 } : h));
                            pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h);
                            return;
                            } catch (error) {
                                console.error('Veo: 请求发送失败', error);
                                setHistory(prev => prev.map(h => h.id === taskId ? { ...h, status: 'failed', errorMsg: error.message || '请求发送失败' } : h));
                                throw error;
                            }
                        }

                        let endpoint = '';
                        let body;
                        const headers = { Authorization: `Bearer ${apiKey}` };
                        // 统一将时长转为纯数字秒，避免后端期望 int 时收到字符串
                        const durationValueNum = (() => {
                            if (duration === null || duration === undefined) return 8;
                            const cleaned = String(duration).trim().replace(/[^\d]/g, '');
                            const parsed = parseInt(cleaned, 10);
                            return Number.isFinite(parsed) && parsed > 0 ? parsed : 8;
                        })();

                        // --- Grok-3 Video Logic (Pure JSON Strategy to fix Int type error, align spec /v2/videos/generations) ---
                        if (modelId.includes('grok')) {
                            const endpoint = `${baseUrl}/v2/videos/generations`;
                            // 1. 强制转换为整数 (解决 Go 后端类型错误)
                            const durationInt = parseInt(duration, 10);
                            const aspectRatioStr = ratio && ratio !== 'Auto' ? ratio : '3:2'; // 按官方枚举优先 3:2/2:3/1:1
                            const resolutionStr = (resolution && resolution !== 'Auto') ? resolution : '1080P'; // 官方支持 720P/1080P

                            console.log(`[Grok] Starting generation (JSON Mode). Duration: ${durationInt || 'N/A'} (type: ${typeof durationInt}), ratio: ${aspectRatioStr}, resolution: ${resolutionStr}`);

                            // 2. 准备基础 Payload
                            const payload = {
                                model: config?.modelName || 'grok-video-3',
                                prompt: prompt,
                                ratio: aspectRatioStr,
                                resolution: resolutionStr
                            };
                            if (Number.isFinite(durationInt) && durationInt > 0) {
                                payload.duration = durationInt;
                            }

                            // 3. 处理图片：转为 Base64 字符串
                            if (sourceImage) {
                                try {
                                    console.log('[Grok] Converting image to Base64...');
                                    let base64Data = '';
                                    
                                    if (sourceImage.startsWith('data:')) {
                                        base64Data = sourceImage; // 已经是 Base64
                                    } else {
                                        // 下载 blob 或 url 并转换
                                        const blob = await getBlobFromUrl(sourceImage);
                                        base64Data = await new Promise((resolve, reject) => {
                                            const reader = new FileReader();
                                            reader.onloadend = () => resolve(reader.result);
                                            reader.onerror = reject;
                                            reader.readAsDataURL(blob);
                                        });
                                    }
                                    
                                    // 将完整的 data URI 放入 images 数组（官方字段）
                                    payload.images = [base64Data]; 
                                } catch (e) {
                                    console.error('Grok Image Conversion Failed:', e);
                                    alert('图片处理失败，请检查图片链接或跨域设置');
                                    return;
                                }
                            }

                            // 4. 发送纯 JSON 请求
                            const resp = await fetch(endpoint, {
                                method: 'POST',
                                headers: { 
                                    'Authorization': `Bearer ${apiKey}`,
                                    'Content-Type': 'application/json' // 必须是 JSON
                                },
                                body: JSON.stringify(payload)
                            });
                            
                            const text = await resp.text();
                            
                            // 5. 错误处理
                            if (!resp.ok) {
                                console.error('[Grok API Error]', text);
                                throw new Error(text || `Grok API error: ${resp.status}`);
                            }
                            
                            // 6. 解析响应
                            let data;
                            try {
                                data = JSON.parse(text);
                            } catch (e) {
                                throw new Error('API 返回了非 JSON 格式数据');
                            }

                            // 兼容多种 ID 返回格式
                            const jobId = data?.data?.id || data?.id || data?.task_id;
                            if (!jobId) {
                                console.error('Grok No Task ID:', data);
                                throw new Error('API 未返回 Task ID');
                            }
                            
                            // 7. 进入轮询 (Grok 兼容 Sora 查询接口)
                            setHistory(prev => prev.map(h => h.id === taskId ? { ...h, status: 'generating', progress: 10, remoteTaskId: jobId } : h));
                            pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId);
                            
                            return; // 阻断后续代码执行
                        }

                        // Generic Video Logic (Sora/Kling/etc) - Force Multipart for Image Input with correct field names
                        if (sourceImage) {
                             const formData = new FormData();
                             const blob = await getBlobFromUrl(sourceImage);
                             
                             if (modelId.includes('sora')) {
                                 endpoint = `${baseUrl}/v1/videos`;
                                 // 发送前移除大括号：将 @{username} 转换为 @username
                                 let finalPrompt = prompt.replace(/@\{([^\}]+)\}/g, (match, username) => {
                                     return `@${username}`;
                                 });
                                 console.log('[Sora 2] Sending prompt with character references:', finalPrompt);
                                 formData.append('model', config?.modelName || 'sora-2');
                                 formData.append('prompt', finalPrompt);
                                 formData.append('seconds', duration);
                                 formData.append('size', sizeStr);
                                 // Sora 2 HD 模式支持
                                 if (modelId === 'sora-2' && (options.isHD || node?.settings?.isHD)) {
                                     formData.append('quality', 'hd');
                                 }
                                 // Sora sometimes uses input_reference or image, append both for safety
                                 formData.append('input_reference', blob, 'ref.png'); 
                                 formData.append('image', blob, 'ref.png');
                            } else if (modelId.includes('jimeng')) {
                                 endpoint = `${baseUrl}/jimeng/submit/videos`;
                                 formData.append('prompt', prompt);
                                 formData.append('duration', parseInt(duration));
                                 formData.append('aspect_ratio', ratio);
                                 formData.append('image', blob, 'input.png'); 
                            } else if (modelId.includes('grok')) {
                                endpoint = `${baseUrl}/v1/videos`;
                                formData.append('model', config?.modelName || 'grok-video-3');
                                formData.append('prompt', prompt);
                                formData.append('aspect_ratio', ratio);
                                formData.append('duration', durationValueNum);
                                formData.append('image', blob, 'input.png');
                             } else {
                                 endpoint = `${baseUrl}/v1/videos`;
                                 formData.append('model', config?.modelName);
                                 formData.append('prompt', prompt);
                                 formData.append('image', blob, 'input.png');
                                 formData.append('size', sizeStr); // Ensure size is passed for generic
                             }
                             body = formData;
                        } else {
                             headers['Content-Type'] = 'application/json';
                             if (modelId.includes('sora')) {
                                 delete headers['Content-Type'];
                                 endpoint = `${baseUrl}/v1/videos`;
                                 const formData = new FormData();
                                 // 发送前移除大括号：将 @{username} 转换为 @username
                                 let finalPrompt = prompt.replace(/@\{([^\}]+)\}/g, (match, username) => {
                                     return `@${username}`;
                                 });
                                 console.log('[Sora 2] Sending prompt with character references:', finalPrompt);
                                 formData.append('model', config?.modelName || 'sora-2');
                                 formData.append('prompt', finalPrompt);
                                 formData.append('seconds', duration);
                                 formData.append('size', sizeStr);
                                 // Sora 2 HD 模式支持
                                 if (modelId === 'sora-2' && (options.isHD || node?.settings?.isHD)) {
                                     formData.append('quality', 'hd');
                                 }
                                 body = formData;
                            } else if (modelId.includes('jimeng')) {
                                 endpoint = `${baseUrl}/jimeng/submit/videos`;
                                 body = JSON.stringify({ prompt, duration: parseInt(duration), aspect_ratio: ratio });
                            } else if (modelId.includes('grok')) {
                                endpoint = `${baseUrl}/v1/videos`;
                                body = JSON.stringify({
                                    model: config?.modelName || 'grok-video-3',
                                    prompt,
                                    aspect_ratio: ratio,
                                    duration: durationValueNum
                                });
                             } else {
                                 endpoint = `${baseUrl}/minimax/v1/video_generation`;
                                 body = JSON.stringify({ model: config?.modelName, prompt, resolution: sizeStr });
                             }
                        }

                        const resp = await fetch(endpoint, { method: 'POST', headers: body instanceof FormData ? { Authorization: headers.Authorization } : headers, body });
                        const text = await resp.text();
                        if (!resp.ok) throw new Error(text || `Video API error: ${resp.status}`);
                        const data = JSON.parse(text);
                        
                        const immediateUrl = data?.video_url || data?.url || data?.data?.video_url;
                        if (immediateUrl) { 
                            const endTime = Date.now();
                            // 在更新 history 之前，先获取 sourceNodeId
                            const historyItem = historyMap.get(taskId);
                            const sourceNodeId = historyItem?.sourceNodeId;
                            const durationMs = endTime - (historyItem?.startTime || endTime);
                            // 使用 setHistory 的回调来确保获取最新的 historyItem
                            setHistory((prev) => {
                                const updated = prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'completed', progress: 100, url: immediateUrl, width: w, height: h, durationMs } : hItem);
                                // 检查是否是分镜表的任务，如果是则回填到分镜表
                                const storyboardTask = storyboardTaskMapRef.current.get(taskId);
                                if (storyboardTask) {
                                    console.log('[分镜表] 视频立即返回，回填视频:', { taskId, nodeId: storyboardTask.nodeId, shotId: storyboardTask.shotId, immediateUrl });
                                    updateShot(storyboardTask.nodeId, storyboardTask.shotId, { 
                                        video_url: immediateUrl,
                                        status: 'done'
                                    });
                                    // 清理任务映射
                                    storyboardTaskMapRef.current.delete(taskId);
                                } else {
                                    // 更新预览窗口（非分镜表任务）
                                const updatedItem = updated.find(h => h.id === taskId);
                                if (updatedItem?.sourceNodeId) {
                                    setTimeout(() => {
                                        console.log('[Tapnow] 视频立即返回: 准备更新预览窗口', { taskId, immediateUrl, sourceNodeId: updatedItem.sourceNodeId });
                                        updatePreviewFromTask(taskId, immediateUrl, 'video', updatedItem.sourceNodeId);
                                    }, 0);
                                } else {
                                    console.warn('[Tapnow] 视频立即返回: 未找到 sourceNodeId', { taskId, updatedItem });
                                    }
                                }
                                return updated;
                            });
                            return; 
                        }
                        
                        const jobId = data?.data?.id || data?.id || data?.task_id || data?.data?.task_id;
                        if (!jobId) throw new Error('No Task/Job ID returned');

                        setHistory(prev => prev.map(h => h.id === taskId ? { ...h, status: 'generating', progress: 10, remoteTaskId: jobId } : h));
                        if (modelId.includes('veo')) pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h);
                        else pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId);
                    }
                } catch (err) {
                    console.error('[CONSOLE_ERROR]', err);
                    // 尝试解析错误信息，提取更友好的错误消息
                    let errorMsg = err?.message || '生成失败';
                    try {
                        // 如果错误信息是 JSON 字符串，尝试解析
                        if (typeof errorMsg === 'string' && errorMsg.trim().startsWith('{')) {
                            const errorData = JSON.parse(errorMsg);
                            if (errorData?.error?.message) {
                                errorMsg = errorData.error.message;
                            } else if (errorData?.error) {
                                errorMsg = typeof errorData.error === 'string' ? errorData.error : JSON.stringify(errorData.error);
                            } else if (errorData?.message) {
                                errorMsg = errorData.message;
                            }
                        }
                        
                        // 检查是否是后端服务模块缺失错误，优化错误信息显示
                        if (errorMsg.includes('Cannot find module') || errorMsg.includes('octetstream') || errorMsg.includes('MODULE_NOT_FOUND')) {
                            // 检查是否已经包含优化后的错误信息，避免重复
                            if (!errorMsg.includes('即梦API代理服务缺少必要模块') && !errorMsg.includes('❌')) {
                                // 提取原始错误信息（去掉可能的重复前缀）
                                const originalError = errorMsg.replace(/后端服务错误[：:].*?错误详情[：:]/g, '').trim();
                                errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n错误：${originalError}\n\n🔧 解决方案：\n1. 停止jimeng-api.exe并重新下载最新版本\n2. 或使用Docker：docker pull ghcr.io/iptag/jimeng-api:latest`;
                            } else if (!errorMsg.includes('🔧')) {
                                // 如果已经有基本错误信息但没有解决方案，添加解决方案
                                errorMsg = errorMsg + '\n\n🔧 解决方案：\n1. 停止jimeng-api.exe并重新下载最新版本\n2. 或使用Docker：docker pull ghcr.io/iptag/jimeng-api:latest';
                            }
                        }
                    } catch (e) {
                        // 如果解析失败，使用原始错误信息
                        // 但仍然检查是否是模块缺失错误
                        if (errorMsg.includes('Cannot find module') || errorMsg.includes('octetstream') || errorMsg.includes('MODULE_NOT_FOUND')) {
                            // 检查是否已经包含优化后的错误信息
                            if (!errorMsg.includes('即梦API代理服务缺少必要模块') && !errorMsg.includes('❌')) {
                                errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n🔧 解决方案：\n1. 停止jimeng-api.exe并重新下载最新版本\n2. 或使用Docker：docker pull ghcr.io/iptag/jimeng-api:latest`;
                            }
                        }
                    }
                    setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg } : hItem));
                }
            };

            const handleToggleTheme = () => {
                setTheme((prev) => (prev === 'dark' ? 'light' : 'dark'));
            };

            // 功能1：批量下载选中的图片/视频节点
            const handleBatchDownload = async () => {
                // 使用ref获取最新的状态，避免闭包问题
                const currentNodes = nodesRef.current;
                const currentSelectedId = selectedNodeIdRef.current;
                const currentSelectedIds = selectedNodeIdsRef.current;
                
                const selectedNodes = currentNodes.filter(node => 
                    (currentSelectedId === node.id || (currentSelectedIds && currentSelectedIds.has(node.id))) && 
                    (node.type === 'input-image' || node.type === 'video-input' || node.type === 'preview') && 
                    node.content
                );

                if (selectedNodes.length === 0) {
                    alert('请先选择要下载的图片或视频节点');
                    return;
                }

                for (const node of selectedNodes) {
                    try {
                        const url = node.content;
                        // 检查URL是否有效
                        if (!url || (typeof url !== 'string' && !url.startsWith('data:'))) {
                            console.warn(`节点 ${node.id} 的内容URL无效:`, url);
                            continue;
                        }
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        const blob = await response.blob();
                        const blobUrl = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = blobUrl;
                        
                        // 判断文件扩展名：对于预览窗口，根据previewType判断；对于其他节点，根据URL或节点类型判断
                        let extension = '.png';
                        if (node.type === 'preview') {
                            // 预览窗口：根据previewType判断
                            if (node.previewType === 'video') {
                                extension = '.mp4';
                            } else {
                                extension = isVideoUrl(url) ? '.mp4' : '.png';
                            }
                        } else if (node.type === 'video-input') {
                            extension = '.mp4';
                        } else {
                            extension = isVideoUrl(url) ? '.mp4' : '.png';
                        }
                        
                        const filename = `${node.id}${extension}`;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(blobUrl);
                        // 添加小延迟避免浏览器阻止多个下载
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (error) {
                        console.error(`下载节点 ${node.id} 失败:`, error);
                        // 不中断其他节点的下载，继续处理下一个
                    }
                }
            };

            // 获取东八区时间戳（用于项目数据）
            const getCSTTimestamp = () => {
                const now = new Date();
                // 获取UTC时间并加上8小时（东八区）
                const cstTime = new Date(now.getTime() + (8 * 60 * 60 * 1000));
                return cstTime.toISOString();
            };

            // 获取东八区时间戳（用于文件名）
            const getCSTFilenameTimestamp = () => {
                const now = new Date();
                const cstTime = new Date(now.getTime() + (8 * 60 * 60 * 1000));
                const year = cstTime.getUTCFullYear();
                const month = String(cstTime.getUTCMonth() + 1).padStart(2, '0');
                const day = String(cstTime.getUTCDate()).padStart(2, '0');
                const hours = String(cstTime.getUTCHours()).padStart(2, '0');
                const minutes = String(cstTime.getUTCMinutes()).padStart(2, '0');
                const seconds = String(cstTime.getUTCSeconds()).padStart(2, '0');
                return `${year}-${month}-${day}T${hours}-${minutes}-${seconds}`;
            };

            // 功能5：保存项目到JSON文件（流式写入，支持超大文件）
            const handleSaveProject = async () => {
                try {
                    // 兼容性检查：优先使用 File System Access API
                    if (!window.showSaveFilePicker) {
                        // 降级到旧的 Blob 下载方式（仅适用于小文件）
                        const shouldProceed = confirm('您的浏览器不支持流式保存大文件。\n\n如果项目包含大量图片/视频（>500MB），建议使用 Chrome 或 Edge 浏览器导出。\n\n是否继续使用传统方式保存？（可能导致内存溢出）');
                        if (!shouldProceed) return;
                        
                        // 执行旧的保存逻辑（仅作为降级方案）
                        const replacer = (key, value) => {
                            if (value === undefined) return null;
                            return value;
                        };
                        const nodesToSave = JSON.parse(JSON.stringify(nodes, replacer));
                        const convertBlobUrlsToDataUrls = async (obj) => {
                            if (obj === null || obj === undefined) return obj;
                            if (typeof obj === 'string' && obj.startsWith('blob:')) {
                                try {
                                    const blob = await getBlobFromUrl(obj);
                                    const dataUrl = await blobToDataURL(blob);
                                    return dataUrl;
                                } catch (error) {
                                    console.error('转换 Blob URL 失败:', error);
                                    return obj;
                                }
                            }
                            if (Array.isArray(obj)) {
                                return await Promise.all(obj.map(item => convertBlobUrlsToDataUrls(item)));
                            }
                            if (typeof obj === 'object') {
                                const converted = {};
                                for (const key in obj) {
                                    if (obj.hasOwnProperty(key)) {
                                        converted[key] = await convertBlobUrlsToDataUrls(obj[key]);
                                    }
                                }
                                return converted;
                            }
                            return obj;
                        };
                        const nodesWithDataUrls = await convertBlobUrlsToDataUrls(nodesToSave);
                        const characterLibraryToSave = JSON.parse(JSON.stringify(characterLibrary, replacer));
                        const characterLibraryWithDataUrls = await convertBlobUrlsToDataUrls(characterLibraryToSave);
                        const projectData = {
                            version: '2.5.7',
                            projectName,
                            nodes: nodesWithDataUrls,
                            connections,
                            view,
                            history,
                            chatSessions,
                            characterLibrary: characterLibraryWithDataUrls,
                            timestamp: getCSTTimestamp()
                        };
                        const jsonStr = JSON.stringify(projectData, replacer, 2);
                        const blob = new Blob([jsonStr], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const timestamp = getCSTFilenameTimestamp();
                        const filename = `${projectName || '未命名项目'}_${timestamp}.json`;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        alert('项目保存成功！');
                        return;
                    }

                    // 使用 File System Access API 流式写入
                    const timestamp = getCSTFilenameTimestamp();
                    const handle = await window.showSaveFilePicker({
                        suggestedName: `${projectName || '未命名项目'}_${timestamp}.json`,
                        types: [{ description: 'JSON File', accept: { 'application/json': ['.json'] } }],
                    });
                    const writable = await handle.createWritable();

                    // replacer 函数：将 undefined 转换为 null
                    const replacer = (key, value) => {
                        if (value === undefined) return null;
                        return value;
                    };

                    // 辅助函数：转换单个节点的 Blob URL 字段
                    const convertNodeBlobUrls = async (node) => {
                        const nodeCopy = { ...node };
                        
                        // 转换 content
                        if (nodeCopy.content && typeof nodeCopy.content === 'string' && nodeCopy.content.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(nodeCopy.content);
                                const mime = isVideoUrl(nodeCopy.content) ? 'video/mp4' : 'image/png';
                                nodeCopy.content = `data:${mime};base64,${b64}`;
                            } catch (e) {
                                console.error('转换节点 content 失败:', e);
                            }
                        }
                        
                        // 转换 maskContent
                        if (nodeCopy.maskContent && typeof nodeCopy.maskContent === 'string' && nodeCopy.maskContent.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(nodeCopy.maskContent);
                                nodeCopy.maskContent = `data:image/png;base64,${b64}`;
                            } catch (e) {
                                console.error('转换节点 maskContent 失败:', e);
                            }
                        }
                        
                        // 转换 selectedKeyframes
                        if (Array.isArray(nodeCopy.selectedKeyframes)) {
                            for (let i = 0; i < nodeCopy.selectedKeyframes.length; i++) {
                                const frame = nodeCopy.selectedKeyframes[i];
                                if (frame && frame.url && typeof frame.url === 'string' && frame.url.startsWith('blob:')) {
                                    try {
                                        const b64 = await getBase64FromUrl(frame.url);
                                        frame.url = `data:image/png;base64,${b64}`;
                                    } catch (e) {
                                        console.error('转换关键帧失败:', e);
                                    }
                                }
                            }
                        }
                        
                        // 转换 frames
                        if (Array.isArray(nodeCopy.frames)) {
                            for (let i = 0; i < nodeCopy.frames.length; i++) {
                                const frame = nodeCopy.frames[i];
                                if (frame && frame.url && typeof frame.url === 'string' && frame.url.startsWith('blob:')) {
                                    try {
                                        const b64 = await getBase64FromUrl(frame.url);
                                        frame.url = `data:image/png;base64,${b64}`;
                                    } catch (e) {
                                        console.error('转换帧失败:', e);
                                    }
                                }
                            }
                        }
                        
                        return nodeCopy;
                    };

                    // 辅助函数：转换历史记录项的 Blob URL
                    const convertHistoryItemBlobUrls = async (item) => {
                        const itemCopy = { ...item };
                        
                        // 转换 url
                        if (itemCopy.url && typeof itemCopy.url === 'string' && itemCopy.url.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(itemCopy.url);
                                const mime = itemCopy.type === 'video' ? 'video/mp4' : 'image/png';
                                itemCopy.url = `data:${mime};base64,${b64}`;
                            } catch (e) {
                                console.error('转换历史记录 url 失败:', e);
                            }
                        }
                        
                        // 转换 mjOriginalUrl
                        if (itemCopy.mjOriginalUrl && typeof itemCopy.mjOriginalUrl === 'string' && itemCopy.mjOriginalUrl.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(itemCopy.mjOriginalUrl);
                                itemCopy.mjOriginalUrl = `data:image/png;base64,${b64}`;
                            } catch (e) {
                                console.error('转换 mjOriginalUrl 失败:', e);
                            }
                        }
                        
                        // 转换 mjImages 数组
                        if (Array.isArray(itemCopy.mjImages)) {
                            for (let i = 0; i < itemCopy.mjImages.length; i++) {
                                const imgUrl = itemCopy.mjImages[i];
                                if (imgUrl && typeof imgUrl === 'string' && imgUrl.startsWith('blob:')) {
                                    try {
                                        const b64 = await getBase64FromUrl(imgUrl);
                                        itemCopy.mjImages[i] = `data:image/png;base64,${b64}`;
                                    } catch (e) {
                                        console.error('转换 mjImages 失败:', e);
                                    }
                                }
                            }
                        }
                        
                        return itemCopy;
                    };

                    // 辅助函数：转换角色库项的 Blob URL
                    const convertCharacterBlobUrls = async (character) => {
                        const charCopy = { ...character };
                        
                        // 转换 avatar
                        if (charCopy.avatar && typeof charCopy.avatar === 'string' && charCopy.avatar.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(charCopy.avatar);
                                charCopy.avatar = `data:image/png;base64,${b64}`;
                            } catch (e) {
                                console.error('转换角色 avatar 失败:', e);
                            }
                        }
                        
                        // 转换 profile_picture_url
                        if (charCopy.profile_picture_url && typeof charCopy.profile_picture_url === 'string' && charCopy.profile_picture_url.startsWith('blob:')) {
                            try {
                                const b64 = await getBase64FromUrl(charCopy.profile_picture_url);
                                charCopy.profile_picture_url = `data:image/png;base64,${b64}`;
                            } catch (e) {
                                console.error('转换角色 profile_picture_url 失败:', e);
                            }
                        }
                        
                        return charCopy;
                    };

                    // 1. 写入 JSON 头部
                    await writable.write(`{\n  "version": "2.5.7",\n  "projectName": ${JSON.stringify(projectName || '')},\n  "nodes": [\n`);

                    // 2. 流式写入节点（逐个处理，释放内存）
                    for (let i = 0; i < nodes.length; i++) {
                        const node = nodes[i];
                        const nodeToSave = await convertNodeBlobUrls(node);
                        
                        // 使用 replacer 处理 undefined 值
                        const nodeJson = JSON.stringify(nodeToSave, replacer, 2);
                        // 为每个节点添加缩进（除了第一个）
                        const indentedNodeJson = i === 0 
                            ? nodeJson.split('\n').join('\n    ')
                            : '    ' + nodeJson.split('\n').join('\n    ');
                        
                        await writable.write(indentedNodeJson);
                        if (i < nodes.length - 1) {
                            await writable.write(',\n');
                        } else {
                            await writable.write('\n');
                        }
                        
                        // 注意：每次循环迭代都会创建新的作用域，变量会自动被 GC 回收
                    }

                    // 3. 写入连接和视图
                    await writable.write(`  ],\n  "connections": ${JSON.stringify(connections, replacer, 2)},\n  "view": ${JSON.stringify(view, replacer, 2)},\n  "history": [\n`);

                    // 4. 流式写入历史记录（通常是最大的部分）
                    for (let i = 0; i < history.length; i++) {
                        const item = history[i];
                        const itemToSave = await convertHistoryItemBlobUrls(item);
                        
                        const itemJson = JSON.stringify(itemToSave, replacer, 2);
                        const indentedItemJson = i === 0 
                            ? itemJson.split('\n').join('\n    ')
                            : '    ' + itemJson.split('\n').join('\n    ');
                        
                        await writable.write(indentedItemJson);
                        if (i < history.length - 1) {
                            await writable.write(',\n');
                        } else {
                            await writable.write('\n');
                        }
                        
                        // 注意：每次循环迭代都会创建新的作用域，变量会自动被 GC 回收
                    }

                    // 5. 写入角色库（流式处理）
                    await writable.write(`  ],\n  "chatSessions": ${JSON.stringify(chatSessions, replacer, 2)},\n  "characterLibrary": [\n`);
                    
                    for (let i = 0; i < characterLibrary.length; i++) {
                        const character = characterLibrary[i];
                        const charToSave = await convertCharacterBlobUrls(character);
                        
                        const charJson = JSON.stringify(charToSave, replacer, 2);
                        const indentedCharJson = i === 0 
                            ? charJson.split('\n').join('\n    ')
                            : '    ' + charJson.split('\n').join('\n    ');
                        
                        await writable.write(indentedCharJson);
                        if (i < characterLibrary.length - 1) {
                            await writable.write(',\n');
                        } else {
                            await writable.write('\n');
                        }
                        
                        // 注意：每次循环迭代都会创建新的作用域，变量会自动被 GC 回收
                    }

                    // 6. 写入尾部
                    await writable.write(`  ],\n  "timestamp": ${JSON.stringify(getCSTTimestamp())}\n}`);
                    
                    // 关闭流
                    await writable.close();
                    alert('项目保存成功！');
                } catch (error) {
                    console.error('保存项目失败:', error);
                    if (error.name === 'AbortError') {
                        // 用户取消了保存
                        return;
                    }
                    alert('保存失败: ' + (error.message || '未知错误'));
                }
            };

            // 功能5：从JSON文件加载项目（流式读取，支持超大文件，修复多行JSON解析问题）
            const handleLoadProject = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    // 初始化临时容器
                    let tempNodes = [];
                    let tempHistory = [];
                    let tempConnections = [];
                    let tempChatSessions = [];
                    let tempCharacterLibrary = [];
                    let tempProjectName = '';
                    let tempView = null;
                    
                    let currentSection = null; 
                    let buffer = '';
                    
                    // 新增：对象构建缓冲区
                    let objectBuffer = ''; 
                    let braceCount = 0; // 括号深度计数器
                    let inObject = false; // 是否正在读取一个对象

                    try {
                        const stream = file.stream().pipeThrough(new TextDecoderStream());
                        const reader = stream.getReader();
                        
                        console.log('开始流式读取项目文件...');

                        while (true) {
                            const { value, done } = await reader.read();
                            if (done) break;

                            buffer += value;
                            
                            // 处理 buffer 中的完整行
                            while (true) {
                                const newlineIndex = buffer.indexOf('\n');
                                if (newlineIndex === -1) break; 
                                
                                const line = buffer.substring(0, newlineIndex);
                                buffer = buffer.substring(newlineIndex + 1);
                                
                                const trimmedLine = line.trim();
                                if (!trimmedLine) continue;
                                
                                // --- 1. 状态机：检测大区块开始 ---
                                if (trimmedLine.includes('"nodes": [')) { currentSection = 'nodes'; continue; }
                                if (trimmedLine.includes('"history": [')) { currentSection = 'history'; continue; }
                                if (trimmedLine.includes('"connections": [')) { currentSection = 'connections'; continue; }
                                if (trimmedLine.includes('"chatSessions": [')) { currentSection = 'chatSessions'; continue; }
                                if (trimmedLine.includes('"characterLibrary": [')) { currentSection = 'characterLibrary'; continue; }
                                
                                // --- 2. 状态机：检测大区块结束 ---
                                if ((trimmedLine === '],' || trimmedLine === ']') && braceCount === 0) {
                                    currentSection = null;
                                    objectBuffer = '';
                                    inObject = false;
                                    continue;
                                }

                                // --- 3. 简单字段解析 (不在数组内的字段) ---
                                if (!currentSection) {
                                    if (trimmedLine.startsWith('"projectName":')) {
                                        try {
                                            const match = trimmedLine.match(/"projectName":\s*(.+)/);
                                            if (match) tempProjectName = JSON.parse(match[1].replace(/,$/, ''));
                                        } catch (e) {}
                                    }
                                    if (trimmedLine.startsWith('"view":') && trimmedLine.endsWith('}')) {
                                        try {
                                            const match = trimmedLine.match(/"view":\s*(.+)/);
                                            if(match) tempView = JSON.parse(match[1].replace(/,$/, ''));
                                        } catch(e) {}
                                    }
                                    continue;
                                }

                                // --- 4. 核心修复：多行对象累积解析 ---
                                if (currentSection) {
                                    // 统计这一行里的 { 和 } 数量
                                    for (let char of line) {
                                        if (char === '{') {
                                            braceCount++;
                                            inObject = true;
                                        }
                                        if (char === '}') {
                                            braceCount--;
                                        }
                                    }

                                    // 将当前行加入缓冲区
                                    objectBuffer += line + '\n';

                                    // 如果 braceCount 回归到 0，且处于对象读取状态中，说明一个完整对象结束了
                                    if (inObject && braceCount === 0) {
                                        let jsonStr = objectBuffer.trim();
                                        if (jsonStr.endsWith(',')) jsonStr = jsonStr.slice(0, -1);

                                        try {
                                            const item = JSON.parse(jsonStr);
                                            
                                            if (item && typeof item === 'object') {
                                                if (currentSection === 'nodes' && item.id) {
                                                    if (!item.settings) item.settings = {};
                                                    tempNodes.push(item);
                                                } else if (currentSection === 'history') {
                                                    tempHistory.push(item);
                                                } else if (currentSection === 'connections') {
                                                    tempConnections.push(item);
                                                } else if (currentSection === 'chatSessions') {
                                                    tempChatSessions.push(item);
                                                } else if (currentSection === 'characterLibrary') {
                                                    tempCharacterLibrary.push(item);
                                                }
                                            }
                                        } catch (parseErr) {
                                            console.warn('JSON片段解析失败', parseErr);
                                        }

                                        // 重置缓冲区
                                        objectBuffer = '';
                                        inObject = false;
                                    }
                                }
                            }
                        }
                        
                        console.log(`流式读取完成：${tempNodes.length} 节点, ${tempHistory.length} 历史`);
                        
                        if (tempNodes.length === 0 && tempHistory.length === 0) {
                            alert('读取完成，但未发现有效数据。可能是文件格式不兼容。');
                            return;
                        }

                        // 更新状态
                        if (tempProjectName) setProjectName(tempProjectName);
                        if (tempView) setView(tempView);
                        if (tempConnections.length > 0) setConnections(tempConnections);
                        if (tempChatSessions.length > 0) setChatSessions(tempChatSessions);
                        
                        // --- 后处理：Base64 -> Blob URL 转换 ---
                        if (tempNodes.length > 0) {
                            console.log('正在优化导入的节点图片数据...');
                            const convertToBlob = async (content) => {
                                if (content && typeof content === 'string' && content.startsWith('data:image/')) {
                                    return await base64ToBlobUrl(content);
                                }
                                return content;
                            };

                            const optimizedNodes = await Promise.all(tempNodes.map(async (node) => {
                                const n = { ...node };
                                n.content = await convertToBlob(n.content);
                                n.maskContent = await convertToBlob(n.maskContent);
                                if (n.selectedKeyframes && Array.isArray(n.selectedKeyframes)) {
                                    n.selectedKeyframes = await Promise.all(n.selectedKeyframes.map(async f => ({...f, url: await convertToBlob(f.url)})));
                                }
                                if (n.frames && Array.isArray(n.frames)) {
                                    n.frames = await Promise.all(n.frames.map(async f => ({...f, url: await convertToBlob(f.url)})));
                                }
                                return n;
                            }));
                            setNodes(optimizedNodes);
                            console.log('节点图片数据优化完成');
                        }

                        if (tempHistory.length > 0) {
                            console.log('正在优化导入的历史记录...');
                            const optimizedHistory = await Promise.all(tempHistory.map(async (item) => {
                                const h = { ...item };
                                if (h.url && h.url.startsWith('data:image/')) h.url = await base64ToBlobUrl(h.url);
                                if (h.mjOriginalUrl && h.mjOriginalUrl.startsWith('data:image/')) h.mjOriginalUrl = await base64ToBlobUrl(h.mjOriginalUrl);
                                if (h.mjImages && Array.isArray(h.mjImages)) {
                                    h.mjImages = await Promise.all(h.mjImages.map(async url => 
                                        url && url.startsWith('data:image/') ? await base64ToBlobUrl(url) : url
                                    ));
                                }
                                return h;
                            }));
                            setHistory(optimizedHistory);
                            console.log('历史记录图片数据优化完成');
                        }
                        
                        if (tempCharacterLibrary.length > 0) {
                            console.log('正在优化导入的角色库...');
                            const optimizedCharLib = await Promise.all(tempCharacterLibrary.map(async (char) => {
                                const c = { ...char };
                                if (c.avatar && c.avatar.startsWith('data:image/')) {
                                    c.avatar = await base64ToBlobUrl(c.avatar);
                                }
                                if (c.profile_picture_url && c.profile_picture_url.startsWith('data:image/')) {
                                    c.profile_picture_url = await base64ToBlobUrl(c.profile_picture_url);
                                }
                                return c;
                            }));
                            setCharacterLibrary(optimizedCharLib);
                            console.log('角色库图片数据优化完成');
                        }

                        alert(`项目加载成功！\n${tempNodes.length} 个节点\n${tempHistory.length} 条历史`);

                    } catch (error) {
                        console.error('加载项目失败:', error);
                        alert(`加载失败: ${error.message}`);
                    }
                };
                input.click();
            };

            // --- 节点操作 ---
            const addNode = (type, worldX, worldY, sourceId, initialContent = undefined, initialDimensions = undefined, targetId = undefined, inputType = undefined) => {
                const defaultSize = type === 'gen-video'
                    ? { w: 320, h: 420 }
                    : type === 'gen-image'
                        ? { w: 360, h: 340 }
                        : type === 'video-input'
                            ? { w: 360, h: 420 }
                            : type === 'video-analyze'
                                ? { w: 400, h: 500 }
                                : type === 'storyboard-node'
                                    ? { w: 600, h: 500 }
                                : type === 'image-compare'
                                ? { w: 400, h: 300 }
                                : type === 'preview'
                                    ? { w: 320, h: 260 }
                                    : type === 'text-node'
                                        ? { w: 280, h: 200 }
                                        : { w: 260, h: 260 };
                const newNode = {
                    id: `node-${Date.now()}`,
                    type,
                    x: worldX - defaultSize.w / 2,
                    y: worldY - defaultSize.h / 2,
                    width: defaultSize.w,
                    height: defaultSize.h,
                    content: initialContent, 
                    ...(initialDimensions ? { dimensions: initialDimensions } : {}),
                    settings: type === 'gen-image'
                        ? { model: 'nano-banana', ratio: 'Auto', resolution: 'Auto', prompt: '' }
                        : type === 'gen-video'
                            ? { model: 'sora-2', duration: '5s', ratio: '16:9', videoPrompt: '' }
                            : type === 'video-analyze'
                                ? { model: 'gemini-3-pro', segmentDuration: 3, analysisMode: 'manual', voiceoverResults: [], analysisResults: [] }
                                : type === 'storyboard-node'
                                    ? { projectTitle: '未命名分镜', shots: [] }
                                : type === 'text-node'
                                    ? { text: initialContent || '' }
                                    : {},
                };
                setNodes(prev => [...prev, newNode]);
                // 从输出端口连接到新节点（原有逻辑）
                if (sourceId) {
                    setConnections(prev => [...prev, { id: `conn-${Date.now()}`, from: sourceId, to: newNode.id }]);
                }
                // 从输入端口连接到新节点（反向连接）
                if (targetId) {
                    setConnections(prev => {
                        // 如果连接到特定输入点，先删除该输入点的旧连接
                        if (inputType && inputType !== 'default') {
                            const filtered = prev.filter((c) => 
                                !(c.to === targetId && (c.inputType || 'default') === inputType)
                            );
                            return [...filtered, { 
                                id: `conn-${Date.now()}`, 
                                from: newNode.id, 
                                to: targetId,
                                inputType: inputType !== 'default' ? inputType : undefined
                            }];
                        }
                        return [...prev, { 
                            id: `conn-${Date.now()}`, 
                            from: newNode.id, 
                            to: targetId 
                        }];
                    });
                }
                setContextMenu(prev => ({ ...prev, visible: false }));
                setConnectingSource(null);
                setConnectingTarget(null);
                setConnectingInputType(null);
            };

            const deleteNode = useCallback((id) => {
                setNodes((prev) => prev.filter((n) => n.id !== id));
                setConnections((prev) => prev.filter((c) => c.from !== id && c.to !== id));
                if (selectedNodeId === id) setSelectedNodeId(null);
            }, [selectedNodeId]);

            const updateNodeSettings = useCallback((id, newSettings) => {
                setNodes((prev) => prev.map((n) => n.id === id ? { ...n, settings: { ...n.settings, ...newSettings } } : n));
            }, []);

            // 获取连接的 gen-image 或 gen-video 节点（用于 storyboard-node 节点）
            const getConnectedGenNodes = useCallback((sourceNodeId) => {
                const genNodes = [];
                for (const conn of connections) {
                    if (conn.from === sourceNodeId) {
                        const targetNode = nodesMap.get(conn.to);
                        if (targetNode && (targetNode.type === 'gen-image' || targetNode.type === 'gen-video')) {
                            genNodes.push(targetNode);
                        }
                    }
                }
                return genNodes;
            }, [connections, nodesMap]);

            // 获取模型的默认时长
            const getDefaultDurationForModel = (modelId) => {
                if (!modelId) return '5s';
                if (modelId === 'sora-2-pro') return '15s';
                if (modelId.includes('sora-2') || modelId === 'sora-2') return '15s';
                if (modelId.includes('veo') || modelId === 'google-veo3') return '8s';
                if (modelId.includes('grok') || modelId === 'grok-3') return '8s';
                return '5s';
            };

            // 获取模型可用的时长选项
            const getDefaultDurationsForModel = (modelId) => {
                if (!modelId) return ['5s', '10s', '8s'];
                if (modelId === 'sora-2-pro') return ['15s', '25s'];
                if (modelId.includes('sora-2') || modelId === 'sora-2') return ['5s', '10s', '15s'];
                if (modelId.includes('veo') || modelId === 'google-veo3') return ['8s'];
                if (modelId.includes('grok') || modelId === 'grok-3') return ['8s', '5s'];
                return ['5s', '10s', '8s'];
            };

            // 分镜表节点功能函数
            const addEmptyShot = (nodeId) => {
                const node = nodesMap.get(nodeId);
                if (!node || node.type !== 'storyboard-node') return;
                // 获取默认视频模型（优先使用 sora-2，否则使用第一个视频模型）
                const defaultModel = apiConfigs.find(c => c.type === 'Video' && c.id === 'sora-2')?.id || apiConfigs.find(c => c.type === 'Video')?.id || '';
                const newShot = {
                    id: `shot-${Date.now()}`,
                    scene_index: (node.settings?.shots?.length || 0) + 1,
                    time_range: '',
                    image_url: '',
                    description: '',
                    prompt: '',
                    camera: '',
                    tags: [],
                    status: 'draft',
                    model: defaultModel,
                    ratio: '16:9',
                    duration: getDefaultDurationForModel(defaultModel)
                };
                updateNodeSettings(nodeId, {
                    shots: [...(node.settings?.shots || []), newShot]
                });
            };

            const deleteShot = (nodeId, shotId) => {
                const node = nodesMap.get(nodeId);
                if (!node || node.type !== 'storyboard-node') return;
                const updatedShots = (node.settings?.shots || []).filter(s => s.id !== shotId);
                // 重新编号
                updatedShots.forEach((shot, idx) => {
                    shot.scene_index = idx + 1;
                });
                updateNodeSettings(nodeId, { shots: updatedShots });
            };

            const updateShot = (nodeId, shotId, updates) => {
                const node = nodesMap.get(nodeId);
                if (!node || node.type !== 'storyboard-node') return;
                const updatedShots = (node.settings?.shots || []).map(shot => 
                    shot.id === shotId ? { ...shot, ...updates } : shot
                );
                updateNodeSettings(nodeId, { shots: updatedShots });
            };

            // 从 video-analyze 节点导入分析结果
            const importShotsFromAnalysis = (nodeId) => {
                const storyboardNode = nodesMap.get(nodeId);
                if (!storyboardNode || storyboardNode.type !== 'storyboard-node') return;
                
                const analyzeNode = getConnectedVideoAnalyzeNode(nodeId);
                if (!analyzeNode) {
                    alert('请先连接一个视频拆解节点');
                    return;
                }

                // 获取分析结果（优先使用 settings.analysisResults，其次使用 analysisResults）
                const analysisResults = analyzeNode.settings?.analysisResults || analyzeNode.analysisResults || [];
                if (analysisResults.length === 0) {
                    alert('视频拆解节点没有分析结果，请先执行分析');
                    return;
                }

                // 转换为 shots 格式
                const newShots = analysisResults.map((result, idx) => {
                    const keyframe = result.keyframes?.find(k => k.type === 'current') || result.keyframes?.[0];
                    const mjPrompt = keyframe?.mj_prompt || '';
                    const jimengPrompt = keyframe?.jimeng_prompt || '';
                    const description = keyframe?.description || result.keyframes?.[0]?.description || '';
                    
                    // 提取标签
                    const tags = [];
                    if (result.global_tags?.style?.[0]) tags.push(result.global_tags.style[0]);
                    if (keyframe?.description) {
                        // 简单提取运镜信息
                        const cameraKeywords = ['推', '拉', '摇', '移', '跟', '升', '降', 'Dolly', 'Pan', 'Tilt', 'Zoom'];
                        cameraKeywords.forEach(keyword => {
                            if (description.includes(keyword)) {
                                tags.push(keyword);
                            }
                        });
                    }

                    return {
                        id: `shot-${Date.now()}-${idx}`,
                        scene_index: idx + 1,
                        time_range: result.time_range || '',
                        image_url: '',
                        description: description,
                        prompt: mjPrompt || jimengPrompt,
                        camera: tags.find(t => ['推', '拉', '摇', '移', '跟', 'Dolly', 'Pan', 'Tilt', 'Zoom'].some(k => t.includes(k))) || '',
                        tags: tags,
                        status: 'draft'
                    };
                });

                updateNodeSettings(nodeId, { shots: newShots });
            };

            // 自动从分析结果创建分镜表节点
            const createStoryboardFromAnalysisResult = (analyzeNodeId, analysisResults) => {
                const analyzeNode = nodesMap.get(analyzeNodeId);
                if (!analyzeNode || !analysisResults || analysisResults.length === 0) {
                    console.warn('[自动生成分镜表] 分析节点不存在或分析结果为空');
                    return;
                }

                // 1. 数据转换 (复用现有逻辑)
                const newShots = analysisResults.map((result, idx) => {
                    const keyframe = result.keyframes?.find(k => k.type === 'current') || result.keyframes?.[0];
                    const mjPrompt = keyframe?.mj_prompt || '';
                    const jimengPrompt = keyframe?.jimeng_prompt || '';
                    const description = keyframe?.description || result.keyframes?.[0]?.description || '';
                    
                    // 提取标签
                    const tags = [];
                    if (result.global_tags?.style?.[0]) tags.push(result.global_tags.style[0]);
                    if (result.global_tags?.camera?.[0]) tags.push(result.global_tags.camera[0]);
                    if (keyframe?.description) {
                        // 简单提取运镜信息
                        const cameraKeywords = ['推', '拉', '摇', '移', '跟', '升', '降', 'Dolly', 'Pan', 'Tilt', 'Zoom'];
                        cameraKeywords.forEach(keyword => {
                            if (description.includes(keyword)) {
                                tags.push(keyword);
                            }
                        });
                    }

                    // 提取运镜信息
                    const camera = result.global_tags?.camera?.[0] || 
                                   tags.find(t => ['推', '拉', '摇', '移', '跟', 'Dolly', 'Pan', 'Tilt', 'Zoom'].some(k => t.includes(k))) || 
                                   '';

                    return {
                        id: `shot-${Date.now()}-${idx}`,
                        scene_index: idx + 1,
                        time_range: result.time_range || '',
                        image_url: '',
                        description: description,
                        prompt: mjPrompt || jimengPrompt,
                        camera: camera,
                        tags: tags,
                        status: 'draft'
                    };
                });

                // 2. 计算新节点位置（放在源节点右侧）
                const newX = analyzeNode.x + analyzeNode.width + 100;
                const newY = analyzeNode.y;
                const storyboardId = `node-storyboard-${Date.now()}`;

                // 3. 创建节点
                const newNode = {
                    id: storyboardId,
                    type: 'storyboard-node',
                    x: newX,
                    y: newY,
                    width: 600,
                    height: 500,
                    settings: {
                        projectTitle: 'AI 拆解结果',
                        shots: newShots
                    }
                };

                // 4. 更新状态
                setNodes(prev => [...prev, newNode]);
                setConnections(prev => [...prev, {
                    id: `conn-${Date.now()}`,
                    from: analyzeNodeId,
                    to: storyboardId
                }]);

                console.log('[自动生成分镜表] 已创建分镜表节点，包含', newShots.length, '个镜头');
            };

            // 分镜表任务映射：用于追踪从分镜表触发的生成任务
            const storyboardTaskMapRef = useRef(new Map()); // taskId -> { storyboardNodeId, shotId }
            
            // 跟踪当前聚焦的提示词文本框
            const focusedPromptTextareaRef = useRef(null);

            // 生成单个镜头
            // 重构后的生成单个镜头函数：原地生成，不依赖外部节点
            // 创建角色
            const createCharacter = async (videoUrl, startSecond, endSecond, fromTaskId = null, customEndpoint = null) => {
                try {
                    // 1. 获取配置
                    const soraConfig = apiConfigs.find(c => c.type === 'Video' && (c.id === 'sora-2' || c.id === 'sora-2-pro'));
                    if (!soraConfig) {
                        alert('未找到 Sora 2 模型配置，请先在设置中配置 Sora 2 或 Sora 2 Pro');
                        setCreateCharacterSubmitting(false);
                        return;
                    }
                    
                    const apiKey = soraConfig.key || globalApiKey;
                    
                    if (!apiKey) {
                        alert('请先配置 API Key');
                        setCreateCharacterSubmitting(false);
                        return;
                    }
                    
                    // 验证时间范围
                    if (endSecond - startSecond < 1 || endSecond - startSecond > 3) {
                        alert('时间范围必须在 1-3 秒之间');
                        setCreateCharacterSubmitting(false);
                        return;
                    }
                    
                    // 2. 使用用户提供的 endpoint 或自动构造
                    const timestamps = `${startSecond},${endSecond}`;
                    let endpoint;
                    if (customEndpoint && customEndpoint.trim()) {
                        endpoint = customEndpoint.trim();
                    } else {
                        // 如果没有提供，使用默认路径
                        const baseUrl = (soraConfig.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                        endpoint = `${baseUrl}/sora/v1/characters`;
                    }
                    
                    // 3. 构造 Body
                    const payload = fromTaskId 
                        ? { from_task: fromTaskId, timestamps }
                        : { url: videoUrl, timestamps };
                    
                    // 4. 详细调试日志
                    console.log('[Create Character] Request Details:', {
                        endpoint,
                        apiKey: apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 4)}` : 'EMPTY',
                        payload,
                        fromTaskId,
                        videoUrl: fromTaskId ? 'N/A (using from_task)' : videoUrl,
                        customEndpoint: customEndpoint || 'N/A (using default)'
                    });
                    
                    // 5. 发送请求
                    const resp = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });
                    
                    // 6. 错误处理
                    if (!resp.ok) {
                        const errText = await resp.text();
                        console.error('[Create Character] API Error:', {
                            status: resp.status,
                            statusText: resp.statusText,
                            errorText: errText,
                            endpoint
                        });
                        
                        // 尝试解析错误响应
                        let errorData = null;
                        try {
                            errorData = JSON.parse(errText);
                        } catch (e) {
                            // 如果不是 JSON，使用原始文本
                        }
                        
                        // 特殊处理 500 错误和 get_origin_task_failed
                        if (resp.status === 500 || (errorData && (errorData.code === 'get_origin_task_failed' || errorData.message?.includes('get_origin_task_failed')))) {
                            throw new Error('TASK_NOT_FOUND');
                        }
                        
                        throw new Error(`API错误 (${resp.status}): ${errText || resp.statusText}`);
                    }
                    
                    const data = await resp.json();
                    console.log('[Create Character] Success:', data);
                    
                    // 7. 保存到角色库
                    if (data.id && data.username) {
                        const newCharacter = {
                            id: data.id,
                            username: data.username,
                            profile_picture_url: data.profile_picture_url || '',
                            permalink: data.permalink || ''
                        };
                        
                        const updated = [...characterLibrary, newCharacter];
                        setCharacterLibrary(updated);
                        alert(`角色 "${data.username}" 创建成功！`);
                        setCreateCharacterOpen(false);
                        // 重置表单
                        setCreateCharacterVideoSourceType('url');
                        setCreateCharacterVideoUrl('');
                        setCreateCharacterSelectedTaskId('');
                        setCreateCharacterStartSecond(1);
                        setCreateCharacterEndSecond(3);
                        setCreateCharacterEndpoint('');
                    } else {
                        throw new Error('返回数据缺少 id 或 username');
                    }
                } catch (err) {
                    console.error('[Create Character] Failed:', err);
                    let msg = err.message;
                    
                    // 特殊处理：原任务已过期或无法访问
                    if (msg === 'TASK_NOT_FOUND') {
                        alert('创建失败：原任务已过期或无法访问。\n\n请尝试获取该视频的下载链接，使用"输入视频 URL"方式重新创建。');
                        return;
                    }
                    
                    // 处理网络错误
                    if (msg.includes('Failed to fetch') || err.name === 'TypeError' || err.message.includes('NetworkError')) {
                        msg = '连接失败。可能原因：\n\n1. API 地址填写错误\n   - 请检查 API 接口地址是否多余了 "/sora" 前缀\n   - 有些服务商的路径可能不同，请询问服务商 Sora 角色创建接口的准确路径\n\n2. 跨域限制 (CORS)\n   - 请尝试安装 Allow CORS 浏览器插件\n\n3. 网络问题\n   - 请检查网络连接';
                    }
                    
                    alert(`创建角色失败: ${msg}`);
                } finally {
                    setCreateCharacterSubmitting(false);
                }
            };

            const generateSingleShot = (nodeId, shot) => {
                // 1. 构建更加丰富的 Prompt
                // 优先级：提示词 > 画面描述 > 风格标签 > 运镜
                let finalPrompt = shot.prompt || "";
                
                // 如果提示词为空，尝试使用描述自动构建
                if (!finalPrompt && shot.description) {
                    finalPrompt = shot.description;
                }

                // 拼接风格标签 (Style Tags)
                if (shot.tags && shot.tags.length > 0) {
                    const styleText = shot.tags.join(", ");
                    finalPrompt += `, ${styleText}`;
                }

                // 拼接运镜 (Camera)
                if (shot.camera) {
                    finalPrompt += `, ${shot.camera} camera movement`;
                }

                if (!finalPrompt) {
                    alert('请至少填写画面描述或提示词');
                    return;
                }

                // 2. 获取选中的视频模型（必须选择视频模型）
                const selectedModel = shot.model || (apiConfigs.find(c => c.type === 'Video' && c.id === 'sora-2')?.id || apiConfigs.find(c => c.type === 'Video')?.id || '');
                const modelConfig = apiConfigsMap.get(selectedModel);
                
                if (!modelConfig || modelConfig.type !== 'Video') {
                    alert('请先选择一个视频模型');
                    return;
                }

                // 3. 准备参考图 (Image Input)
                // 如果分镜格子里已经有图（比如用户拖入的参考图），则将其作为 img2img/img2vid 的输入
                const sourceImages = [];
                if (shot.image_url) {
                    sourceImages.push(shot.image_url);
                }

                // 4. 更新 shot 状态为生成中
                updateShot(nodeId, shot.id, { status: 'generating' });

                // 5. 构建覆盖选项
                const overrideOptions = {
                    model: selectedModel,
                    ratio: shot.ratio || '16:9',
                    duration: shot.duration || getDefaultDurationForModel(selectedModel)
                };
                
                // 6. 创建一个特殊的节点ID用于标识这是分镜表的任务
                // 格式：storyboard-${nodeId}-shot-${shotId}
                const virtualNodeId = `storyboard-${nodeId}-shot-${shot.id}`;
                
                // 7. 预先记录任务映射（在 startGeneration 创建 taskId 之前）
                // 由于 startGeneration 内部会使用 Date.now().toString() 作为 taskId
                // 我们需要在 startGeneration 内部检查 sourceNodeId 模式并自动记录
                // 这里我们先调用 startGeneration，任务映射会在 startGeneration 内部完成
                
                // 调用核心生成函数
                startGeneration(finalPrompt, 'video', sourceImages, virtualNodeId, overrideOptions);
            };
            
            // 拓展图片 Zoom Out 功能
            const handleExpandImageZoom = async (nodeId, zoomLevel) => {
                const node = nodesMap.get(nodeId);
                if (!node || !node.content) {
                    console.warn('拓展图片: 节点不存在或没有图片内容');
                    return;
                }

                // 查找 Midjourney 配置（优先使用节点设置中选择的模型）
                const selectedMjModelId = node.settings?.mjModel || 'mj-v7';
                let mjConfig = apiConfigs.find(c => c.id === selectedMjModelId);
                
                // 如果找不到，尝试查找任何 Midjourney 配置
                if (!mjConfig) {
                    mjConfig = apiConfigs.find(c => c.id.includes('mj') || c.provider.toLowerCase().includes('midjourney'));
                }
                
                if (!mjConfig) {
                    alert('请先配置 Midjourney API');
                    setSettingsOpen(true);
                    return;
                }

                const apiKey = mjConfig.key || globalApiKey;
                const baseUrl = (mjConfig.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                if (!apiKey) {
                    alert('请先配置 Midjourney API Key');
                    setSettingsOpen(true);
                    return;
                }

                try {
                    // 1. 上传图片获取 HTTP URL（如果是 data URL）
                    let imageUrl = node.content;
                    if (imageUrl.startsWith('data:')) {
                        console.log('拓展图片: 开始上传图片获取 HTTP URL...', 'baseUrl:', baseUrl, 'apiKey存在:', !!apiKey);
                        const httpUrl = await uploadImageToGetHttpUrl(imageUrl, baseUrl, apiKey);
                        if (!httpUrl) {
                            console.error('拓展图片: 图片上传失败，所有方法都失败');
                            alert('图片上传失败，无法进行拓展。请检查网络连接和API配置。');
                            return;
                        }
                        console.log('拓展图片: 图片上传成功，HTTP URL:', httpUrl);
                        imageUrl = httpUrl;
                    } else if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                        console.log('拓展图片: 图片已经是HTTP URL，直接使用:', imageUrl);
                    } else {
                        console.warn('拓展图片: 图片URL格式未知:', imageUrl.substring(0, 50));
                    }

                    // 2. 先提交图片到 Midjourney 获取原始任务ID
                    const taskId = Date.now().toString();
                    const now = Date.now();
                    
                    setHistory((prev) => [{
                        id: taskId,
                        type: 'image',
                        url: '',
                        prompt: `Zoom Out ${zoomLevel}x`,
                        time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                        status: 'generating',
                        progress: 5,
                        modelName: 'Midjourney Zoom',
                        width: 0,
                        height: 0,
                        remoteTaskId: null,
                        apiConfig: { modelId: 'mj-zoom', baseUrl, apiKey },
                        sourceNodeId: nodeId,
                        startTime: now,
                        durationMs: null
                    }, ...prev]);
                    setHistoryOpen(true);

                    // 3. 提交图片到 Midjourney（使用 imagine 接口，不包含 zoom 参数）
                    const mjMode = 'fast';
                    const imagineEndpoint = `${baseUrl}/${mjMode}/mj/submit/imagine`;
                    const imaginePayload = {
                        prompt: imageUrl,
                        notifyHook: '',
                        state: ''
                    };

                    const imagineResp = await fetch(imagineEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(imaginePayload)
                    });

                    const imagineText = await imagineResp.text();
                    if (!imagineResp.ok) {
                        throw new Error(imagineText || `Imagine API error: ${imagineResp.status}`);
                    }

                    const imagineData = JSON.parse(imagineText);
                    if (imagineData.code !== 1 && imagineData.code !== 22) {
                        throw new Error(imagineData.description || `Midjourney提交失败: code ${imagineData.code}`);
                    }

                    const originalTaskId = imagineData.result;
                    if (!originalTaskId) throw new Error('未获取到任务ID');

                    console.log('拓展图片: 获取到原始任务ID', originalTaskId);

                    // 4. 等待原始任务完成（ZOOM操作需要原始任务完成）
                    console.log('拓展图片: 等待原始任务完成...', originalTaskId);
                    let originalTaskCompleted = false;
                    let pollCount = 0;
                    const maxPolls = 120; // 最多轮询120次（约10分钟）
                    
                    while (!originalTaskCompleted && pollCount < maxPolls) {
                        await new Promise(resolve => setTimeout(resolve, 5000)); // 每5秒检查一次
                        pollCount++;
                        
                        try {
                            const statusResp = await fetch(`${baseUrl}/${mjMode}/mj/task/${originalTaskId}/fetch`, {
                                method: 'GET',
                                headers: {
                                    'Authorization': `Bearer ${apiKey}`,
                                    'Content-Type': 'application/json'
                                }
                            });
                            
                            const statusText = await statusResp.text();
                            const statusData = JSON.parse(statusText);
                            const status = statusData?.status || '';
                            
                            console.log('拓展图片: 原始任务状态检查', { status, pollCount });
                            
                        if (status === 'SUCCESS' || status === 'FINISHED') {
                            originalTaskCompleted = true;
                            console.log('拓展图片: 原始任务已完成，可以执行ZOOM操作');
                        } else if (status === 'FAILURE' || status === 'ERROR' || status === 'CANCELLED') {
                            throw new Error(`原始任务失败: ${status}`);
                        }
                    } catch (error) {
                        if (pollCount >= maxPolls) {
                            throw new Error('原始任务状态检查超时');
                        }
                        console.warn('拓展图片: 状态检查出错，继续重试', error);
                    }
                }
                
                if (!originalTaskCompleted) {
                    throw new Error('原始任务超时，无法执行ZOOM操作');
                }

                // 5. 使用 modal 接口提交 ZOOM 操作
                const modalEndpoint = `${baseUrl}/mj/submit/modal`;
                // ZOOM操作的prompt格式：根据Midjourney文档，使用 --zoomout 参数
                const zoomPrompt = `--zoomout ${zoomLevel}`;
                const modalPayload = {
                    taskId: originalTaskId,
                    prompt: zoomPrompt
                    // maskBase64 可选，ZOOM 不需要蒙版
                };

                console.log('拓展图片: 调用 ZOOM modal 接口', { taskId: originalTaskId, prompt: zoomPrompt });
                
                const modalResp = await fetch(modalEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(modalPayload)
                });

                const modalText = await modalResp.text();
                if (!modalResp.ok) {
                    throw new Error(modalText || `Modal API error: ${modalResp.status}`);
                }

                const modalData = JSON.parse(modalText);
                if (modalData.code !== 1 && modalData.code !== 22) {
                    throw new Error(modalData.description || `ZOOM提交失败: code ${modalData.code}`);
                }

                const zoomTaskId = modalData.result;
                if (!zoomTaskId) throw new Error('未获取到ZOOM任务ID');

                console.log('拓展图片: 获取到ZOOM任务ID', zoomTaskId);

                // 6. 更新历史记录，保存ZOOM任务ID
                setHistory((prev) => prev.map((hItem) => 
                    hItem.id === taskId 
                        ? { ...hItem, remoteTaskId: zoomTaskId, status: 'generating', progress: 20 } 
                        : hItem
                ));

                // 7. 开始轮询ZOOM任务状态
                pollMidjourneyJob(zoomTaskId, taskId, baseUrl, apiKey, mjMode, 0, 0);
                } catch (error) {
                    console.error('拓展图片: 处理失败', error);
                    const taskId = Date.now().toString();
                    setHistory((prev) => {
                        const existing = prev.find(h => h.sourceNodeId === nodeId && h.prompt === `Zoom Out ${zoomLevel}x`);
                        if (existing) {
                            return prev.map((hItem) => 
                                hItem.id === existing.id 
                                    ? { ...hItem, status: 'failed', errorMsg: error.message || '拓展失败' } 
                                    : hItem
                            );
                        }
                        return prev;
                    });
                }
            };

            const handleFileUpload = (nodeId, e) => {
                const file = e.target.files?.[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = async (ev) => {
                         const content = ev.target.result;
                         let dimensions = { w: 0, h: 0 };
                         try { dimensions = await getImageDimensions(content); } catch (e) {}
                         setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, content: content, dimensions } : n));
                    };
                    reader.readAsDataURL(file);
                }
            };

            // 按时间段分组关键帧
            const groupKeyframesByTime = (keyframes, segmentDuration) => {
                if (!keyframes || keyframes.length === 0) return [];
                const sorted = [...keyframes].sort((a, b) => a.time - b.time);
                const groups = [];
                let currentGroup = [];
                let currentGroupStart = sorted[0].time;
                
                sorted.forEach((frame, idx) => {
                    if (frame.time - currentGroupStart >= segmentDuration && currentGroup.length > 0) {
                        groups.push([...currentGroup]);
                        currentGroup = [frame];
                        currentGroupStart = frame.time;
                    } else {
                        currentGroup.push(frame);
                    }
                });
                
                if (currentGroup.length > 0) {
                    groups.push(currentGroup);
                }
                
                return groups;
            };

            // 为选中关键帧生成提示词
            const handleGeneratePrompts = async (nodeId) => {
                const node = nodesMap.get(nodeId);
                if (!node || node.type !== 'video-analyze') return;
                
                const videoInputNode = getConnectedVideoInputNode(nodeId);
                if (!videoInputNode) {
                    alert('请先连接一个视频输入节点');
                    return;
                }
                
                const selectedKeyframes = videoInputNode.selectedKeyframes || [];
                if (selectedKeyframes.length === 0) {
                    alert('请先在视频输入节点中选择关键帧');
                    return;
                }
                
                const config = apiConfigs.find((c) => c.id === node.settings?.model || 'gemini-3-pro');
                const apiKey = config?.key || globalApiKey;
                const baseUrl = (config?.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                
                if (!apiKey) {
                    alert('请先在 API 设置中配置 Key');
                    setSettingsOpen(true);
                    return;
                }
                
                const segmentDuration = node.settings?.segmentDuration || 3;
                const groups = groupKeyframesByTime(selectedKeyframes, segmentDuration);
                
                if (groups.length === 0) {
                    alert('无法分组关键帧');
                    return;
                }
                
                setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, isGenerating: true, analysisResults: [] } : n));
                
                const allResults = [];
                const videoFileName = videoInputNode.videoFileName || 'video.mp4';
                const videoDuration = videoInputNode.videoMeta?.duration || 0;
                // 保存分析模式，用于判断是否添加到历史记录
                const analysisMode = node.settings?.analysisMode || 'manual';
                
                try {
                    for (let sceneIndex = 0; sceneIndex < groups.length; sceneIndex++) {
                        const group = groups[sceneIndex];
                        const timeRange = `${group[0].time.toFixed(1)}s-${group[group.length - 1].time.toFixed(1)}s`;
                        
                        // 构建多模态消息
                        const systemPrompt = `你是一个专业的视频拆解和提示词生成助手。请分析提供的视频关键帧，动态拆解视频内容，并根据用户选中的关键帧生成高质量的AI绘图提示词。

请返回严格的 JSON 格式，结构如下：
{
  "video_id": "${videoFileName}",
  "scene_index": ${sceneIndex + 1},
  "time_range": "${timeRange}",
  "keyframes": [
    {
      "type": "prev",
      "time": 5.2,
      "description": "上一画面内容简介",
      "mj_prompt": "Midjourney 英文提示词",
      "jimeng_prompt": "即梦中文提示词"
    },
    {
      "type": "current",
      "time": 6.8,
      "description": "当前画面内容简介",
      "mj_prompt": "Midjourney 英文提示词",
      "jimeng_prompt": "即梦中文提示词"
    },
    {
      "type": "next",
      "time": 8.7,
      "description": "下一画面内容简介",
      "mj_prompt": "Midjourney 英文提示词",
      "jimeng_prompt": "即梦中文提示词"
    }
  ],
  "global_tags": {
    "style": ["赛博朋克", "末日科幻"],
    "camera": ["低机位", "广角"],
    "color": ["冷暖对比"]
  }
}

要求：
1. 为每个关键帧生成 prev/current/next 三种类型的描述和提示词
2. mj_prompt 使用英文，适合 Midjourney
3. jimeng_prompt 使用中文，适合即梦AI
4. global_tags 提取整个场景的风格、镜头、色彩特征`;

                        const userContent = [
                            { type: "text", text: `请分析以下视频关键帧（场景 ${sceneIndex + 1}，时间段：${timeRange}），生成详细的提示词：` }
                        ];
                        
                        // 添加关键帧图片（限制最多15张，因为API限制是16张，需要留一些余量）
                        const maxFrames = 15;
                        const framesToSend = group.length > maxFrames ? group.slice(0, maxFrames) : group;
                        framesToSend.forEach((frame, idx) => {
                            userContent.push({
                                type: "image_url",
                                image_url: { url: frame.url }
                            });
                            if (idx < framesToSend.length - 1) {
                                userContent.push({ type: "text", text: `关键帧 ${idx + 1}（时间：${frame.time.toFixed(2)}s）` });
                            }
                        });
                        if (group.length > maxFrames) {
                            userContent.push({ type: "text", text: `注意：该场景共有 ${group.length} 个关键帧，但为了符合API限制，仅发送了前 ${maxFrames} 个关键帧进行分析。` });
                        }
                        
                        const apiMessages = [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userContent }
                        ];
                        
                        // 添加超时控制（60秒）
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 60000);
                        
                        let response;
                        try {
                            response = await fetch(`${baseUrl}/v1/chat/completions`, {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${apiKey}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    model: config?.modelName || 'gemini-3-pro-preview',
                                    messages: apiMessages,
                                    stream: false
                                }),
                                signal: controller.signal
                            });
                        } catch (fetchError) {
                            clearTimeout(timeoutId);
                            // 处理网络错误
                            if (fetchError.name === 'AbortError') {
                                throw new Error('请求超时，请检查网络连接或稍后重试');
                            } else if (fetchError.message && fetchError.message.includes('Failed to fetch')) {
                                throw new Error(`无法连接到 API 服务器 (${baseUrl})。请检查：\n1. API 地址是否正确\n2. 网络连接是否正常\n3. API 服务是否可用`);
                            } else {
                                throw new Error(`网络请求失败: ${fetchError.message}`);
                            }
                        } finally {
                            clearTimeout(timeoutId);
                        }
                        
                        if (!response.ok) {
                            let errText = '';
                            try {
                                errText = await response.text();
                            } catch (e) {
                                errText = `HTTP ${response.status}: ${response.statusText}`;
                            }
                            throw new Error(errText || `API Error: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        console.log('[视频拆解] API 响应数据:', { 
                            hasData: !!data, 
                            hasChoices: !!data.choices, 
                            choicesLength: data.choices?.length,
                            dataKeys: Object.keys(data || {}),
                            model: config?.modelName || config?.id
                        });
                        
                        // 支持多种响应格式
                        let aiContent = null;
                        if (data.choices && data.choices.length > 0) {
                            // OpenAI 格式: data.choices[0].message.content
                            aiContent = data.choices[0]?.message?.content;
                        } else if (data.data?.choices && data.data.choices.length > 0) {
                            // 嵌套 data.choices 格式
                            aiContent = data.data.choices[0]?.message?.content;
                        } else if (data.content) {
                            // 直接 content 字段
                            aiContent = data.content;
                        } else if (data.data?.content) {
                            // 嵌套 data.content 格式
                            aiContent = data.data.content;
                        } else if (data.text) {
                            // text 字段
                            aiContent = data.text;
                        } else if (data.data?.text) {
                            // 嵌套 data.text 格式
                            aiContent = data.data.text;
                        } else if (data.message) {
                            // message 字段
                            aiContent = typeof data.message === 'string' ? data.message : data.message.content;
                        } else if (data.data?.message) {
                            // 嵌套 data.message 格式
                            aiContent = typeof data.data.message === 'string' ? data.data.message : data.data.message.content;
                        } else if (data.result) {
                            // result 字段
                            aiContent = typeof data.result === 'string' ? data.result : data.result.content;
                        } else if (data.data?.result) {
                            // 嵌套 data.result 格式
                            aiContent = typeof data.data.result === 'string' ? data.data.result : data.data.result.content;
                        }
                        
                        if (!aiContent || aiContent.trim() === '' || aiContent === '{}') {
                            console.error('[视频拆解] API 响应内容为空:', data);
                            throw new Error(`API 返回内容为空。响应数据: ${JSON.stringify(data).substring(0, 200)}`);
                        }
                        
                        console.log('[视频拆解] 提取的内容长度:', aiContent.length, '前100字符:', aiContent.substring(0, 100));
                        
                        // 尝试解析 JSON（可能包含 markdown 代码块）
                        let jsonStr = aiContent.trim();
                        if (jsonStr.startsWith('```')) {
                            jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
                        }
                        
                        let result;
                        try {
                            result = JSON.parse(jsonStr);
                            console.log('[视频拆解] JSON 解析成功，场景索引:', result.scene_index || sceneIndex + 1);
                        } catch (e) {
                            console.error('[视频拆解] 解析 JSON 失败:', e, '内容前500字符:', jsonStr.substring(0, 500));
                            // 尝试修复常见的JSON格式问题
                            try {
                                // 移除可能的注释
                                jsonStr = jsonStr.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*/g, '');
                                // 尝试修复尾随逗号
                                jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');
                                result = JSON.parse(jsonStr);
                                console.log('[视频拆解] JSON 修复后解析成功');
                            } catch (e2) {
                                console.error('[视频拆解] JSON修复后仍解析失败:', e2, '原始内容:', jsonStr);
                                // 如果还是失败，创建一个默认结构
                                result = {
                                    video_id: videoFileName,
                                    scene_index: sceneIndex + 1,
                                    time_range: timeRange,
                                    keyframes: group.map((frame, fIdx) => ({
                                        type: fIdx === 0 ? 'prev' : fIdx === 1 ? 'current' : 'next',
                                        time: frame.time,
                                        description: `视频帧 ${frame.time.toFixed(1)}s`,
                                        mj_prompt: 'A detailed scene from the video',
                                        jimeng_prompt: '视频场景描述'
                                    })),
                                    global_tags: { style: [], camera: [], color: [] }
                                };
                                console.warn('[视频拆解] 使用默认结构，原始内容:', jsonStr.substring(0, 200));
                            }
                        }
                        
                        allResults.push(result);
                        console.log('[视频拆解] 场景处理完成，当前结果数:', allResults.length);
                        
                        // 更新节点状态
                        setNodes((prev) => prev.map((n) => {
                            if (n.id === nodeId) {
                                const currentResults = n.analysisResults || [];
                                const updatedResults = [...currentResults, result];
                                console.log('[视频拆解] 更新节点状态，结果数:', updatedResults.length);
                                return { ...n, analysisResults: updatedResults };
                            }
                            return n;
                        }));
                        
                        // 只有自动模式（AI 导演拆解）才添加到历史记录，手动选帧拆解不添加到历史记录
                        const isManualMode = analysisMode === 'manual';
                        if (!isManualMode) {
                        // 添加到历史记录
                        const taskId = `analyze-${nodeId}-${sceneIndex}-${Date.now()}`;
                        const historyItem = {
                            id: taskId,
                            type: 'analyze',
                            prompt: `视频拆解 - 场景 ${sceneIndex + 1}`,
                            url: group[0]?.url || '',
                            status: 'completed',
                            progress: 100,
                            modelName: config?.provider || 'Gemini 3 Pro',
                            time: new Date().toLocaleString('zh-CN'),
                            sourceNodeId: nodeId,
                            analysisResult: result,
                            videoFileName,
                            sceneIndex: sceneIndex + 1,
                            timeRange
                        };
                        
                        setHistory((prev) => [historyItem, ...prev]);
                        }
                    }
                    
                    // 确保所有结果都已更新到节点
                    console.log('[视频拆解] 所有场景处理完成，总结果数:', allResults.length);
                    setNodes((prev) => prev.map((n) => {
                        if (n.id === nodeId) {
                            // 确保使用最新的 allResults
                            const finalResults = allResults.length > 0 ? allResults : (n.analysisResults || []);
                            console.log('[视频拆解] 最终更新节点，结果数:', finalResults.length);
                            return { ...n, isGenerating: false, analysisResults: finalResults };
                        }
                        return n;
                    }));
                    
                } catch (error) {
                    console.error('生成提示词失败:', error);
                    const errorMsg = error.message || '未知错误';
                    setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, isGenerating: false, errorMsg: errorMsg } : n));
                    // 不显示 alert，错误信息已经在节点上显示
                    // alert(`生成提示词失败: ${errorMsg}`);
                }
            };

            // AI 视频全自动分析
            const handleAutoVideoAnalysis = async (nodeId) => {
                const node = nodesMap.get(nodeId);
                if (!node || node.type !== 'video-analyze') return;
                
                const videoInputNode = getConnectedVideoInputNode(nodeId);
                if (!videoInputNode || !videoInputNode.content) {
                    alert('请先连接一个包含视频的视频输入节点');
                    return;
                }
                
                // 预处理视频内容：如果是 blob: URL，需要转换为 base64 以便远程可访问
                let videoDataUrl = videoInputNode.content;
                if (videoDataUrl.startsWith('blob:')) {
                    try {
                        console.log('Converting Blob URL to Base64 for API...');
                        const blob = await fetch(videoDataUrl).then(r => r.blob());
                        videoDataUrl = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onerror = () => reject(new Error('FileReader failed'));
                            reader.onloadend = () => resolve(reader.result);
                            reader.readAsDataURL(blob);
                        });
                    } catch (e) {
                        console.error('Blob conversion failed', e);
                        alert('视频转换失败，无法发送给 AI');
                        return;
                    }
                }
                
                // 强制使用 gemini-3-pro 模型（支持视频输入）
                let config = apiConfigs.find((c) => c.id === 'gemini-3-pro' && c.type === 'Chat');
                
                // 如果没有找到 gemini-3-pro，尝试其他 gemini 模型
                if (!config) {
                    config = apiConfigs.find((c) => {
                        const modelId = c.id?.toLowerCase() || '';
                        return modelId.includes('gemini') && c.type === 'Chat';
                    });
                }
                
                // 如果还是没有，使用默认配置
                if (!config) {
                    config = apiConfigs.find((c) => c.type === 'Chat');
                }
                
                const apiKey = config?.key || globalApiKey;
                const baseUrl = (config?.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                
                if (!apiKey) {
                    alert('请先在 API 设置中配置 Key');
                    setSettingsOpen(true);
                    return;
                }
                
                setNodes((prev) => prev.map((n) => 
                    n.id === nodeId 
                        ? { ...n, isGenerating: true, settings: { ...n.settings, voiceoverResults: [], analysisResults: [] } }
                        : n
                ));
                
                try {
                    const systemPrompt = `你是一位世界级的**游戏买量视频拆解专家**和**AI视觉导演**。你需要同时完成两项任务：

1. **视觉拆解**：分析视频的每一个分镜，推测其运镜手法（推拉摇移）、画面动态、人物关系。

2. **听觉提取**：提取视频中的口播文案（Voiceover）。

请按时间顺序，将视频拆解为多个关键场景，并返回如下 **JSON 格式**（不要包含Markdown代码块标记）：

{
  "voiceover_script": [
    { "time_range": "0s-3s", "text": "提取的口播文案..." }
  ],
  "scenes": [
    {
      "scene_id": 1,
      "time_range": "0s-2.5s",
      "visual_analysis": {
        "camera_movement": "详细描述运镜，例如：镜头瞬间快速拉远(Dolly Zoom Out)，或 环绕拍摄(Orbit)",
        "subject_dynamics": "描述主体动作，例如：角色从王座上猛然站起，披风飞扬",
        "atmosphere": "赛博朋克，冷峻，高科技感"
      },
      "prompts": {
        "jimeng_prompt": "即梦提示词：一定要包含运镜描述。格式：(运镜描述)+画面主体+环境+风格。例如：(镜头急速拉远)，一名黑发年轻男子坐在虚拟王座上，身穿黑色长风衣...",
        "mj_prompt": "Midjourney Prompt: English description, include camera directives like 'dynamic angle', 'fast zoom out', 'cinematic lighting'..."
      }
    }
  ]
}

**重要要求：**
- **运镜分析**要非常精准。
- **即梦提示词**必须将"运镜描述"放在最前面，用括号括起来。
- **口播提取**要依靠视频中的音频内容，如果视频没有声音则留空。`;

                    // 直接使用视频 URL（gemini-3-pro 支持视频输入）
                    const userContent = [
                        { type: "text", text: "请分析这段视频。请严格按JSON格式输出拆解报告。" },
                        { type: "image_url", image_url: { url: videoDataUrl } }
                    ];
                    
                    const apiMessages = [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: userContent }
                    ];
                    
                    // 添加超时控制（120秒，因为视频分析需要更长时间）
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 120000);
                    
                    let response;
                    try {
                        response = await fetch(`${baseUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                model: config?.modelName || 'gemini-3-pro-preview',
                                messages: apiMessages,
                                stream: false
                            }),
                            signal: controller.signal
                        });
                    } catch (fetchError) {
                        clearTimeout(timeoutId);
                        // 处理网络错误
                        if (fetchError.name === 'AbortError') {
                            throw new Error('请求超时（120秒），视频分析可能需要更长时间，请稍后重试');
                        } else if (fetchError.message && fetchError.message.includes('Failed to fetch')) {
                            throw new Error(`无法连接到 API 服务器 (${baseUrl})。请检查：\n1. API 地址是否正确\n2. 网络连接是否正常\n3. API 服务是否可用\n4. 是否配置了正确的 API Key`);
                        } else {
                            throw new Error(`网络请求失败: ${fetchError.message}`);
                        }
                    } finally {
                        clearTimeout(timeoutId);
                    }
                    
                    if (!response.ok) {
                        let errText = '';
                        try {
                            errText = await response.text();
                        } catch (e) {
                            errText = `HTTP ${response.status}: ${response.statusText}`;
                        }
                        throw new Error(errText || `API Error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('[AI导演拆解] API 响应数据:', { 
                        hasData: !!data, 
                        hasChoices: !!data.choices, 
                        choicesLength: data.choices?.length,
                        dataKeys: Object.keys(data || {}),
                        model: config?.modelName || config?.id
                    });
                    
                    // 支持多种响应格式
                    let aiContent = null;
                    if (data.choices && data.choices.length > 0) {
                        // OpenAI 格式: data.choices[0].message.content
                        aiContent = data.choices[0]?.message?.content;
                    } else if (data.data?.choices && data.data.choices.length > 0) {
                        // 嵌套 data.choices 格式
                        aiContent = data.data.choices[0]?.message?.content;
                    } else if (data.content) {
                        // 直接 content 字段
                        aiContent = data.content;
                    } else if (data.data?.content) {
                        // 嵌套 data.content 格式
                        aiContent = data.data.content;
                    } else if (data.text) {
                        // text 字段
                        aiContent = data.text;
                    } else if (data.data?.text) {
                        // 嵌套 data.text 格式
                        aiContent = data.data.text;
                    } else if (data.message) {
                        // message 字段
                        aiContent = typeof data.message === 'string' ? data.message : data.message.content;
                    } else if (data.data?.message) {
                        // 嵌套 data.message 格式
                        aiContent = typeof data.data.message === 'string' ? data.data.message : data.data.message.content;
                    } else if (data.result) {
                        // result 字段
                        aiContent = typeof data.result === 'string' ? data.result : data.result.content;
                    } else if (data.data?.result) {
                        // 嵌套 data.result 格式
                        aiContent = typeof data.data.result === 'string' ? data.data.result : data.data.result.content;
                    }
                    
                    if (!aiContent || aiContent.trim() === '' || aiContent === '{}') {
                        console.error('[AI导演拆解] API 响应内容为空:', data);
                        throw new Error(`API 返回内容为空。响应数据: ${JSON.stringify(data).substring(0, 200)}`);
                    }
                    
                    console.log('[AI导演拆解] 提取的内容长度:', aiContent.length, '前100字符:', aiContent.substring(0, 100));
                    
                    // 解析 JSON
                    let jsonStr = aiContent.trim();
                    if (jsonStr.startsWith('```')) {
                        jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
                    }
                    
                    let result;
                    try {
                        result = JSON.parse(jsonStr);
                        console.log('[AI导演拆解] JSON 解析成功，场景数:', result.scenes?.length || 0);
                    } catch (e) {
                        console.error('[AI导演拆解] 解析 JSON 失败:', e, '内容前500字符:', jsonStr.substring(0, 500));
                        // 尝试修复
                        try {
                            jsonStr = jsonStr.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*/g, '');
                            jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');
                            result = JSON.parse(jsonStr);
                            console.log('[AI导演拆解] JSON 修复后解析成功');
                        } catch (e2) {
                            console.error('[AI导演拆解] JSON修复后仍解析失败:', e2, '原始内容:', jsonStr.substring(0, 500));
                            throw new Error(`模型返回的不是有效的 JSON 格式。原始内容: ${jsonStr.substring(0, 200)}`);
                        }
                    }
                    
                    // 处理 voiceover_script，转换为 voiceoverResults 格式
                    const voiceoverResults = (result.voiceover_script || []).map((v, idx) => ({
                        time: idx,
                        text: v.text || ''
                    }));
                    console.log('[AI导演拆解] 口播文案数:', voiceoverResults.length);
                    
                    // 处理 scenes，转换为 analysisResults 格式
                    const analysisResults = (result.scenes || []).map((scene, idx) => ({
                        scene_index: scene.scene_id || idx + 1,
                        time_range: scene.time_range || '',
                        keyframes: [{
                            type: 'current',
                            time: 0,
                            description: `${scene.visual_analysis?.camera_movement || ''} ${scene.visual_analysis?.subject_dynamics || ''}`.trim(),
                            mj_prompt: scene.prompts?.mj_prompt || '',
                            jimeng_prompt: scene.prompts?.jimeng_prompt || ''
                        }],
                        global_tags: {
                            style: scene.visual_analysis?.atmosphere ? [scene.visual_analysis.atmosphere] : [],
                            camera: scene.visual_analysis?.camera_movement ? [scene.visual_analysis.camera_movement] : [],
                            color: []
                        }
                    }));
                    console.log('[AI导演拆解] 场景数:', analysisResults.length);
                    
                    // 更新节点状态
                    setNodes((prev) => prev.map((n) => {
                        if (n.id === nodeId) {
                            console.log('[AI导演拆解] 更新节点状态，场景数:', analysisResults.length, '口播数:', voiceoverResults.length);
                            return { 
                                ...n, 
                                isGenerating: false, 
                                settings: { 
                                    ...n.settings, 
                                    voiceoverResults, 
                                    analysisResults 
                                } 
                            };
                        }
                        return n;
                    }));
                    
                    // 自动创建分镜表节点
                    if (analysisResults.length > 0) {
                        setTimeout(() => {
                            createStoryboardFromAnalysisResult(nodeId, analysisResults);
                        }, 100); // 延迟100ms确保节点状态已更新
                    }
                    
                } catch (error) {
                    console.error('AI视频分析失败:', error);
                    const errorMsg = error.message || 'AI视频分析失败';
                    setNodes((prev) => prev.map((n) => 
                        n.id === nodeId 
                            ? { ...n, isGenerating: false, errorMsg: errorMsg }
                            : n
                    ));
                    // 不显示 alert，错误信息已经在节点上显示
                    // alert(`AI视频分析失败: ${errorMsg}`);
                }
            };

            const addPromptLibraryItem = () => {
                const name = promptLibraryForm.name.trim();
                const prompt = promptLibraryForm.prompt.trim();
                if (!name || !prompt) {
                    alert('请输入名称和提示词内容');
                    return;
                }
                setPromptLibrary((prev) => [
                    { id: `custom-${Date.now()}`, name, prompt },
                    ...prev
                ]);
                setPromptLibraryForm({ name: '', prompt: '' });
            };
            const removePromptLibraryItem = (id) => {
                setPromptLibrary((prev) => prev.filter((p) => p.id !== id));
            };
            const applyLibraryPrompt = (nodeId, promptText) => {
                if (!nodeId || !promptText) return;
                updateNodeSettings(nodeId, { prompt: promptText });
            };

            // 生成九宫格分镜脚本提示词
            const generateGridPrompt = () => {
                const currentSelectedId = selectedNodeIdRef.current;
                if (!currentSelectedId) {
                    alert('请先选中一个AI绘图节点');
                    return;
                }
                
                const targetNode = nodesRef.current.find(n => n.id === currentSelectedId);
                if (!targetNode || targetNode.type !== 'gen-image') {
                    alert('请选中一个AI绘图节点（gen-image）');
                    return;
                }
                
                // 获取连接的参考图
                const connectedImages = getConnectedInputImages(targetNode.id, 'default');
                const hasReferenceImage = connectedImages.length > 0;
                
                // 生成提示词
                const gridPrompt = hasReferenceImage
                    ? GRID_PROMPT_TEXT
                    : `生成一张九宫格（3x3 grid）布局的分镜脚本。在9个格子中展示同一个角色不同的动作、表情和拍摄角度（如正面、侧面、背面、特写等）。要求风格高度统一，形成一张完整的角色动态表（Character Sheet）。`;
                
                // 更新节点的提示词，保持模型、分辨率、比例不变
                updateNodeSettings(targetNode.id, { prompt: gridPrompt });
                
                // 提示用户
                alert('已生成九宫格分镜脚本提示词！');
            };

            // 智能拆分放大：直接生成提示词
            const handleUpscale = () => {
                const currentSelectedId = selectedNodeIdRef.current;
                if (!currentSelectedId) {
                    alert('请选择图片生成节点进行放大。');
                    return;
                }
                
                const targetNode = nodesRef.current.find(n => n.id === currentSelectedId);
                if (!targetNode || targetNode.type !== 'gen-image') {
                    alert('请选择图片生成节点进行放大。');
                    return;
                }
                
                const upscalePrompt = UPSCALE_PROMPT_TEXT;
                
                // 更新节点的提示词
                updateNodeSettings(targetNode.id, { prompt: upscalePrompt });
                
                // 提示用户
                alert('已生成高清放大提示词！');
            };

            // 切割九宫格图片（3x3网格）
            const splitGridImage = async (imageUrl) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    const timeout = setTimeout(() => {
                        reject(new Error('图片加载超时'));
                    }, 30000);
                    
                    img.onload = () => {
                        clearTimeout(timeout);
                        try {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // 九宫格是3x3网格，每张图是原图的1/3
                            const singleWidth = Math.floor(img.width / 3);
                            const singleHeight = Math.floor(img.height / 3);
                            
                            const images = [];
                            
                            // 切割9张图：按从上到下、从左到右的顺序（1-9）
                            const cropPromises = [];
                            
                            for (let row = 0; row < 3; row++) {
                                for (let col = 0; col < 3; col++) {
                                    const cropX = Math.max(0, Math.min(col * singleWidth, img.width - singleWidth));
                                    const cropY = Math.max(0, Math.min(row * singleHeight, img.height - singleHeight));
                                    const cropW = Math.min(singleWidth, img.width - cropX);
                                    const cropH = Math.min(singleHeight, img.height - cropY);
                                    
                                    const cropCanvas = document.createElement('canvas');
                                    cropCanvas.width = cropW;
                                    cropCanvas.height = cropH;
                                    const cropCtx = cropCanvas.getContext('2d');
                                    
                                    cropCtx.fillStyle = '#ffffff';
                                    cropCtx.fillRect(0, 0, cropW, cropH);
                                    
                                    cropCtx.drawImage(
                                        img,
                                        cropX, cropY, cropW, cropH,
                                        0, 0, cropW, cropH
                                    );
                                    
                                    // 使用 toBlob 替代 toDataURL，生成 Blob URL
                                    const cropPromise = new Promise((resolveCrop, rejectCrop) => {
                                        cropCanvas.toBlob((blob) => {
                                            if (blob) {
                                                const blobUrl = URL.createObjectURL(blob);
                                                resolveCrop({
                                                    url: blobUrl,
                                                    width: cropW,
                                                    height: cropH
                                                });
                                            } else {
                                                rejectCrop(new Error('Canvas toBlob 失败'));
                                            }
                                        }, 'image/png');
                                    });
                                    
                                    cropPromises.push(cropPromise);
                                }
                            }
                            
                            // 等待所有切割完成
                            Promise.all(cropPromises).then((results) => {
                                resolve(results);
                            }).catch((error) => {
                                reject(error);
                            });
                        } catch (error) {
                            reject(error);
                        }
                    };
                    
                    img.onerror = () => {
                        clearTimeout(timeout);
                        reject(new Error('图片加载失败'));
                    };
                    
                    img.src = imageUrl;
                });
            };

            // 裁切九宫格图片并创建节点
            const handleSplitGridImage = async () => {
                const currentSelectedId = selectedNodeIdRef.current;
                if (!currentSelectedId) {
                    alert('请先选中一个图片节点');
                    return;
                }
                
                const targetNode = nodesRef.current.find(n => n.id === currentSelectedId);
                if (!targetNode) {
                    alert('未找到选中的节点');
                    return;
                }
                
                const imageUrl = targetNode.content;
                if (!imageUrl) {
                    alert('选中的节点没有图片内容');
                    return;
                }
                
                try {
                    // 切割图片
                    const croppedImages = await splitGridImage(imageUrl);
                    
                    if (croppedImages.length !== 9) {
                        alert('切割失败：未能生成9张图片');
                        return;
                    }
                    
                    // 获取原节点的位置和尺寸
                    const sourceX = targetNode.x;
                    const sourceY = targetNode.y;
                    const sourceWidth = targetNode.width || 260;
                    const nodeWidth = 260;
                    const nodeHeight = 260;
                    const spacing = 20;
                    
                    const cols = 3;
                    const rows = 3;
                    
                    // 计算起始位置：位于原图的右侧开始排列
                    const startX = sourceX + sourceWidth + spacing;
                    const startY = sourceY;
                    
                    // 创建9个新节点
                    const newNodes = [];
                    for (let i = 0; i < croppedImages.length; i++) {
                        const row = Math.floor(i / cols);
                        const col = i % cols;
                        const x = startX + col * (nodeWidth + spacing);
                        const y = startY + row * (nodeHeight + spacing);
                        
                        const newNode = {
                            id: `node-${Date.now()}-${i}`,
                            type: 'input-image',
                            x: x,
                            y: y,
                            width: nodeWidth,
                            height: nodeHeight,
                            content: croppedImages[i].url,
                            dimensions: { w: croppedImages[i].width, h: croppedImages[i].height }
                        };
                        newNodes.push(newNode);
                    }
                    
                    setNodes(prev => [...prev, ...newNodes]);
                    // 静默创建，不显示成功提示
                } catch (error) {
                    alert('切割失败: ' + error.message);
                }
            };

            const handleSplitGridFromUrl = async (imageUrl, options = {}) => {
                if (!imageUrl) return;
                const {
                    originX,
                    originY,
                    cols = 3,
                    spacing = 20,
                    nodeWidth = 260,
                    nodeHeight = 260,
                    replaceSelected = false, // 是否替换已选中的节点
                } = options;

                try {
                    const croppedImages = await splitGridImage(imageUrl);
                    if (croppedImages.length !== 9) {
                        alert('切割失败：未能生成9张图片');
                        return;
                    }

                    // 检查是否有框选的节点需要替换
                    const currentSelectedIds = selectedNodeIdsRef.current;
                    if (replaceSelected && currentSelectedIds && currentSelectedIds.size === 9) {
                        // 替换模式：更新已选中的9个节点
                        const selectedIdsArray = Array.from(currentSelectedIds);
                        setNodes(prev => prev.map(node => {
                            const index = selectedIdsArray.indexOf(node.id);
                            if (index !== -1 && index < croppedImages.length) {
                                // 替换节点内容，保持位置和大小
                                return {
                                    ...node,
                                    content: croppedImages[index].url,
                                    dimensions: { 
                                        w: croppedImages[index].width, 
                                        h: croppedImages[index].height 
                                    }
                                };
                            }
                            return node;
                        }));
                        // 静默替换，不显示提示
                        return;
                    }

                    // 创建新节点模式（原有逻辑）
                    const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
                    const startX = originX !== undefined ? originX : world.x;
                    const startY = originY !== undefined ? originY : world.y;
                    const newNodes = [];
                    for (let i = 0; i < croppedImages.length; i++) {
                        const row = Math.floor(i / cols);
                        const col = i % cols;
                        const x = startX + col * (nodeWidth + spacing);
                        const y = startY + row * (nodeHeight + spacing);
                        newNodes.push({
                            id: `node-${Date.now()}-${i}`,
                            type: 'input-image',
                            x,
                            y,
                            width: nodeWidth,
                            height: nodeHeight,
                            content: croppedImages[i].url,
                            dimensions: { w: croppedImages[i].width, h: croppedImages[i].height }
                        });
                    }
                    setNodes(prev => [...prev, ...newNodes]);
                    // 静默创建，不显示成功提示
                } catch (e) {
                    alert('切割失败: ' + e.message);
                }
            };

            // 智能整理节点：DAG 层级布局 + 交叉最小化 (Barycenter Heuristic)
            const autoArrangeNodes = () => {
                // 1. 获取选中的节点
                const currentSelectedId = selectedNodeIdRef.current;
                const currentSelectedIds = selectedNodeIdsRef.current;
                
                let nodesToArrange = [];
                
                if (currentSelectedId) {
                    const node = nodesRef.current.find(n => n.id === currentSelectedId);
                    if (node) nodesToArrange = [node];
                } else if (currentSelectedIds && currentSelectedIds.size > 0) {
                    nodesToArrange = nodesRef.current.filter(n => currentSelectedIds.has(n.id));
                }

                if (nodesToArrange.length < 2) {
                     alert('请至少选中两个节点进行智能整理');
                     return;
                }

                const targetNodeIds = new Set(nodesToArrange.map(n => n.id));

                // 2. 构建图结构
                // map: id -> graphNode
                const graph = {}; 
                nodesToArrange.forEach(n => {
                    graph[n.id] = { 
                        id: n.id, 
                        node: n, 
                        parents: [], 
                        children: [], 
                        level: 0,
                        rank: 0 // 用于层内排序
                    };
                });

                connectionsRef.current.forEach(conn => {
                    if (targetNodeIds.has(conn.from) && targetNodeIds.has(conn.to)) {
                        graph[conn.from].children.push(conn.to);
                        graph[conn.to].parents.push(conn.from);
                    }
                });

                // 3. 计算层级 (Assign Layers) - Longest Path Layering
                // 找出入度为0的节点
                let roots = Object.values(graph).filter(n => n.parents.length === 0);
                
                // 处理环路或纯独立节点：如果没有根，取第一个
                if (roots.length === 0 && nodesToArrange.length > 0) {
                    roots = [Object.values(graph)[0]];
                }

                // 计算每个节点的深度 level
                const calcLevels = () => {
                    const queue = roots.map(r => ({ node: r, lvl: 0 }));
                    const visited = new Set();
                    
                    while(queue.length > 0) {
                        const { node, lvl } = queue.shift();
                        // 只有当该节点未访问，或者发现了更长的路径时更新
                        if (lvl >= node.level) {
                            node.level = lvl;
                            // 只有当该节点的所有父节点都处理过，或者它是根节点时，才继续往下（简化版拓扑排序）
                            // 这里为了简单，直接遍历子节点
                            node.children.forEach(childId => {
                                const childNode = graph[childId];
                                if (childNode) {
                                    // 避免环路无限循环：限制最大深度
                                    if (lvl < 20) { 
                                        queue.push({ node: childNode, lvl: lvl + 1 });
                                    }
                                }
                            });
                        }
                    }
                };
                calcLevels();

                // 4. 构建层级数组
                // layers: [ [node, node], [node], ... ]
                const maxLevel = Math.max(...Object.values(graph).map(n => n.level));
                const layers = Array.from({ length: maxLevel + 1 }, () => []);
                
                Object.values(graph).forEach(n => {
                    layers[n.level].push(n);
                });

                // 5. 交叉最小化 (Crossing Minimization) - Iterative Barycenter Method
                // 初始排序：保持目前的相对顺序或ID顺序
                layers.forEach(layer => {
                    layer.sort((a, b) => a.node.y - b.node.y);
                });

                // 迭代次数，比如做 3 次往返扫描
                const iterations = 3; 
                
                for (let i = 0; i < iterations; i++) {
                    // Forward Sweep (从左往右): 子节点跟随父节点的重心
                    for (let l = 1; l < layers.length; l++) {
                        const layer = layers[l];
                        layer.forEach(n => {
                            if (n.parents.length > 0) {
                                let sumRank = 0;
                                n.parents.forEach(pid => {
                                    // 找到父节点在上一层中的索引位置(rank)
                                    const parentNode = graph[pid];
                                    const parentLayerIndex = layers[l-1].indexOf(parentNode);
                                    if (parentLayerIndex !== -1) sumRank += parentLayerIndex;
                                });
                                n.barycenter = sumRank / n.parents.length;
                            } else {
                                n.barycenter = layers[l].indexOf(n); // 保持原位
                            }
                        });
                        // 根据重心排序
                        layer.sort((a, b) => (a.barycenter || 0) - (b.barycenter || 0));
                    }

                    // Backward Sweep (从右往左): 父节点跟随子节点的重心
                    // 这一步对于解决图中的那种"输入节点乱序导致连线交叉"非常关键
                    for (let l = layers.length - 2; l >= 0; l--) {
                        const layer = layers[l];
                        layer.forEach(n => {
                            if (n.children.length > 0) {
                                let sumRank = 0;
                                n.children.forEach(cid => {
                                    const childNode = graph[cid];
                                    const childLayerIndex = layers[l+1].indexOf(childNode);
                                    if (childLayerIndex !== -1) sumRank += childLayerIndex;
                                });
                                n.barycenter = sumRank / n.children.length;
                            } else {
                                n.barycenter = layers[l].indexOf(n);
                            }
                        });
                        layer.sort((a, b) => (a.barycenter || 0) - (b.barycenter || 0));
                    }
                }

                // 6. 计算最终坐标 (Coordinate Assignment)
                const startX = Math.min(...nodesToArrange.map(n => n.x));
                const startY = Math.min(...nodesToArrange.map(n => n.y));
                const H_SPACING = 150; // 加宽一点水平间距，给连线留空间
                const V_SPACING = 40;  // 垂直间距

                let currentX = startX;
                const updatedNodesMap = new Map();

                layers.forEach((layer, lIndex) => {
                    if (layer.length === 0) return;

                    // 计算该层最宽的节点，用于推算下一层的X
                    const maxW = Math.max(...layer.map(n => n.node.width || 260));
                    
                    // 计算该层总高度，用于垂直居中对齐整个层
                    const totalH = layer.reduce((sum, n) => sum + (n.node.height || 200), 0) + (layer.length - 1) * V_SPACING;
                    
                    // 简单的垂直排列，从 startY 开始
                    // 进阶优化：可以让层与层之间垂直中心对齐，但这里简单排列通常就够了
                    let currentY = startY;

                    layer.forEach(graphNode => {
                        updatedNodesMap.set(graphNode.id, {
                            ...graphNode.node,
                            x: currentX,
                            y: currentY
                        });
                        currentY += (graphNode.node.height || 200) + V_SPACING;
                    });

                    currentX += maxW + H_SPACING;
                });

                // 7. 应用更新
                setNodes(prev => prev.map(node => {
                    if (updatedNodesMap.has(node.id)) {
                        return updatedNodesMap.get(node.id);
                    }
                    return node;
                }));
            };

            const handleVideoFileUpload = (nodeId, file) => {
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    const content = ev.target.result;
                    let videoMeta = { duration: 0, w: 0, h: 0 };
                    try { videoMeta = await getVideoMetadata(content); } catch (e) { console.warn('读取视频元信息失败', e); }
                    setNodes((prev) => prev.map((n) => 
                        n.id === nodeId 
                            ? { ...n, content, videoMeta, frames: [], selectedKeyframes: [], extractingFrames: false, videoFileName: file.name } 
                            : n
                    ));
                };
                reader.readAsDataURL(file);
            };

            const handleVideoDrop = (nodeId, e) => {
                e.preventDefault(); e.stopPropagation();
                e.currentTarget.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files);
                const videoFile = files.find(file => file.type.startsWith('video/'));
                if (videoFile) {
                    handleVideoFileUpload(nodeId, videoFile);
                }
            };

            // 智能抽帧：场景检测算法
            const detectScenesAndCapture = async (videoUrl, threshold = 30) => {
                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    video.crossOrigin = "anonymous";
                    video.src = videoUrl;
                    video.muted = true;
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    
                    const keyframes = [];
                    let prevData = null;
                    
                    video.onloadeddata = async () => {
                        canvas.width = 320;
                        canvas.height = Math.floor(320 * (video.videoHeight / video.videoWidth));
                        
                        const duration = video.duration;
                        const sampleRate = 2;
                        
                        video.currentTime = 0;
                        
                        const scan = async () => {
                            // 检查是否已经扫描完成
                            const currentTime = video.currentTime;
                            if (currentTime >= duration || Math.abs(currentTime - duration) < 0.01) {
                                // 确保最后一帧也被包含
                                if (keyframes.length === 0 || parseFloat(keyframes[keyframes.length - 1].time) < duration - 0.5) {
                                    const hdCanvas = document.createElement('canvas');
                                    hdCanvas.width = video.videoWidth;
                                    hdCanvas.height = video.videoHeight;
                                    const hdCtx = hdCanvas.getContext('2d');
                                    video.currentTime = Math.max(0, duration - 0.1);
                                    await new Promise(r => {
                                        const timeout = setTimeout(() => r(), 200);
                                        video.onseeked = () => {
                                            clearTimeout(timeout);
                                            hdCtx.drawImage(video, 0, 0);
                                            const lastTime = Math.max(0, duration - 0.1);
                                            keyframes.push({
                                                time: lastTime.toFixed(2),
                                                image: hdCanvas.toDataURL('image/jpeg', 0.8)
                                            });
                                            r();
                                        };
                                    });
                                }
                                resolve(keyframes.map(kf => ({ time: parseFloat(kf.time), url: kf.image })));
                                return;
                            }
                            
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                            const frameData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                            
                            if (prevData) {
                                let diff = 0;
                                for (let i = 0; i < frameData.length; i += 4) {
                                    diff += Math.abs(frameData[i] - prevData[i]) +
                                            Math.abs(frameData[i+1] - prevData[i+1]) +
                                            Math.abs(frameData[i+2] - prevData[i+2]);
                                }
                                const avgDiff = diff / (frameData.length / 4 * 3);
                                
                                if (avgDiff > threshold) {
                                    const hdCanvas = document.createElement('canvas');
                                    hdCanvas.width = video.videoWidth;
                                    hdCanvas.height = video.videoHeight;
                                    hdCanvas.getContext('2d').drawImage(video, 0, 0);
                                    const dataUrl = hdCanvas.toDataURL('image/jpeg', 0.8);
                                    
                                    // 确保使用实际的currentTime，而不是字符串
                                    const captureTime = video.currentTime;
                                    keyframes.push({
                                        time: captureTime.toFixed(2),
                                        image: dataUrl
                                    });
                                    prevData = null;
                                } else {
                                    prevData = frameData;
                                }
                            } else {
                                // 第一帧，记录当前时间（确保使用实际的currentTime）
                                prevData = frameData;
                                const currentTime = video.currentTime;
                                const hdCanvas = document.createElement('canvas');
                                hdCanvas.width = video.videoWidth;
                                hdCanvas.height = video.videoHeight;
                                hdCanvas.getContext('2d').drawImage(video, 0, 0);
                                keyframes.push({ 
                                    time: currentTime.toFixed(2), 
                                    image: hdCanvas.toDataURL('image/jpeg', 0.8) 
                                });
                            }
                            
                            // 更新到下一个采样点
                            const nextTime = video.currentTime + (1 / sampleRate);
                            if (nextTime >= duration) {
                                // 确保最后一帧也被包含
                                if (keyframes.length === 0 || parseFloat(keyframes[keyframes.length - 1].time) < duration - 0.5) {
                                    const hdCanvas = document.createElement('canvas');
                                    hdCanvas.width = video.videoWidth;
                                    hdCanvas.height = video.videoHeight;
                                    const hdCtx = hdCanvas.getContext('2d');
                                    video.currentTime = Math.max(0, duration - 0.1);
                                    await new Promise(r => {
                                        const timeout = setTimeout(() => r(), 200);
                                        video.onseeked = () => {
                                            clearTimeout(timeout);
                                            hdCtx.drawImage(video, 0, 0);
                                            const lastTime = Math.max(0, duration - 0.1);
                                            keyframes.push({
                                                time: lastTime.toFixed(2),
                                                image: hdCanvas.toDataURL('image/jpeg', 0.8)
                                            });
                                            r();
                                        };
                                    });
                                }
                                resolve(keyframes.map(kf => ({ time: parseFloat(kf.time), url: kf.image })));
                                return;
                            }
                            video.currentTime = nextTime;
                            await new Promise(r => { 
                                const timeout = setTimeout(() => r(), 200); // 超时保护
                                video.onseeked = () => {
                                    clearTimeout(timeout);
                                    r();
                                };
                            });
                            scan();
                        };
                        
                        scan();
                    };
                    
                    video.onerror = (e) => reject(new Error("视频加载失败，请检查格式或跨域设置"));
                });
            };

            const handleAutoExtractKeyframes = async (nodeId, fps = 2) => {
                const node = nodesMap.get(nodeId);
                if (!node?.content) return;
                setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: true } : n));
                try {
                    const frames = await extractKeyFrames(node.content, { fps });
                    setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, frames, selectedKeyframes: [], extractingFrames: false } : n));
                } catch (error) {
                    console.error('视频抽帧失败', error);
                    setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: false } : n));
                }
            };

            const handleSmartExtractKeyframes = async (nodeId, threshold = 30) => {
                const node = nodesMap.get(nodeId);
                if (!node?.content) return;
                setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: true } : n));
                try {
                    const frames = await detectScenesAndCapture(node.content, threshold);
                    setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, frames, selectedKeyframes: [], extractingFrames: false } : n));
                } catch (error) {
                    console.error('智能抽帧失败', error);
                    alert(`智能抽帧失败: ${error.message}`);
                    setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: false } : n));
                }
            };

            // 提取口播文案
            const handleExtractVoiceover = async (nodeId) => {
                const node = nodesMap.get(nodeId);
                if (!node || node.type !== 'video-analyze') return;
                
                const videoInputNode = getConnectedVideoInputNode(nodeId);
                if (!videoInputNode || !videoInputNode.content) {
                    alert('请先连接一个包含视频的视频输入节点');
                    return;
                }
                
                const config = apiConfigs.find((c) => c.id === node.settings?.model || 'gemini-3-pro');
                const apiKey = config?.key || globalApiKey;
                const baseUrl = (config?.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                
                if (!apiKey) {
                    alert('请先在 API 设置中配置 Key');
                    setSettingsOpen(true);
                    return;
                }
                
                setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, isExtractingVoiceover: true, voiceoverResults: [] } : n));
                
                const videoFileName = videoInputNode.videoFileName || 'video.mp4';
                const videoDuration = videoInputNode.videoMeta?.duration || 0;
                
                try {
                    // 构建多模态消息，请求提取口播文案
                    const systemPrompt = `你是一个专业的视频口播文案提取助手。请分析提供的视频，提取每一秒的口播内容。

请返回严格的 JSON 格式，结构如下：
{
  "video_id": "${videoFileName}",
  "duration": ${videoDuration},
  "voiceover": [
    {
      "time": 0,
      "text": "第一秒的口播内容"
    },
    {
      "time": 1,
      "text": "第二秒的口播内容"
    },
    {
      "time": 2,
      "text": "第三秒的口播内容"
    }
  ]
}

要求：
1. 按秒为单位提取口播内容
2. 如果某一秒没有口播，text 字段为空字符串
3. 准确记录每一秒的说话内容
4. 只提取口播文案，不要添加其他描述`;

                    // 从视频中提取关键帧用于分析（每5秒一帧，避免太多）
                    const sampleFrames = [];
                    const video = document.createElement('video');
                    video.crossOrigin = 'anonymous';
                    video.src = videoInputNode.content;
                    video.muted = true;
                    
                    await new Promise((resolve) => {
                        video.onloadedmetadata = () => {
                            const canvas = document.createElement('canvas');
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                            const ctx = canvas.getContext('2d');
                            
                            let currentTime = 0;
                            const extractFrame = async () => {
                                if (currentTime >= videoDuration) {
                                    resolve();
                                    return;
                                }
                                
                                video.currentTime = currentTime;
                                await new Promise((r) => {
                                    video.onseeked = () => {
                                        ctx.drawImage(video, 0, 0);
                                        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                                        sampleFrames.push({
                                            time: currentTime,
                                            url: dataUrl
                                        });
                                        currentTime += 5; // 每5秒一帧
                                        setTimeout(r, 50);
                                    };
                                });
                                extractFrame();
                            };
                            extractFrame();
                        };
                    });
                    
                    // 构建用户消息，包含视频帧
                    const userContent = [
                        { type: "text", text: `请分析以下视频，提取每一秒的口播文案。视频总时长：${videoDuration.toFixed(1)}秒。` }
                    ];
                    
                    // 添加关键帧（每5秒一帧，避免太多）
                    sampleFrames.forEach((frame) => {
                        userContent.push({
                            type: "image_url",
                            image_url: { url: frame.url }
                        });
                        userContent.push({
                            type: "text",
                            text: `时间点：${frame.time.toFixed(1)}秒`
                        });
                    });
                    
                    const apiMessages = [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: userContent }
                    ];
                    
                    const response = await fetch(`${baseUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: config?.modelName || 'gemini-3-pro-preview',
                            messages: apiMessages,
                            stream: false
                        })
                    });
                    
                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(errText || `API Error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const aiContent = data.choices?.[0]?.message?.content || "{}";
                    
                    // 解析 JSON
                    let jsonStr = aiContent.trim();
                    if (jsonStr.startsWith('```')) {
                        jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
                    }
                    
                    let result;
                    try {
                        result = JSON.parse(jsonStr);
                    } catch (e) {
                        console.error('解析 JSON 失败:', e, jsonStr);
                        // 尝试修复
                        try {
                            jsonStr = jsonStr.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*/g, '');
                            jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');
                            result = JSON.parse(jsonStr);
                        } catch (e2) {
                            throw new Error('模型返回的不是有效的 JSON 格式');
                        }
                    }
                    
                    // 更新节点状态
                    setNodes((prev) => prev.map((n) => 
                        n.id === nodeId 
                            ? { ...n, isExtractingVoiceover: false, voiceoverResults: result.voiceover || [] }
                            : n
                    ));
                    
                } catch (error) {
                    console.error('提取口播文案失败', error);
                    setNodes((prev) => prev.map((n) => 
                        n.id === nodeId 
                            ? { ...n, isExtractingVoiceover: false, errorMsg: error.message || '提取口播文案失败' }
                            : n
                    ));
                }
            };

            const handleToggleKeyframe = (nodeId, frame, index = 0, event = null) => {
                const shiftKey = !!event?.shiftKey;
                setNodes(prev => prev.map(n => {
                    if (n.id !== nodeId) return n;
                    const frames = n.frames || [];
                    const keyOf = (f) => `${f.time}-${f.url}`;
                    const frameMap = new Map(frames.map(f => [keyOf(f), f]));
                    const currentSelected = n.selectedKeyframes || [];
                    let nextSelected = [...currentSelected];

                    if (shiftKey && frameSelectionRef.current[nodeId] !== undefined && frameSelectionRef.current[nodeId] !== null && frames.length > 0) {
                        const lastIndex = frameSelectionRef.current[nodeId];
                        const start = Math.min(lastIndex, index);
                        const end = Math.max(lastIndex, index);
                        const rangeFrames = frames.slice(start, end + 1);
                        const selectedKeys = new Set(nextSelected.map(keyOf));
                        rangeFrames.forEach(f => selectedKeys.add(keyOf(f)));
                        nextSelected = Array.from(selectedKeys).map(k => frameMap.get(k)).filter(Boolean);
                    } else {
                        const exists = nextSelected.some(f => keyOf(f) === keyOf(frame));
                        nextSelected = exists 
                            ? nextSelected.filter(f => keyOf(f) !== keyOf(frame))
                            : [...nextSelected, frame];
                    }

                    frameSelectionRef.current[nodeId] = index;
                    return { ...n, selectedKeyframes: nextSelected };
                }));
            };

            const openFrameContextMenu = (e, nodeId, frame) => {
                e.preventDefault();
                e.stopPropagation();
                setFrameContextMenu({ visible: true, x: e.clientX, y: e.clientY, nodeId, frame });
            };

            const closeFrameContextMenu = () => {
                setFrameContextMenu({ visible: false, x: 0, y: 0, nodeId: null, frame: null });
            };

            const sendFrameToChat = () => {
                const { frame } = frameContextMenu;
                if (!frame?.url) return;
                const newFile = {
                    name: `Frame-${(frame.time ?? 0).toFixed(2)}s.png`,
                    type: 'image/png',
                    content: frame.url,
                    isImage: true,
                    isVideo: false,
                    isAudio: false,
                    fromHistory: true,
                    fileExt: 'png'
                };
                setChatFiles(prev => [...prev, newFile]);
                setIsChatOpen(true);
                closeFrameContextMenu();
            };

            const sendFrameToCanvas = async () => {
                const { frame } = frameContextMenu;
                if (!frame?.url) return;
                const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
                let dims;
                try {
                    const real = await getImageDimensions(frame.url);
                    if (real?.w && real?.h) dims = { w: real.w, h: real.h };
                } catch (e) {}
                addNode('input-image', world.x + 50, world.y + 50, null, frame.url, dims);
                closeFrameContextMenu();
            };

            const sendFrameToPreview = () => {
                const { frame } = frameContextMenu;
                if (!frame?.url) return;
                setNodes(prev => {
                    // 优先使用当前选中的预览节点
                    const selectedId = selectedNodeIdRef.current;
                    const selectedIds = selectedNodeIdsRef.current;
                    const previews = prev.filter(n => n.type === 'preview');
                    if (!previews.length) return prev;
                    
                    // 先查找选中的预览节点
                    let targetId = null;
                    if (selectedId) {
                        const selectedPreview = previews.find(p => p.id === selectedId);
                        if (selectedPreview) targetId = selectedPreview.id;
                    }
                    if (!targetId && selectedIds && selectedIds.size > 0) {
                        const selectedPreview = previews.find(p => selectedIds.has(p.id));
                        if (selectedPreview) targetId = selectedPreview.id;
                    }
                    // 如果没有选中预览节点，则默认使用最后一个预览窗口
                    if (!targetId) {
                        targetId = previews[previews.length - 1].id;
                    }

                    return prev.map(n =>
                        n.id === targetId
                            ? { ...n, content: frame.url, previewType: 'image' }
                            : n
                    );
                });
                closeFrameContextMenu();
            };

            const applyFrameToSelectedNode = () => {
                const { frame } = frameContextMenu;
                if (!frame?.url) return;
                const targetId = selectedNodeId;
                const targetNode = nodesMap.get(targetId);
                if (targetNode && targetNode.type === 'input-image') {
                    setNodes(prev => prev.map(n => n.id === targetId ? { ...n, content: frame.url } : n));
                } else {
                    alert('请先选择一个"图片输入"节点');
                }
                closeFrameContextMenu();
            };

            const handleHistoryRightClick = (e, item, imageUrl = null, imageIndex = null) => {
                e.preventDefault();
                e.stopPropagation();
                // 如果提供了 imageUrl 和 imageIndex，说明是点击了多图中的某一张
                // 否则使用 item.url（单图情况）
                const selectedUrl = imageUrl || item.url;
                const selectedIndex = imageIndex !== null ? imageIndex : (item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : null);
                
                // 创建一个修改后的item，使用选中的图片URL
                const menuItem = {
                    ...item,
                    url: selectedUrl,
                    selectedMjImageIndex: selectedIndex
                };
                
                const world = screenToWorld(e.clientX, e.clientY);
                setHistoryContextMenu({ visible: true, x: e.clientX, y: e.clientY, worldX: world.x, worldY: world.y, item: menuItem });
            };

            const applyHistoryToSelectedNode = () => {
                const item = historyContextMenu.item;
                const targetId = selectedNodeId;
                const targetNode = nodesMap.get(targetId);

                if (targetNode && targetNode.type === 'input-image' && item.url) {
                    setNodes(prev => prev.map(n => n.id === targetId ? { ...n, content: item.url } : n));
                } else {
                    alert('请先选择一个"图片输入"节点');
                }
                setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
            };

            const sendHistoryToCanvas = async () => {
                const item = historyContextMenu.item;
                if (!item?.url) return;
                const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
                
                // Fix: Mark video content so input-image node knows to display it properly
                let content = item.url;
                if (item.type === 'video' && !isVideoUrl(content)) {
                     // Append helper param so isVideoUrl returns true
                     content += (content.includes('?') ? '&' : '?') + 'force_video_display=true';
                }
                
                let dims;
                if (item.type === 'image') {
                    try {
                        const real = await getImageDimensions(content);
                        if (real?.w && real?.h) {
                            dims = { w: real.w, h: real.h };
                        }
                    } catch (e) {
                        console.error('SendHistoryToCanvas getImageDimensions error', e);
                    }
                }

                addNode('input-image', world.x + 50, world.y + 50, null, content, dims); 
                setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
            };
            
            const sendHistoryToChat = () => {
                const item = historyContextMenu.item;
                if (!item || !item.url) return;
                
                // 确保正确识别图片和视频类型
                const isImage = item.type === 'image';
                const isVideo = item.type === 'video';
                const fileExt = isImage ? 'png' : (isVideo ? 'mp4' : 'file');
                const mimeType = isImage ? 'image/png' : (isVideo ? 'video/mp4' : 'application/octet-stream');
                
                const newFile = { 
                    name: `Generated-${item.id}.${fileExt}`, 
                    type: mimeType, 
                    content: item.url, 
                    isImage, 
                    isVideo, 
                    isAudio: false, 
                    fromHistory: true,
                    fileExt
                };
                
                setChatFiles(prev => [...prev, newFile]);
                setIsChatOpen(true); 
                setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
            };

            const handlePreviewRightClick = (e, item) => {
                if (!item?.url) return;
                e.preventDefault();
                e.stopPropagation();
                setPreviewContextMenu({ visible: true, x: e.clientX, y: e.clientY, item });
            };
            const closePreviewContextMenu = () => setPreviewContextMenu({ visible: false, x: 0, y: 0, item: null });

            const sendPreviewToChat = () => {
                const item = previewContextMenu.item;
                if (!item?.url) return;
                const isImage = item.type !== 'video';
                const isVideo = item.type === 'video';
                const fileExt = isImage ? 'png' : 'mp4';
                const mimeType = isImage ? 'image/png' : 'video/mp4';
                const newFile = { name: `Preview-${Date.now()}.${fileExt}`, type: mimeType, content: item.url, isImage, isVideo, isAudio: false, fileExt };
                setChatFiles(prev => [...prev, newFile]);
                setIsChatOpen(true);
                closePreviewContextMenu();
            };

            const sendPreviewToCanvas = async () => {
                const item = previewContextMenu.item;
                if (!item?.url) return;
                const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
                let dims = { w: 512, h: 512 };
                try { dims = await getImageDimensions(item.url); } catch (e) { console.warn('Preview dims fail', e); }
                addNode('input-image', world.x + 50, world.y + 50, null, item.url, dims);
                closePreviewContextMenu();
            };

            // 图片输入节点右键菜单处理
            const handleInputImageRightClick = (e, nodeId) => {
                e.preventDefault();
                e.stopPropagation();
                const node = nodesMap.get(nodeId);
                if (!node || !node.content) return;
                setInputImageContextMenu({ visible: true, x: e.clientX, y: e.clientY, nodeId });
            };

            const closeInputImageContextMenu = () => {
                setInputImageContextMenu({ visible: false, x: 0, y: 0, nodeId: null });
            };

            const sendInputImageToChat = () => {
                const nodeId = inputImageContextMenu.nodeId;
                const node = nodesMap.get(nodeId);
                if (!node || !node.content) return;
                
                const isImage = !isVideoUrl(node.content);
                const isVideo = isVideoUrl(node.content);
                const fileExt = isImage ? 'png' : 'mp4';
                const mimeType = isImage ? 'image/png' : 'video/mp4';
                const newFile = { 
                    name: `InputImage-${Date.now()}.${fileExt}`, 
                    type: mimeType, 
                    content: node.content, 
                    isImage, 
                    isVideo, 
                    isAudio: false, 
                    fileExt 
                };
                setChatFiles(prev => [...prev, newFile]);
                setIsChatOpen(true);
                closeInputImageContextMenu();
            };

            // ... (rest of render logic unchanged) ...
            // ConnectionLayer 组件：提取连接线渲染逻辑，使用 React.memo 优化
            const ConnectionLayer = memo(({ 
                connections, 
                nodesMap, 
                connectionsByNode, 
                connectingSource, 
                connectingTarget, 
                connectingInputType, 
                mousePos, 
                apiConfigsMap, 
                selectedNodeId, 
                onDisconnectConnection,
                visibleNodes 
            }) => {
                // 连接线虚拟化：只渲染可见节点的连接线
                const visibleNodeIds = useMemo(() => {
                    return new Set(visibleNodes.map(n => n.id));
                }, [visibleNodes]);
                
                const visibleConnections = useMemo(() => {
                    return connections.filter(conn => 
                        visibleNodeIds.has(conn.from) || visibleNodeIds.has(conn.to)
                    );
                }, [connections, visibleNodeIds]);
                
                return (
                    <div className="absolute inset-0 pointer-events-none overflow-visible w-full h-full">
                        <svg className="absolute inset-0 overflow-visible w-full h-full">
                            {visibleConnections.map((conn) => {
                                // 使用 nodesMap 快速查找，O(1) 复杂度
                                const fromNode = nodesMap.get(conn.from);
                                const toNode = nodesMap.get(conn.to);
                                if (!fromNode || !toNode) return null;
                                
                                // 检查连接线是否与选中节点相关
                                const isRelatedToSelected = selectedNodeId && (
                                    fromNode.id === selectedNodeId || 
                                    toNode.id === selectedNodeId
                                );
                                // 设置透明度：选中节点相关为100%，其他为35%
                                const opacity = isRelatedToSelected ? 1 : 0.35;
                                
                                const startX = fromNode.x + fromNode.width - 4;
                                const startY = fromNode.y + fromNode.height / 2;
                                const endX = toNode.x + 4;
                                let endY = toNode.y + toNode.height / 2;

                                // 处理image-compare节点的多个输入点
                                if (toNode.type === 'image-compare') {
                                    // 使用缓存的 connectionsByNode，避免重复 filter
                                    const relevantConns = connectionsByNode.to.get(toNode.id) || [];
                                    const idx = relevantConns.findIndex(c => c.id === conn.id);
                                    if (idx === 0) endY = toNode.y + toNode.height * 0.33;
                                    else if (idx >= 1) endY = toNode.y + toNode.height * 0.66;
                                }
                                
                                // 处理Midjourney节点的oref和sref输入点
                                // 检查inputType是否为oref或sref（注意：default连接时inputType可能是undefined）
                                if (toNode.type === 'gen-image' && (conn.inputType === 'oref' || conn.inputType === 'sref')) {
                                    const currentModel = apiConfigsMap.get(toNode.settings?.model);
                                    const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                    
                                    if (isMidjourney) {
                                        // 使用基于节点世界坐标的计算，考虑实际DOM结构
                                        // 节点结构：p-3(12px) + 计时器(如果有，约28px + mb-2=8px) + 标题(约16px + mb-2=8px) + 引用状态区域(如果有，约60px + mb-2=8px) + 提示词区域(约100px + mb-2=8px) + 指令区域
                                        // 指令区域：gap-1.5(6px) + oref项(约16px) + gap-1.5(6px) + ow项(约16px + input高度) + gap-1.5(6px) + sref项(约16px)
                                        const paddingTop = 12; // 节点顶部padding (p-3 = 12px)
                                        const timerHeight = 28; // 计时器区域高度（px-2 py-1 + text-[10px] ≈ 28px）
                                        const timerMarginBottom = 8; // 计时器下方margin (mb-2 = 8px)
                                        const titleHeight = 16; // 标题高度 (text-xs ≈ 12px + line-height ≈ 16px，flex items-center)
                                        const titleMarginBottom = 8; // 标题下方margin (mb-2 = 8px)
                                        const refAreaHeight = 60; // 引用状态区域高度（p-2 + 内容，约60px）
                                        const refAreaMarginBottom = 8; // 引用区域下方margin (mb-2 = 8px)
                                        const promptAreaHeight = 100; // 提示词区域高度（p-3 + textarea，约100px）
                                        const promptAreaMarginBottom = 8; // 提示词区域下方margin (mb-2 = 8px)
                                        const instructionGap = 6; // 指令项之间的gap (gap-1.5 = 6px)
                                        const instructionItemHeight = 16; // 每个指令项的实际高度（text-[10px] + flex items-center ≈ 16px）
                                        const owInputHeight = 28; // ow输入框高度（px-2 py-1 + text-[10px] ≈ 28px）
                                        
                                        // 检查是否有计时器（正在生成或已完成）
                                        const hasTimer = false; // 计时器是动态的，这里简化处理，实际应该从节点状态判断
                                        
                                        // 使用缓存的 connectionsByNode，避免重复 some 计算
                                        const toNodeConns = connectionsByNode.to.get(toNode.id) || [];
                                        const hasRefArea = toNodeConns.some(c => !c.inputType || c.inputType === 'default');
                                        
                                        // 计算基础偏移（到指令区域开始的位置）
                                        let baseOffset = paddingTop;
                                        if (hasTimer) {
                                            baseOffset += timerHeight + timerMarginBottom;
                                        }
                                        baseOffset += titleHeight + titleMarginBottom;
                                        if (hasRefArea) {
                                            baseOffset += refAreaHeight + refAreaMarginBottom;
                                        }
                                        baseOffset += promptAreaHeight + promptAreaMarginBottom;
                                        
                                        if (conn.inputType === 'oref') {
                                            // oref在第一个指令位置（第一个指令项的中心）
                                            // 指令区域开始 + 第一个指令项的中心
                                            endY = toNode.y + baseOffset + instructionItemHeight * 0.5;
                                        } else if (conn.inputType === 'sref') {
                                            // sref在第三个指令位置
                                            // 指令区域开始 + oref项(16px) + gap(6px) + ow项(owInputHeight ≈ 28px) + gap(6px) + sref项的中心(8px)
                                            endY = toNode.y + baseOffset + instructionItemHeight + instructionGap + owInputHeight + instructionGap + instructionItemHeight * 0.5;
                                        }
                                    }
                                }

                                const dist = Math.abs(endX - startX);
                                const cp1X = startX + dist * 0.5;
                                const cp2X = endX - dist * 0.5;
                                return (
                                    <g key={conn.id} className="connection-group" style={{ opacity }}>
                                        <path d={`M ${startX} ${startY} C ${cp1X} ${startY}, ${cp2X} ${endY}, ${endX} ${endY}`} stroke="transparent" strokeWidth="20" fill="none" style={{pointerEvents: 'stroke'}} />
                                        <path d={`M ${startX} ${startY} C ${cp1X} ${startY}, ${cp2X} ${endY}, ${endX} ${endY}`} stroke="#18181b" strokeWidth="4" fill="none" />
                                        <path d={`M ${startX} ${startY} C ${cp1X} ${startY}, ${cp2X} ${endY}, ${endX} ${endY}`} stroke="#71717a" strokeWidth="2" fill="none" />
                                        <circle cx={startX} cy={startY} r="2" fill="#71717a" />
                                        <circle cx={endX} cy={endY} r="2" fill="#71717a" />
                                        <g className="connection-delete cursor-pointer" style={{ opacity: isRelatedToSelected ? 1 : 0.35 }} onClick={() => onDisconnectConnection(conn.id)}>
                                            <circle cx={(startX + endX) / 2} cy={(startY + endY) / 2} r="8" fill="#ef4444" />
                                            <Unlink size={10} className="text-white" x={(startX + endX) / 2 - 5} y={(startY + endY) / 2 - 5} />
                                        </g>
                                    </g>
                                );
                            })}
                            {connectingSource && (() => {
                                // 使用 nodesMap 快速查找
                                const node = nodesMap.get(connectingSource);
                                if (!node) return null;
                                return <path d={`M ${node.x + node.width - 4} ${node.y + node.height / 2} C ${node.x + node.width + 100} ${node.y + node.height / 2}, ${mousePos.x - 100} ${mousePos.y}, ${mousePos.x} ${mousePos.y}`} stroke="#60a5fa" strokeWidth="2" fill="none" strokeDasharray="4,4" />;
                            })()}
                            {connectingTarget && (() => {
                                // 使用 nodesMap 快速查找
                                const node = nodesMap.get(connectingTarget);
                                if (!node) return null;
                            // 从输入端口向左拖拽，连接线从左侧开始
                            const startX = node.x + 4;
                            let startY = node.y + node.height / 2;
                            
                            // 处理Midjourney节点的oref和sref输入点
                            if (node.type === 'gen-image' && connectingInputType) {
                                const currentModel = apiConfigsMap.get(node.settings?.model);
                                const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                
                                if (isMidjourney) {
                                    // 使用与连接线渲染相同的计算逻辑
                                    const paddingTop = 12;
                                    const timerHeight = 28;
                                    const timerMarginBottom = 8;
                                    const titleHeight = 16; // 标题高度 (text-xs ≈ 12px + line-height ≈ 16px)
                                    const titleMarginBottom = 8;
                                    const refAreaHeight = 60;
                                    const refAreaMarginBottom = 8;
                                    const promptAreaHeight = 100;
                                    const promptAreaMarginBottom = 8;
                                    const instructionGap = 6;
                                    const instructionItemHeight = 16; // 每个指令项的实际高度（text-[10px] + flex items-center ≈ 16px）
                                    const owInputHeight = 28; // ow输入框高度（px-2 py-1 + text-[10px] ≈ 28px）
                                    
                                    const hasTimer = false; // 计时器是动态的，这里简化处理
                                    // 使用缓存的 connectionsByNode，避免重复 some 计算
                                    const toNodeConns = connectionsByNode.to.get(node.id) || [];
                                    const hasRefArea = toNodeConns.some(c => !c.inputType || c.inputType === 'default');
                                    
                                    let baseOffset = paddingTop;
                                    if (hasTimer) {
                                        baseOffset += timerHeight + timerMarginBottom;
                                    }
                                    baseOffset += titleHeight + titleMarginBottom;
                                    if (hasRefArea) {
                                        baseOffset += refAreaHeight + refAreaMarginBottom;
                                    }
                                    baseOffset += promptAreaHeight + promptAreaMarginBottom;
                                    
                                    if (connectingInputType === 'oref') {
                                        startY = node.y + baseOffset + instructionItemHeight * 0.5;
                                    } else if (connectingInputType === 'sref') {
                                        // sref在第三个指令位置：oref项(16px) + gap(6px) + ow项(owInputHeight ≈ 28px) + gap(6px) + sref项的中心(8px)
                                        startY = node.y + baseOffset + instructionItemHeight + instructionGap + owInputHeight + instructionGap + instructionItemHeight * 0.5;
                                    }
                                }
                            }
                            // 处理image-compare节点的多个输入点
                            else if (node.type === 'image-compare') {
                                // 这里可以根据鼠标位置判断是哪个输入点，暂时使用中间位置
                                startY = node.y + node.height / 2;
                            }
                            
                            return <path d={`M ${startX} ${startY} C ${startX - 100} ${startY}, ${mousePos.x + 100} ${mousePos.y}, ${mousePos.x} ${mousePos.y}`} stroke="#60a5fa" strokeWidth="2" fill="none" strokeDasharray="4,4" />;
                        })()}
                    </svg>
                </div>
            );
            }, (prevProps, nextProps) => {
                // 自定义对比函数：仅当 connections 数组、可见节点或相关选中状态变化时才重渲染
                return (
                    prevProps.connections === nextProps.connections &&
                    prevProps.visibleNodes === nextProps.visibleNodes &&
                    prevProps.selectedNodeId === nextProps.selectedNodeId &&
                    prevProps.connectingSource === nextProps.connectingSource &&
                    prevProps.connectingTarget === nextProps.connectingTarget &&
                    prevProps.connectingInputType === nextProps.connectingInputType &&
                    prevProps.mousePos.x === nextProps.mousePos.x &&
                    prevProps.mousePos.y === nextProps.mousePos.y
                );
            });

            // 使用 useMemo 优化连接线渲染函数，避免重复查找和计算
            const renderConnections = useCallback(() => {
                return (
                    <ConnectionLayer
                        connections={connections}
                        nodesMap={nodesMap}
                        connectionsByNode={connectionsByNode}
                        connectingSource={connectingSource}
                        connectingTarget={connectingTarget}
                        connectingInputType={connectingInputType}
                        mousePos={mousePos}
                        apiConfigsMap={apiConfigsMap}
                        selectedNodeId={selectedNodeId}
                        onDisconnectConnection={disconnectConnection}
                        visibleNodes={visibleNodes}
                    />
                );
            }, [connections, nodesMap, connectionsByNode, connectingSource, connectingTarget, connectingInputType, mousePos, apiConfigsMap, selectedNodeId, disconnectConnection, visibleNodes]);

            // 使用 useMemo 缓存节点的连接状态，避免每次渲染时重复计算
            const nodeConnectedStatus = useMemo(() => {
                const status = new Map(); // nodeId -> boolean
                connections.forEach(conn => {
                    if (!conn.inputType || conn.inputType === 'default') {
                        status.set(conn.to, true);
                    }
                });
                return status;
            }, [connections]);

            // 功能3：获取相邻节点（上游和下游）- 使用缓存的连接映射优化性能
            const getAdjacentNodes = useCallback((nodeId) => {
                const adjacent = new Set();
                const fromConns = connectionsByNode.from.get(nodeId) || [];
                const toConns = connectionsByNode.to.get(nodeId) || [];
                fromConns.forEach(conn => adjacent.add(conn.to));
                toConns.forEach(conn => adjacent.add(conn.from));
                return adjacent;
            }, [connectionsByNode]);
            
            // 缓存相邻节点集合，避免在renderNode中重复计算
            const adjacentNodesCache = useMemo(() => {
                const cache = new Map();
                if (selectedNodeId || selectedNodeIds.size > 0) {
                    const selectedId = selectedNodeId || (selectedNodeIds.size === 1 ? Array.from(selectedNodeIds)[0] : null);
                    if (selectedId) {
                        cache.set(selectedId, getAdjacentNodes(selectedId));
                    }
                }
                return cache;
            }, [selectedNodeId, selectedNodeIds, getAdjacentNodes]);

            // NodeItem 组件：提取节点渲染逻辑，使用 React.memo 优化
            // 注意：由于 renderNode 的 JSX 内容非常长（约 2700 行），完整提取需要大量工作
            // 我们采用更实用的方法：保持 renderNode 函数的结构，但通过 React.memo 优化
            // 关键优化点：
            // 1. 所有回调函数都使用 useCallback 优化（已完成）
            // 2. ConnectionLayer 已提取并优化（已完成）
            // 3. CSS 渲染优化（已完成）
            // 4. 通过计算 props 减少不必要的重渲染

            const renderNode = useCallback((node) => {
                // LOD (Level of Detail) 阈值
                const LOD_THRESHOLD = 0.4;
                const isLowDetail = view.zoom < LOD_THRESHOLD;
                
                const isSelected = selectedNodeId === node.id || selectedNodeIds.has(node.id);
                const connectedImages = getConnectedInputImages(node.id);
                const isHoverTarget = hoverTargetId === node.id;
                // 使用缓存的连接状态，O(1) 查找
                const isConnected = nodeConnectedStatus.get(node.id) || false;
                
                // 功能3：检查是否为相邻节点（当有节点被选中时）- 使用缓存的相邻节点集合
                const selectedId = selectedNodeId || (selectedNodeIds.size === 1 ? Array.from(selectedNodeIds)[0] : null);
                const adjacentSet = selectedId ? adjacentNodesCache.get(selectedId) : null;
                const isAdjacent = selectedId && selectedId !== node.id && adjacentSet && adjacentSet.has(node.id);
                
                // 判断是否为Nano Banana 2模型 - 使用 Map 优化查找（O(1)）
                const currentModel = apiConfigsMap.get(node.settings?.model);
                const isNanoBanana2 = currentModel
                    ? ((currentModel.modelName || currentModel.id || '').includes('nano-banana-2'))
                    : ((node.settings?.model || '').includes('nano-banana-2'));

                // 低细节模式：只渲染核心内容
                if (isLowDetail) {
                    return (
                        <div
                            key={node.id}
                            data-node-id={node.id}
                            className={`absolute node-wrapper flex flex-col ${
                                isSelected
                                    ? 'ring-1 ring-blue-500'
                                    : theme === 'dark'
                                        ? 'border border-zinc-800'
                                        : 'border border-zinc-200'
                            } ${theme === 'dark' ? 'bg-[#18181b]' : 'bg-white'}`}
                            style={{ 
                                left: node.x, 
                                top: node.y, 
                                width: node.width, 
                                height: node.height, 
                                cursor: (dragNodeId === node.id || (dragNodeId && selectedNodeIds.has(node.id))) ? 'grabbing' : 'default', 
                                zIndex: 10,
                                border: `1px solid ${theme === 'dark' ? '#3f3f46' : '#e4e4e7'}`,
                                background: theme === 'dark' ? '#18181b' : '#fff',
                                boxShadow: 'none',
                                borderRadius: '0',
                                transform: 'translateZ(0)',
                                backfaceVisibility: 'hidden'
                            }}
                            onMouseDown={(e) => { 
                                if (e.button === 0) { 
                                    e.stopPropagation(); 
                                    if (e.ctrlKey || e.metaKey) {
                                        setSelectedNodeIds(prev => {
                                            const newSet = new Set(prev);
                                            if (newSet.has(node.id)) {
                                                newSet.delete(node.id);
                                            } else {
                                                newSet.add(node.id);
                                            }
                                            if (newSet.size === 1) {
                                                setSelectedNodeId(Array.from(newSet)[0]);
                                            } else {
                                                setSelectedNodeId(null);
                                            }
                                            return newSet;
                                        });
                                    } else {
                                        const isAlreadySelected = selectedNodeIds.has(node.id);
                                        if (isAlreadySelected && selectedNodeIds.size > 1) {
                                            setSelectedNodeId(node.id);
                                        } else {
                                            setSelectedNodeId(node.id);
                                            setSelectedNodeIds(new Set([node.id]));
                                        }
                                    }
                                    setDragNodeId(node.id); 
                                } 
                            }}
                            onMouseEnter={() => { if (connectingSource || connectingTarget) setHoverTargetId(node.id); }}
                            onMouseLeave={() => { if ((connectingSource || connectingTarget) && hoverTargetId === node.id) setHoverTargetId(null); }}
                            onMouseUp={(e) => handleNodeMouseUp(node.id, e)}
                        >
                            {/* 仅显示核心图片/视频 */}
                            {node.type === 'input-image' && node.content && (
                                <div className="w-full h-full relative">
                                    {isVideoUrl(node.content) ? (
                                        <video 
                                            src={node.content} 
                                            className="w-full h-full object-cover opacity-80" 
                                            muted
                                            playsInline
                                        />
                                    ) : (
                                        <LazyBase64Image
                                            src={node.content}
                                            className="w-full h-full object-cover opacity-80"
                                            alt=""
                                        />
                                    )}
                                </div>
                            )}
                            {node.type === 'video-input' && node.content && (
                                <video 
                                    src={node.content} 
                                    className="w-full h-full object-cover opacity-80" 
                                    muted
                                    playsInline
                                />
                            )}
                            {!node.content && (
                                <div className={`p-2 font-bold text-sm truncate ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                    {node.type === 'input-image' ? '图片' : 
                                     node.type === 'video-input' ? '视频' : 
                                     node.type === 'gen-image' ? '生成图片' : 
                                     node.type === 'gen-video' ? '生成视频' : 
                                     node.type === 'text-node' ? '文字' : 
                                     node.type === 'preview' ? '预览' : 
                                     node.type || '节点'}
                                </div>
                            )}
                            
                            {/* 保留连接点占位符，确保连线位置正确（简化样式） */}
                            {node.type !== 'input-image' && node.type !== 'video-input' && node.type !== 'video-analyze' && node.type !== 'preview' && (
                                node.type === 'image-compare' ? (
                                    <>
                                        <div 
                                            className="input-point" 
                                            style={{ 
                                                top: '33%', 
                                                left: '-0.25rem',
                                                width: '0.5rem',
                                                height: '0.5rem',
                                                backgroundColor: isConnected ? '#60a5fa' : '#52525b',
                                                borderRadius: '50%',
                                                position: 'absolute',
                                                zIndex: 20,
                                                pointerEvents: 'auto'
                                            }}
                                            onMouseDown={(e) => { 
                                                e.stopPropagation(); 
                                                e.preventDefault(); 
                                                const world = screenToWorld(e.clientX, e.clientY);
                                                setMousePos(world); 
                                                setConnectingTarget(node.id); 
                                                setConnectingInputType('default'); 
                                            }}
                                            onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')} 
                                        />
                                        <div 
                                            className="input-point" 
                                            style={{ 
                                                top: '66%', 
                                                left: '-0.25rem',
                                                width: '0.5rem',
                                                height: '0.5rem',
                                                backgroundColor: isConnected ? '#60a5fa' : '#52525b',
                                                borderRadius: '50%',
                                                position: 'absolute',
                                                zIndex: 20,
                                                pointerEvents: 'auto'
                                            }}
                                            onMouseDown={(e) => { 
                                                e.stopPropagation(); 
                                                e.preventDefault(); 
                                                const world = screenToWorld(e.clientX, e.clientY);
                                                setMousePos(world); 
                                                setConnectingTarget(node.id); 
                                                setConnectingInputType('default'); 
                                            }}
                                            onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')} 
                                        />
                                    </>
                                ) : (
                                    <div 
                                        className="input-point" 
                                        style={{ 
                                            top: '50%', 
                                            left: '-0.25rem',
                                            width: '0.5rem',
                                            height: '0.5rem',
                                            backgroundColor: isConnected ? '#60a5fa' : '#52525b',
                                            borderRadius: '50%',
                                            position: 'absolute',
                                            zIndex: 20,
                                            pointerEvents: 'auto'
                                        }}
                                        onMouseDown={(e) => { 
                                            e.stopPropagation(); 
                                            e.preventDefault(); 
                                            const world = screenToWorld(e.clientX, e.clientY);
                                            setMousePos(world); 
                                            setConnectingTarget(node.id); 
                                            setConnectingInputType('default'); 
                                        }}
                                        onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')} 
                                    />
                                )
                            )}
                            {node.type !== 'preview' && (
                                <div
                                    className="connector connector-right"
                                    style={{
                                        position: 'absolute',
                                        top: '50%',
                                        right: '-0.45rem',
                                        width: '0.9rem',
                                        height: '0.9rem',
                                        backgroundColor: connectingSource === node.id ? '#d4d4d8' : '#27272a',
                                        border: '1px solid #71717a',
                                        borderRadius: '50%',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        cursor: 'crosshair',
                                        zIndex: 30,
                                        opacity: connectingSource === node.id ? 1 : 0.5,
                                        pointerEvents: 'auto'
                                    }}
                                    onMouseDown={(e) => { 
                                        e.stopPropagation(); 
                                        e.preventDefault(); 
                                        const world = screenToWorld(e.clientX, e.clientY);
                                        setMousePos(world); 
                                        setConnectingSource(node.id); 
                                    }}
                                >
                                    <Plus size={10} />
                                </div>
                            )}
                        </div>
                    );
                }

                // 高细节模式：完整渲染逻辑
                return (
                    <div
                        key={node.id}
                        data-node-id={node.id}
                        className={`absolute rounded-xl shadow-xl transition-shadow duration-150 group flex flex-col node-wrapper ${
                            isSelected
                                ? 'ring-1 ring-blue-500 shadow-blue-500/20'
                                : isAdjacent
                                    ? 'ring-2 ring-blue-300/60 shadow-blue-300/30'
                                    : theme === 'dark'
                                        ? 'border border-zinc-800 shadow-black/40'
                                        : 'border border-zinc-200 shadow-black/10'
                        } ${isHoverTarget && ((connectingSource && connectingSource !== node.id) || (connectingTarget && connectingTarget !== node.id)) ? 'ring-2 ring-green-500/50' : ''} ${
                            theme === 'dark' ? 'bg-[#18181b]' : 'bg-white'
                        }`}
                        style={{ 
                            left: node.x, 
                            top: node.y, 
                            width: node.width, 
                            height: node.height, 
                            cursor: (dragNodeId === node.id || (dragNodeId && selectedNodeIds.has(node.id))) ? 'grabbing' : 'default', 
                            zIndex: 10,
                            WebkitFontSmoothing: 'antialiased',
                            MozOsxFontSmoothing: 'grayscale',
                            textRendering: 'optimizeLegibility',
                            transform: 'translateZ(0)',
                            backfaceVisibility: 'hidden'
                        }}
                        onMouseDown={(e) => { 
                            if (e.button === 0) { 
                                e.stopPropagation(); 
                                // 如果按住了Ctrl键，添加到多选
                                if (e.ctrlKey || e.metaKey) {
                                    setSelectedNodeIds(prev => {
                                        const newSet = new Set(prev);
                                        if (newSet.has(node.id)) {
                                            newSet.delete(node.id);
                                        } else {
                                            newSet.add(node.id);
                                        }
                                        // 如果多选集合为空或只有一个，更新selectedNodeId
                                        if (newSet.size === 1) {
                                            setSelectedNodeId(Array.from(newSet)[0]);
                                        } else {
                                            setSelectedNodeId(null);
                                        }
                                        return newSet;
                                    });
                                } else {
                                    // 如果没有按住Ctrl，检查该节点是否已经在多选集合中
                                    const isAlreadySelected = selectedNodeIds.has(node.id);
                                    if (isAlreadySelected && selectedNodeIds.size > 1) {
                                        // 如果节点已经在多选集合中，保持多选状态，不重置
                                        // 只更新 selectedNodeId 为当前节点（用于显示详情等）
                                        setSelectedNodeId(node.id);
                                    } else {
                                        // 单选模式：重置为只选中当前节点
                                        setSelectedNodeId(node.id);
                                        setSelectedNodeIds(new Set([node.id]));
                                    }
                                }
                                setDragNodeId(node.id); 
                                setActiveDropdown(null); 
                            } 
                        }}
                        onMouseEnter={() => { if (connectingSource || connectingTarget) setHoverTargetId(node.id); }}
                        onMouseLeave={() => { if ((connectingSource || connectingTarget) && hoverTargetId === node.id) setHoverTargetId(null); }}
                        onMouseUp={(e) => handleNodeMouseUp(node.id, e)}
                        onDoubleClick={(e) => {
                            // 功能6：双击图片或视频节点显示预览弹窗
                            if ((node.type === 'input-image' || node.type === 'video-input') && node.content) {
                                e.stopPropagation();
                                setLightboxItem({ url: node.content, type: isVideoUrl(node.content) ? 'video' : 'image' });
                            }
                        }}
                    >
                        <button
                            onClick={(e) => { e.stopPropagation(); deleteNode(node.id); }}
                            className={`absolute -top-2.5 -right-2.5 z-50 p-1 rounded-full shadow border opacity-0 group-hover:opacity-100 transition-opacity scale-90 hover:scale-100 ${
                                theme === 'dark'
                                    ? 'bg-zinc-800 text-zinc-400 hover:text-red-500 hover:bg-zinc-700 border-zinc-700'
                                    : 'bg-zinc-100 text-zinc-500 hover:text-red-500 hover:bg-zinc-200 border-zinc-300'
                            }`}
                            onMouseDown={(e) => e.stopPropagation()}
                        >
                            <X size={12} />
                        </button>
                        <div className="absolute bottom-1 right-1 w-4 h-4 z-[100] resize-handle flex items-end justify-end p-0.5" onMouseDown={(e) => { e.stopPropagation(); e.preventDefault(); setResizingNodeId(node.id); }}><svg width="6" height="6" viewBox="0 0 8 8" fill="none" className="text-zinc-600"><path d="M8 0L8 8L0 8" stroke="currentColor" strokeWidth="2" /></svg></div>
                        
                        {node.type !== 'input-image' && node.type !== 'video-input' && node.type !== 'video-analyze' && node.type !== 'preview' && (
                            node.type === 'image-compare' ? (
                                <>
                                    <div 
                                        className={`input-point ${connectingTarget === node.id && !connectingInputType ? 'active' : ''}`} 
                                        style={{ top: '33%' }} 
                                        title="图 1 输入" 
                                        onMouseDown={(e) => { 
                                            e.stopPropagation(); 
                                            e.preventDefault(); 
                                            // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                                            const world = screenToWorld(e.clientX, e.clientY);
                                            setMousePos(world); 
                                            setConnectingTarget(node.id); 
                                            setConnectingInputType('default'); 
                                        }}
                                        onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')} 
                                    />
                                    <div 
                                        className={`input-point ${connectingTarget === node.id && !connectingInputType ? 'active' : ''}`} 
                                        style={{ top: '66%' }} 
                                        title="图 2 输入" 
                                        onMouseDown={(e) => { 
                                            e.stopPropagation(); 
                                            e.preventDefault(); 
                                            // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                                            const world = screenToWorld(e.clientX, e.clientY);
                                            setMousePos(world); 
                                            setConnectingTarget(node.id); 
                                            setConnectingInputType('default'); 
                                        }}
                                        onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')} 
                                    />
                                </>
                            ) : (
                                <div 
                                    className={`input-point ${isConnected ? 'connected' : ''} ${connectingTarget === node.id && !connectingInputType ? 'active' : ''}`} 
                                    title="输入" 
                                    onMouseDown={(e) => { 
                                        e.stopPropagation(); 
                                        e.preventDefault(); 
                                        // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                                        const world = screenToWorld(e.clientX, e.clientY);
                                        setMousePos(world); 
                                        setConnectingTarget(node.id); 
                                        setConnectingInputType('default'); 
                                    }}
                                    onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')} 
                                />
                            )
                        )}
                        
                        {node.type !== 'preview' && (
                            <div
                                className={`connector connector-right ${connectingSource === node.id ? 'active' : ''} ${connectingTarget && hoverTargetId === node.id ? 'ring-2 ring-green-500/50' : ''}`}
                                title="输出"
                                onMouseDown={(e) => { 
                                    e.stopPropagation(); 
                                    e.preventDefault(); 
                                    // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                                    const world = screenToWorld(e.clientX, e.clientY);
                                    setMousePos(world); 
                                    setConnectingSource(node.id); 
                                }}
                                onMouseEnter={() => { if (connectingTarget) setHoverTargetId(node.id); }}
                                onMouseLeave={() => { if (connectingTarget && hoverTargetId === node.id) setHoverTargetId(null); }}
                            >
                                <Plus size={10} />
                            </div>
                        )}
                        

                        <div
                            className={`overflow-hidden rounded-xl flex-1 flex flex-col pointer-events-none h-full w-full relative ${
                                theme === 'dark' ? 'bg-[#18181b]' : 'bg-white'
                            }`}
                        >
                            {node.type === 'input-image' && (
                                <div
                                    className={`relative w-full h-full flex flex-col items-center justify-center transition-colors pointer-events-auto drop-zone ${
                                        theme === 'dark'
                                            ? 'bg-zinc-900 group-hover:bg-zinc-800'
                                            : 'bg-zinc-100 group-hover:bg-zinc-200'
                                    }`}
                                    onDrop={(e) => handleDrop(node.id, e)}
                                    onDragOver={handleDragOver}
                                    onDragLeave={handleDragLeave}
                                    onContextMenu={(e) => handleInputImageRightClick(e, node.id)}
                                >
                                    {node.content ? (
                                        <div className="relative w-full h-full">
                                            {isVideoUrl(node.content) ? (
                                                 <video 
                                                    src={node.content} 
                                                    controls 
                                                    className="w-full h-full object-contain bg-black/50" 
                                                    draggable={false}
                                                    style={{
                                                        imageRendering: view.zoom >= 1 ? 'auto' : 'crisp-edges',
                                                        WebkitFontSmoothing: 'antialiased',
                                                        transform: 'translateZ(0)',
                                                        backfaceVisibility: 'hidden',
                                                        WebkitBackfaceVisibility: 'hidden'
                                                    }}
                                                />
                                            ) : (
                                                 <img 
                                                    src={node.content} 
                                                    className="w-full h-full object-contain bg-black/50" 
                                                    draggable={false}
                                                    loading="lazy"
                                                    style={{
                                                        imageRendering: view.zoom >= 1 ? 'auto' : 'crisp-edges',
                                                        WebkitFontSmoothing: 'antialiased',
                                                        transform: 'translateZ(0)',
                                                        backfaceVisibility: 'hidden',
                                                        WebkitBackfaceVisibility: 'hidden'
                                                    }}
                                                />
                                            )}
                                            {node.dimensions && (
                                                <div
                                                    className={`absolute bottom-2 right-2 text-[10px] px-1.5 py-0.5 rounded backdrop-blur-sm border ${
                                                        theme === 'dark'
                                                            ? 'bg-black/70 text-white border-white/10'
                                                            : 'bg-white/80 text-zinc-800 border-zinc-200'
                                                    }`}
                                                >
                                                    {node.dimensions.w}x{node.dimensions.h}
                                                </div>
                                            )}
                                            {/* 悬浮菜单：当 isMasking 为 true 时强制隐藏 */}
                                            {!node.isMasking && (
                                            <div className="absolute inset-0 bg-black/40 transition-opacity gap-2 opacity-0 group-hover:opacity-100 flex flex-col items-center justify-center">
                                                <div className="flex items-center gap-2">
                                                <label
                                                    className={`cursor-pointer px-3 py-1.5 rounded-lg text-xs backdrop-blur-sm border transition-colors ${
                                                        theme === 'dark'
                                                            ? 'bg-white/10 hover:bg-white/20 text-white border-white/10'
                                                            : 'bg-white hover:bg-zinc-100 text-zinc-800 border-zinc-300'
                                                    }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    更换 <input type="file" className="hidden" accept="image/*" onChange={(e) => handleFileUpload(node.id, e)} />
                                                </label>
                                                    {!isVideoUrl(node.content) && (
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                setNodes((prev) => prev.map((n) => 
                                                                    n.id === node.id 
                                                                        ? { ...n, isMasking: !n.isMasking }
                                                                        : n
                                                                ));
                                                            }}
                                                            className={`px-3 py-1.5 rounded-lg text-xs backdrop-blur-sm border transition-colors flex items-center gap-1 ${
                                                                theme === 'dark'
                                                                    ? node.isMasking
                                                                        ? 'bg-red-500/80 hover:bg-red-500 text-white border-red-400'
                                                                        : 'bg-white/10 hover:bg-white/20 text-white border-white/10'
                                                                    : node.isMasking
                                                                        ? 'bg-red-500 hover:bg-red-600 text-white border-red-400'
                                                                        : 'bg-white hover:bg-zinc-100 text-zinc-800 border-zinc-300'
                                                            }`}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                        >
                                                            <Brush size={12} />
                                                            局部重绘
                                                        </button>
                                                    )}
                                                </div>
                                                <div
                                                    className={`text-[10px] text-center px-2 ${
                                                        theme === 'dark' ? 'text-zinc-300' : 'text-zinc-500'
                                                    }`}
                                                >
                                                    或拖放图片到此处
                                                    <br />
                                                    或 Ctrl+V 粘贴
                                                </div>
                                            </div>
                                            )}
                                            {/* 非编辑模式下的蒙版回显 */}
                                            {!node.isMasking && node.maskContent && (
                                                <div 
                                                    className="absolute inset-0 z-20 pointer-events-none"
                                                    style={{
                                                        background: 'rgba(255, 0, 0, 0.3)',
                                                        mixBlendMode: 'multiply',
                                                        WebkitMaskImage: `url(${node.maskContent})`,
                                                        maskImage: `url(${node.maskContent})`,
                                                        WebkitMaskSize: '100% 100%',
                                                        maskSize: '100% 100%',
                                                        WebkitMaskRepeat: 'no-repeat',
                                                        maskRepeat: 'no-repeat'
                                                    }}
                                                />
                                            )}
                                            {/* MaskEditor 组件 */}
                                            {node.isMasking && !isVideoUrl(node.content) && node.dimensions && (
                                                <MaskEditor
                                                    nodeId={node.id}
                                                    imageUrl={node.content}
                                                    imageDimensions={node.dimensions}
                                                    isActive={node.isMasking}
                                                    onClose={() => {
                                                        setNodes((prev) => prev.map((n) => 
                                                            n.id === node.id 
                                                                ? { ...n, isMasking: false }
                                                                : n
                                                        ));
                                                    }}
                                                    onSave={(maskDataUrl) => {
                                                        console.log('蒙版已保存:', maskDataUrl);
                                                    }}
                                                    onUpdateNode={(nodeId, updates) => {
                                                        setNodes((prev) => prev.map((n) => 
                                                            n.id === nodeId 
                                                                ? { ...n, ...updates }
                                                                : n
                                                        ));
                                                    }}
                                                    theme={theme}
                                                    view={view}
                                                    maskContent={node.maskContent}
                                                />
                                            )}
                                        </div>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center h-full w-full">
                                             <div
                                                className={`w-12 h-12 rounded-2xl flex items-center justify-center mb-3 border ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700/50'
                                                        : 'bg-zinc-100 border-zinc-300'
                                                }`}
                                             >
                                                <ImageIcon
                                                    className={`w-6 h-6 ${
                                                        theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'
                                                    }`}
                                                />
                                             </div>
                                             <label
                                                className="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-lg text-xs font-medium transition-colors cursor-pointer pointer-events-auto"
                                                onMouseDown={(e) => e.stopPropagation()}
                                             >
                                                选择图片
                                                <input type="file" className="hidden" accept="image/*" onChange={(e) => handleFileUpload(node.id, e)} />
                                             </label>
                                             <div
                                                className={`text-[10px] text-center mt-2 pointer-events-none ${
                                                    theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'
                                                }`}
                                             >
                                                或拖放图片到此处
                                                <br />
                                                或 Ctrl+V 粘贴
                                             </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {node.type === 'video-input' && (
                                <div
                                    className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto drop-zone video-input-container ${
                                        theme === 'dark'
                                            ? 'bg-zinc-900/80'
                                            : 'bg-zinc-100'
                                    }`}
                                    onDrop={(e) => handleVideoDrop(node.id, e)}
                                    onDragOver={handleDragOver}
                                    onDragLeave={handleDragLeave}
                                >
                                    <div className="flex items-center justify-between px-3 py-2 border-b text-xs font-semibold">
                                        <div className="flex items-center gap-1.5">
                                            <Video size={13} className="text-blue-500" />
                                            <span>视频输入</span>
                                        </div>
                                        <div className="flex items-center gap-2 text-[10px] text-zinc-500">
                                            {node.videoMeta?.duration ? <span>时长 {node.videoMeta.duration.toFixed(1)}s</span> : null}
                                            {node.videoMeta?.w ? <span>{node.videoMeta.w}x{node.videoMeta.h}</span> : null}
                                            {node.selectedKeyframes?.length ? <span className="text-blue-500">关键帧 {node.selectedKeyframes.length} 个</span> : null}
                                        </div>
                                    </div>

                                    <div className="flex-1 flex flex-col gap-3 p-3 overflow-hidden min-h-0">
                                        {node.content ? (
                                            <div className="space-y-2">
                                                <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden flex items-center justify-center">
                                                    <video
                                                        src={node.content}
                                                        controls
                                                        className="w-full h-full object-contain"
                                                        draggable={false}
                                                    />
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <label
                                                        className="bg-blue-600 hover:bg-blue-500 text-white px-3 py-1.5 rounded text-xs font-medium transition-colors cursor-pointer"
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        更换视频
                                                        <input
                                                            type="file"
                                                            className="hidden"
                                                            accept="video/*"
                                                            onChange={(e) => handleVideoFileUpload(node.id, e.target.files?.[0])}
                                                        />
                                                    </label>
                                                    <button
                                                        className={`px-3 py-1.5 rounded text-xs border transition-colors ${
                                                            theme === 'dark'
                                                                ? 'border-zinc-700 bg-zinc-800 text-zinc-300 hover:border-blue-500 hover:text-blue-400'
                                                                : 'border-zinc-300 hover:border-blue-500 hover:text-blue-600'
                                                        }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        onClick={() => handleAutoExtractKeyframes(node.id, 2)}
                                                    >
                                                        自动抽帧（2fps）
                                                    </button>
                                                    <button
                                                        className={`px-3 py-1.5 rounded text-xs border transition-colors ${
                                                            theme === 'dark'
                                                                ? 'bg-green-600/40 border-green-500 text-green-200 hover:bg-green-600/60 hover:border-green-400'
                                                                : 'bg-green-50 border-green-300 hover:border-green-500 hover:text-green-600'
                                                        }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        onClick={() => handleSmartExtractKeyframes(node.id, 30)}
                                                    >
                                                        智能抽帧
                                                    </button>
                                                    {node.extractingFrames && (
                                                        <span className="text-[11px] text-blue-500">抽帧中...</span>
                                                    )}
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="flex flex-col items-center justify-center flex-1 gap-3">
                                                <div
                                                    className={`w-12 h-12 rounded-2xl flex items-center justify-center border ${
                                                        theme === 'dark'
                                                            ? 'bg-zinc-800 border-zinc-700/50'
                                                            : 'bg-zinc-100 border-zinc-300'
                                                    }`}
                                                >
                                                    <Video className={`w-6 h-6 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`} />
                                                </div>
                                                <label
                                                    className="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-lg text-xs font-medium transition-colors cursor-pointer"
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    选择或拖拽视频
                                                    <input
                                                        type="file"
                                                        className="hidden"
                                                        accept="video/*"
                                                        onChange={(e) => handleVideoFileUpload(node.id, e.target.files?.[0])}
                                                    />
                                                </label>
                                                <div className="text-[10px] text-center text-zinc-500 pointer-events-none">
                                                    支持 MP4/WEBM，拖拽或 Ctrl+V 不可用
                                                </div>
                                            </div>
                                        )}

                                        <div className="flex items-center justify-between text-[11px] text-zinc-500">
                                            <span>抽帧缩略图</span>
                                            <span>{(node.frames || []).length} 张</span>
                                        </div>
                                        <div
                                            className="grid gap-3 w-full overflow-y-auto custom-scrollbar flex-1 min-h-0"
                                            style={{
                                                gridTemplateColumns: 'repeat(auto-fill, minmax(clamp(140px, 20vw, 240px), 1fr))',
                                                gridAutoRows: 'minmax(110px, auto)'
                                            }}
                                        >
                                            {(node.frames || []).length === 0 ? (
                                                <div className={`col-span-full text-[11px] text-zinc-500 text-center py-4 border rounded ${
                                                    theme === 'dark' ? 'bg-zinc-800/40 border-zinc-700' : 'bg-white/40 border-zinc-300'
                                                }`}>
                                                    点击「自动抽帧」即可生成缩略图
                                                </div>
                                            ) : (
                                                (node.frames || []).map((frame, idx) => {
                                                    const selected = (node.selectedKeyframes || []).some(f => f.url === frame.url && f.time === frame.time);
                                                    return (
                                                        <button
                                                            key={`${frame.url}-${idx}`}
                                                            className={`relative rounded border overflow-hidden group ${selected ? 'ring-2 ring-blue-500' : ''}`}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                            onClick={(e) => handleToggleKeyframe(node.id, frame, idx, e)}
                                                            onContextMenu={(e) => openFrameContextMenu(e, node.id, frame)}
                                                        >
                                                            <img src={frame.url} className="w-full aspect-video object-contain bg-black" alt={`frame-${idx}`} loading="lazy" />
                                                            <div className="absolute left-1 top-1 text-[10px] px-1 py-0.5 rounded bg-black/60 text-white">
                                                                {frame.time.toFixed(2)}s
                                                            </div>
                                                            <div className="absolute right-1 top-1 w-4 h-4 rounded-full border border-white/80 bg-black/40 flex items-center justify-center">
                                                                {selected ? <CheckCircle2 size={10} className="text-white" /> : null}
                                                            </div>
                                                        </button>
                                                    );
                                                })
                                            )}
                                        </div>
                                    </div>
                                </div>
                            )}

                            {node.type === 'text-node' && (
                                <div
                                    className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto ${
                                        theme === 'dark'
                                            ? 'bg-zinc-900/80'
                                            : 'bg-zinc-100'
                                    }`}
                                >
                                    <div className="flex items-center justify-between px-3 py-2 border-b text-xs font-semibold">
                                        <div className="flex items-center gap-1.5">
                                            <FileText size={13} className="text-blue-500" />
                                            <span>文字节点</span>
                                        </div>
                                    </div>
                                    <div className="flex-1 p-3">
                                        <textarea
                                            data-node-type="text-node"
                                            data-node-id={node.id}
                                            value={node.settings?.text || ''}
                                            onChange={(e) => {
                                                updateNodeSettings(node.id, { text: e.target.value });
                                            }}
                                            placeholder="输入文字内容..."
                                            className={`w-full h-full resize-none outline-none text-sm p-2 rounded border ${
                                                theme === 'dark'
                                                    ? 'bg-zinc-800 border-zinc-700 text-zinc-200 placeholder-zinc-500'
                                                    : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                            }`}
                                            onMouseDown={(e) => e.stopPropagation()}
                                        />
                                    </div>
                                </div>
                            )}

                            {node.type === 'video-analyze' && (
                                <div
                                    className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto video-analyze-container ${theme === 'dark' ? 'bg-zinc-900/80' : 'bg-zinc-100'}`}
                                    onClick={(e) => {
                                        // 检查是否有文本选择，如果有则不阻止事件
                                        const selection = window.getSelection();
                                        if (selection && selection.toString().length > 0) {
                                            return; // 允许文本选择
                                        }
                                        // 检查是否点击在可交互元素上
                                        const target = e.target;
                                        if (target && (
                                            target.tagName === 'INPUT' ||
                                            target.tagName === 'TEXTAREA' ||
                                            target.tagName === 'SELECT' ||
                                            target.tagName === 'BUTTON' ||
                                            target.isContentEditable ||
                                            target.closest('input, textarea, select, button, [contenteditable="true"]')
                                        )) {
                                            return; // 允许交互元素正常工作
                                        }
                                        e.stopPropagation();
                                    }}
                                >
                                    <div className="flex items-center justify-between px-3 py-2 border-b text-xs font-semibold">
                                        <div className="flex items-center gap-1.5">
                                            <FileSearch size={13} className="text-blue-500" />
                                            <span>视频拆解 / 提示词反推</span>
                                        </div>
                                    </div>

                                    <div className="flex-1 flex flex-col gap-3 p-3 overflow-hidden min-h-0">
                                        {(() => {
                                            const videoInputNode = getConnectedVideoInputNode(node.id);
                                            if (!videoInputNode) {
                                                return (
                                                    <div className="flex flex-col items-center justify-center flex-1 gap-2 text-[11px] text-zinc-500">
                                                        <LinkIcon size={24} className="text-zinc-400" />
                                                        <span>请连接一个视频输入节点</span>
                                                    </div>
                                                );
                                            }
                                            
                                            const videoFileName = videoInputNode.videoFileName || '未命名视频';
                                            const videoDuration = videoInputNode.videoMeta?.duration || 0;
                                            const selectedKeyframes = videoInputNode.selectedKeyframes || [];
                                            
                                            return (
                                                <>
                                                    <div className="space-y-2">
                                                        <div className={`text-[11px] px-2 py-1.5 rounded border ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700' : 'bg-zinc-50 border-zinc-300'}`}>
                                                            <div className="flex items-center justify-between mb-1">
                                                                <span className="text-zinc-500">关联的视频</span>
                                                            </div>
                                                            <div className="text-zinc-700 dark:text-zinc-300">
                                                                <div>文件名: {videoFileName}</div>
                                                                <div>总时长: {videoDuration.toFixed(1)}s</div>
                                                                <div>已选关键帧: {selectedKeyframes.length} 个</div>
                                                            </div>
                                                        </div>
                                                        
                                                        {/* 模式选择切换按钮 */}
                                                        <div className={`flex items-center gap-2 p-1 rounded-lg border shadow-inner ${
                                                            theme === 'dark' ? 'bg-zinc-800 border-zinc-700' : 'bg-zinc-100 border-zinc-200'
                                                        }`}>
                                                            <button
                                                                onClick={() => updateNodeSettings(node.id, { analysisMode: 'manual' })}
                                                                className={`flex-1 py-1 px-2 text-[11px] rounded transition-all flex justify-center items-center gap-1 ${
                                                                    (node.settings?.analysisMode || 'manual') === 'manual'
                                                                        ? theme === 'dark'
                                                                            ? 'bg-zinc-600 shadow-md text-blue-300 font-bold'
                                                                            : 'bg-white shadow-md text-blue-600 font-bold'
                                                                        : theme === 'dark'
                                                                            ? 'text-zinc-500 hover:text-zinc-300'
                                                                            : 'text-zinc-500 hover:text-zinc-700'
                                                                }`}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            >
                                                                <Camera size={12} /> 手动选帧拆解
                                                            </button>
                                                            <button
                                                                onClick={() => updateNodeSettings(node.id, { analysisMode: 'auto' })}
                                                                className={`flex-1 py-1 px-2 text-[11px] rounded transition-all flex justify-center items-center gap-1 ${
                                                                    node.settings?.analysisMode === 'auto'
                                                                        ? theme === 'dark'
                                                                            ? 'bg-zinc-600 shadow-md text-purple-300 font-bold'
                                                                            : 'bg-white shadow-md text-purple-600 font-bold'
                                                                        : theme === 'dark'
                                                                            ? 'text-zinc-500 hover:text-zinc-300'
                                                                            : 'text-zinc-500 hover:text-zinc-700'
                                                                }`}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            >
                                                                <Sparkles size={12} /> AI 导演拆解
                                                            </button>
                                                        </div>
                                                        
                                                        {(node.settings?.analysisMode || 'manual') === 'manual' && (
                                                            <>
                                                                <div className="flex items-center gap-2">
                                                                    <label className="text-[11px] text-zinc-500">按时间段分组:</label>
                                                                    <input
                                                                        type="number"
                                                                        min="1"
                                                                        max="30"
                                                                        value={node.settings?.segmentDuration || 3}
                                                                        onChange={(e) => updateNodeSettings(node.id, { segmentDuration: parseInt(e.target.value) || 3 })}
                                                                        className={`w-16 px-2 py-1 text-[11px] rounded border ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-300' : 'bg-white border-zinc-300 text-zinc-800'}`}
                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                    />
                                                                    <span className="text-[11px] text-zinc-500">秒</span>
                                                                </div>
                                                                
                                                                <div className="flex items-center gap-2">
                                                                    <label className="text-[11px] text-zinc-500">模型:</label>
                                                                    <select
                                                                        value={node.settings?.model || 'gemini-3-pro'}
                                                                        onChange={(e) => updateNodeSettings(node.id, { model: e.target.value })}
                                                                        className={`flex-1 px-2 py-1 text-[11px] rounded border ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-300' : 'bg-zinc-50 border-zinc-300 text-zinc-800'}`}
                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                    >
                                                                        {apiConfigs.filter(c => c.type === 'Chat' && ['gemini-3-pro', 'gpt-5-1', 'gpt-5-2', 'deepseek-v3'].includes(c.id)).map(c => (
                                                                            <option key={c.id} value={c.id}>{c.provider}</option>
                                                                        ))}
                                                                    </select>
                                                                </div>
                                                            </>
                                                        )}
                                                        
                                                        <button
                                                            onClick={() => node.settings?.analysisMode === 'auto' ? handleAutoVideoAnalysis(node.id) : handleGeneratePrompts(node.id)}
                                                            disabled={node.isGenerating || ((node.settings?.analysisMode || 'manual') === 'manual' && selectedKeyframes.length === 0)}
                                                            className={`w-full px-3 py-2 rounded text-xs font-medium transition-colors flex items-center justify-center gap-2 ${
                                                                node.isGenerating
                                                                    ? 'bg-zinc-600 text-zinc-400 cursor-not-allowed'
                                                                    : node.settings?.analysisMode === 'auto'
                                                                        ? 'bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-500 hover:to-indigo-500 text-white shadow-lg'
                                                                        : 'bg-blue-600 hover:bg-blue-500 text-white'
                                                            }`}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                        >
                                                            {node.isGenerating ? (
                                                                <>
                                                                    <Loader2 size={14} className="animate-spin" />
                                                                    <span>{node.settings?.analysisMode === 'auto' ? 'AI 正在拉片分析中...' : '生成中...'}</span>
                                                                </>
                                                            ) : (
                                                                <>
                                                                    <Sparkles size={14} />
                                                                    <span>{node.settings?.analysisMode === 'auto' ? '开始全自动拆解视频' : '为选中关键帧生成提示词'}</span>
                                                                </>
                                                            )}
                                                        </button>
                                                        
                                                        {node.errorMsg && (
                                                            <div className="text-[10px] text-red-500 px-2 py-1 rounded bg-red-500/10">
                                                                {node.errorMsg}
                                                            </div>
                                                        )}
                                                    </div>
                                                    
                                                    {/* 结果展示区 (Auto 模式) */}
                                                    {node.settings?.analysisMode === 'auto' && node.settings?.analysisResults?.length > 0 && (
                                                        <div className="flex-1 overflow-y-auto custom-scrollbar pt-2">
                                                            {/* 口播文案 (Voiceover) */}
                                                            {node.settings.voiceoverResults?.length > 0 && (
                                                                <div className={`p-2 rounded-lg mb-4 ${theme === 'dark' ? 'bg-zinc-700/50 border border-zinc-700' : 'bg-zinc-50 border border-blue-200'}`}>
                                                                    <h4 className={`text-xs font-semibold mb-2 flex items-center gap-1 ${theme === 'dark' ? 'text-white' : 'text-blue-700'}`}>
                                                                        <Mic2 size={12} /> 提取口播文案
                                                                    </h4>
                                                                    <div className="space-y-1">
                                                                        {node.settings.voiceoverResults.map((v, i) => (
                                                                            <p 
                                                                                key={i} 
                                                                                className={`text-[10px] select-text cursor-text ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}
                                                                                onMouseDown={(e) => e.stopPropagation()}
                                                                            >
                                                                                <span className="font-mono text-xs mr-2 opacity-70">[{v.time_range || `${v.time}s`}]</span>
                                                                                {v.text || <span className="text-zinc-400 italic">（无口播）</span>}
                                                                            </p>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            )}

                                                            {/* 场景拆解结果 */}
                                                            <h4 className={`text-xs font-semibold mb-3 flex items-center gap-1 ${theme === 'dark' ? 'text-white' : 'text-zinc-800'}`}>
                                                                <Camera size={12} /> 导演级场景分析 ({node.settings.analysisResults.length} 场景)
                                                            </h4>
                                                            
                                                            <div className="space-y-4">
                                                                {node.settings.analysisResults.map((scene, i) => (
                                                                    <div key={i} className={`p-3 rounded-lg ${theme === 'dark' ? 'bg-zinc-800 border border-zinc-700' : 'bg-zinc-50 border border-zinc-200'}`}>
                                                                        <h5 className={`text-sm font-bold mb-2 ${theme === 'dark' ? 'text-purple-400' : 'text-purple-700'}`}>
                                                                            场景 {scene.scene_index || scene.scene_id || i + 1} <span className="text-xs font-normal opacity-70 ml-2">({scene.time_range})</span>
                                                                        </h5>
                                                                        
                                                                        {/* 视觉分析 */}
                                                                        <div className="text-[11px] space-y-1 mb-3">
                                                                            {scene.keyframes?.[0]?.description && (
                                                                                <p 
                                                                                    className={`select-text cursor-text ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}
                                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                                >
                                                                                    <span className="font-semibold mr-1">运镜/动态:</span> {scene.keyframes[0].description}
                                                                                </p>
                                                                            )}
                                                                            {scene.global_tags?.style?.[0] && (
                                                                                <p 
                                                                                    className={`select-text cursor-text ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}
                                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                                >
                                                                                    <span className="font-semibold mr-1">氛围/风格:</span> {scene.global_tags.style[0]}
                                                                                </p>
                                                                            )}
                                                                        </div>

                                                                        {/* 提示词输出 */}
                                                                        <div className="space-y-2">
                                                                            {/* 即梦 Prompt */}
                                                                            {scene.keyframes?.[0]?.jimeng_prompt && (
                                                                                <div className={`p-2 rounded ${theme === 'dark' ? 'bg-zinc-700 border border-zinc-600' : 'bg-zinc-50 border border-gray-300'}`}>
                                                                                    <h6 className={`text-[10px] font-semibold mb-1 flex items-center gap-1 ${theme === 'dark' ? 'text-yellow-300' : 'text-yellow-700'}`}><Code size={10} /> 即梦 Prompt</h6>
                                                                                    <p 
                                                                                        className={`text-[10px] whitespace-pre-wrap select-text cursor-text ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'}`}
                                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                                    >{scene.keyframes[0].jimeng_prompt}</p>
                                                                                    <button onClick={() => navigator.clipboard.writeText(scene.keyframes[0].jimeng_prompt)} className="mt-1 flex items-center text-[9px] text-blue-400 hover:text-blue-300" onMouseDown={(e) => e.stopPropagation()}>
                                                                                        <ClipboardCopy size={10} className="mr-1" /> 复制
                                                                                    </button>
                                                                                </div>
                                                                            )}
                                                                            
                                                                            {/* MJ Prompt */}
                                                                            {scene.keyframes?.[0]?.mj_prompt && (
                                                                                <div className={`p-2 rounded ${theme === 'dark' ? 'bg-zinc-700 border border-zinc-600' : 'bg-zinc-50 border border-gray-300'}`}>
                                                                                    <h6 className={`text-[10px] font-semibold mb-1 flex items-center gap-1 ${theme === 'dark' ? 'text-green-300' : 'text-green-700'}`}><Code size={10} /> MJ Prompt</h6>
                                                                                    <p 
                                                                                        className={`text-[10px] whitespace-pre-wrap select-text cursor-text ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'}`}
                                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                                    >{scene.keyframes[0].mj_prompt}</p>
                                                                                    <button onClick={() => navigator.clipboard.writeText(scene.keyframes[0].mj_prompt)} className="mt-1 flex items-center text-[9px] text-blue-400 hover:text-blue-300" onMouseDown={(e) => e.stopPropagation()}>
                                                                                        <ClipboardCopy size={10} className="mr-1" /> 复制
                                                                                    </button>
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    )}
                                                    
                                                    {/* 结果展示区 (Manual 模式) */}
                                                    {(node.settings?.analysisMode || 'manual') === 'manual' && node.analysisResults && node.analysisResults.length > 0 ? (
                                                        <div className="space-y-3 flex-1 flex flex-col min-h-0">
                                                            <div className="text-[11px] font-medium text-zinc-700 dark:text-zinc-300 shrink-0">拆解提示词 ({node.analysisResults.length} 个场景)</div>
                                                            <div className="space-y-3 flex-1 overflow-y-auto custom-scrollbar min-h-0">
                                                                {node.analysisResults.map((result, idx) => {
                                                                    // 获取关键帧对应的图片URL（从videoInputNode的frames或selectedKeyframes中查找）
                                                                    const getFrameImageUrl = (frameTime) => {
                                                                        // 先从selectedKeyframes中查找
                                                                        const selectedFrame = videoInputNode.selectedKeyframes?.find(f => Math.abs(f.time - frameTime) < 0.1);
                                                                        if (selectedFrame) return selectedFrame.url;
                                                                        // 再从frames中查找
                                                                        const frame = videoInputNode.frames?.find(f => Math.abs(f.time - frameTime) < 0.1);
                                                                        return frame?.url || null;
                                                                    };
                                                                    
                                                                    // 获取当前场景的主要关键帧（prev/current/next）
                                                                    const currentKeyframe = result.keyframes?.find(k => k.type === 'current') || result.keyframes?.[0];
                                                                    const prevKeyframe = result.keyframes?.find(k => k.type === 'prev');
                                                                    const nextKeyframe = result.keyframes?.find(k => k.type === 'next');
                                                                    
                                                                    // 获取简短描述（使用current的描述，如果没有则使用第一个）
                                                                    const shortDescription = currentKeyframe?.description || result.keyframes?.[0]?.description || '无描述';
                                                                    
                                                                    return (
                                                                        <div
                                                                            key={idx}
                                                                            className={`p-3 rounded-lg border ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700' : 'bg-white border-zinc-300'}`}
                                                                        >
                                                                            {/* 场景标题和时间区间 */}
                                                                            <div className="flex items-center justify-between mb-2">
                                                                                <div className="font-medium text-[11px] text-zinc-800 dark:text-zinc-200">
                                                                                    场景 {result.scene_index || idx + 1}
                                                                                </div>
                                                                                <div className="text-[10px] text-zinc-500">
                                                                                    {result.time_range}
                                                                                </div>
                                                                            </div>
                                                                            
                                                                            {/* 简短描述 */}
                                                                            <div 
                                                                                className="text-[10px] text-zinc-600 dark:text-zinc-400 mb-3 line-clamp-2 select-text cursor-text"
                                                                                onMouseDown={(e) => e.stopPropagation()}
                                                                            >
                                                                                {shortDescription}
                                                                            </div>
                                                                            
                                                                            {/* 关键帧缩略图 */}
                                                                            <div className="grid grid-cols-3 gap-2 mb-3">
                                                                                {[prevKeyframe, currentKeyframe, nextKeyframe].map((kf, kfIdx) => {
                                                                                    if (!kf) return <div key={kfIdx} className="aspect-video bg-zinc-200 dark:bg-zinc-700 rounded"></div>;
                                                                                    const imageUrl = getFrameImageUrl(kf.time);
                                                                                    return (
                                                                                        <div key={kfIdx} className="relative aspect-video bg-black rounded overflow-hidden">
                                                                                            {imageUrl ? (
                                                                                                <img src={imageUrl} className="w-full h-full object-cover" alt={`关键帧 ${kfIdx + 1}`} loading="lazy" />
                                                                                            ) : (
                                                                                                <div className="w-full h-full flex items-center justify-center text-[8px] text-zinc-500">
                                                                                                    {kf.type === 'prev' ? '上一帧' : kf.type === 'current' ? '当前帧' : '下一帧'}
                                                                                                </div>
                                                                                            )}
                                                                                            <div className="absolute bottom-0 left-0 right-0 bg-black/60 text-white text-[8px] px-1 py-0.5 text-center">
                                                                                                {kf.time.toFixed(1)}s
                                                                                            </div>
                                                                                        </div>
                                                                                    );
                                                                                })}
                                                                            </div>
                                                                            
                                                                            {/* 提示词列表 */}
                                                                            <div className="space-y-2">
                                                                                {result.keyframes?.map((kf, kfIdx) => (
                                                                                    <div key={kfIdx} className="space-y-1.5">
                                                                                        <div className="text-[9px] text-zinc-500">
                                                                                            {kf.type === 'prev' ? '上一帧' : kf.type === 'current' ? '当前帧' : '下一帧'} ({kf.time.toFixed(1)}s)
                                                                                        </div>
                                                                                        
                                                                                        {/* MJ 提示词 */}
                                                                                        {kf.mj_prompt && (
                                                                                            <div className={`p-2 rounded border ${theme === 'dark' ? 'bg-zinc-900 border-zinc-600' : 'bg-zinc-50 border-zinc-200'}`}>
                                                                                                <div className="flex items-start justify-between gap-2">
                                                                                                    <div className="flex-1">
                                                                                                        <div className="text-[9px] text-zinc-500 mb-1">Midjourney 提示词</div>
                                                                                                        <div 
                                                                                                            className="text-[10px] text-zinc-700 dark:text-zinc-300 break-words select-text cursor-text"
                                                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                                                        >{kf.mj_prompt}</div>
                                                                                                    </div>
                                                                                                    <div className="flex items-center gap-1 shrink-0">
                                                                                                        <button
                                                                                                            onClick={async () => {
                                                                                                                try {
                                                                                                                    await navigator.clipboard.writeText(kf.mj_prompt);
                                                                                                                    alert('已复制到剪贴板');
                                                                                                                } catch (e) {
                                                                                                                    alert('复制失败');
                                                                                                                }
                                                                                                            }}
                                                                                                            className={`p-1 rounded hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors ${theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : 'text-zinc-500 hover:text-zinc-700'}`}
                                                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                                                            title="复制"
                                                                                                        >
                                                                                                            <CopyPlus size={12} />
                                                                                                        </button>
                                                                                                        <button
                                                                                                            onClick={() => {
                                                                                                                const world = screenToWorld(node.x + node.width + 100, node.y + node.height / 2);
                                                                                                                const newNodeId = `node-${Date.now()}`;
                                                                                                                
                                                                                                                // 创建图生图节点
                                                                                                                const genImageNode = {
                                                                                                                    id: newNodeId,
                                                                                                                    type: 'gen-image',
                                                                                                                    x: world.x - 180,
                                                                                                                    y: world.y - 170,
                                                                                                                    width: 360,
                                                                                                                    height: 340,
                                                                                                                    settings: { 
                                                                                                                        model: 'mj-v6',
                                                                                                                        prompt: kf.mj_prompt,
                                                                                                                        ratio: 'Auto',
                                                                                                                        resolution: 'Auto'
                                                                                                                    }
                                                                                                                };
                                                                                                                
                                                                                                                setNodes((prev) => [...prev, genImageNode]);
                                                                                                                
                                                                                                                // 创建预览节点并连接
                                                                                                                setTimeout(() => {
                                                                                                                    const previewWorld = screenToWorld(node.x + node.width + 200, node.y + node.height / 2);
                                                                                                                    const previewNodeId = `node-${Date.now() + 1}`;
                                                                                                                    const previewNode = {
                                                                                                                        id: previewNodeId,
                                                                                                                        type: 'preview',
                                                                                                                        x: previewWorld.x - 160,
                                                                                                                        y: previewWorld.y - 130,
                                                                                                                        width: 320,
                                                                                                                        height: 260
                                                                                                                    };
                                                                                                                    
                                                                                                                    setNodes((prev) => [...prev, previewNode]);
                                                                                                                    
                                                                                                                    // 连接图生图节点到预览节点
                                                                                                                    setConnections((prev) => [...prev, { 
                                                                                                                        id: `conn-${Date.now()}`, 
                                                                                                                        from: newNodeId, 
                                                                                                                        to: previewNodeId 
                                                                                                                    }]);
                                                                                                                }, 50);
                                                                                                            }}
                                                                                                            className={`p-1 rounded hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors text-blue-600 dark:text-blue-400`}
                                                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                                                            title="生成图生图节点"
                                                                                                        >
                                                                                                            <ImagePlus size={12} />
                                                                                                        </button>
                                                                                                    </div>
                                                                                                </div>
                                                                                            </div>
                                                                                        )}
                                                                                        
                                                                                        {/* 即梦提示词 */}
                                                                                        {kf.jimeng_prompt && (
                                                                                            <div className={`p-2 rounded border ${theme === 'dark' ? 'bg-zinc-900 border-zinc-600' : 'bg-zinc-50 border-zinc-200'}`}>
                                                                                                <div className="flex items-start justify-between gap-2">
                                                                                                    <div className="flex-1">
                                                                                                        <div className="text-[9px] text-zinc-500 mb-1">即梦提示词</div>
                                                                                                        <div 
                                                                                                            className="text-[10px] text-zinc-700 dark:text-zinc-300 break-words select-text cursor-text"
                                                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                                                        >{kf.jimeng_prompt}</div>
                                                                                                    </div>
                                                                                                    <button
                                                                                                        onClick={async () => {
                                                                                                            try {
                                                                                                                await navigator.clipboard.writeText(kf.jimeng_prompt);
                                                                                                                alert('已复制到剪贴板');
                                                                                                            } catch (e) {
                                                                                                                alert('复制失败');
                                                                                                            }
                                                                                                        }}
                                                                                                        className={`p-1 rounded hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors ${theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : 'text-zinc-500 hover:text-zinc-700'}`}
                                                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                                                        title="复制"
                                                                                                    >
                                                                                                        <CopyPlus size={12} />
                                                                                                    </button>
                                                                                                </div>
                                                                                            </div>
                                                                                        )}
                                                                                    </div>
                                                                                ))}
                                                                            </div>
                                                                            
                                                                            {/* 全局标签 */}
                                                                            {result.global_tags && (
                                                                                <div className="mt-2 pt-2 border-t border-zinc-300 dark:border-zinc-700">
                                                                                    <div className="text-[9px] text-zinc-500 mb-1">全局标签</div>
                                                                                    <div className="flex flex-wrap gap-1">
                                                                                        {Object.entries(result.global_tags).map(([key, values]) => (
                                                                                            Array.isArray(values) && values.map((val, valIdx) => (
                                                                                                <span key={`${key}-${valIdx}`} className="text-[8px] px-1.5 py-0.5 rounded bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300">
                                                                                                    {val}
                                                                                                </span>
                                                                                            ))
                                                                                        ))}
                                                                                    </div>
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                    );
                                                                })}
                                                            </div>
                                                        </div>
                                                    ) : null}
                                                </>
                                            );
                                        })()}
                                    </div>
                                </div>
                            )}

                            {node.type === 'storyboard-node' && (() => {
                                // --- 辅助函数：处理单个镜头的图片上传 ---
                                const handleShotImageUpload = (e, shotId) => {
                                    const file = e.target.files?.[0];
                                    if (file) {
                                        const reader = new FileReader();
                                        reader.onload = (ev) => updateShot(node.id, shotId, { image_url: ev.target.result });
                                        reader.readAsDataURL(file);
                                    }
                                };

                                // --- 辅助函数：处理单个镜头的粘贴 (Ctrl+V) ---
                                const handleShotPaste = (e, shotId) => {
                                    const items = e.clipboardData.items;
                                    for (let i = 0; i < items.length; i++) {
                                        if (items[i].type.indexOf('image') !== -1) {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            const blob = items[i].getAsFile();
                                            const reader = new FileReader();
                                            reader.onload = (ev) => updateShot(node.id, shotId, { image_url: ev.target.result });
                                            reader.readAsDataURL(blob);
                                            return;
                                        }
                                    }
                                };

                                // --- 辅助函数：处理单个镜头的拖拽 (Drop) ---
                                const handleShotDrop = (e, shotId) => {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    
                                    // 1. 尝试从浏览器外部拖入文件
                                    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                                        const file = e.dataTransfer.files[0];
                                        if (file.type.startsWith('image/')) {
                                            const reader = new FileReader();
                                            reader.onload = (ev) => updateShot(node.id, shotId, { image_url: ev.target.result });
                                            reader.readAsDataURL(file);
                                            return;
                                        }
                                    }
                                    
                                    // 2. 尝试从左侧历史记录拖入 (需要配合你在 Sidebar 设置的 dataTransfer)
                                    // 这里假设历史记录拖拽时没有传递复杂数据，通常较难直接拦截 React 组件间的拖拽
                                    // 建议使用上面的"本地上传"或"粘贴"作为主要交互
                                };

                                return (
                                    <div 
                                        className={`flex flex-col h-full rounded-xl overflow-hidden pointer-events-auto transition-colors ${
                                        theme === 'dark' ? 'bg-zinc-950 border border-zinc-800' : 'bg-white border border-zinc-300 shadow-sm'
                                        }`}
                                        onMouseEnter={() => setIsMouseOverStoryboard(true)}
                                        onMouseLeave={() => setIsMouseOverStoryboard(false)}
                                    >
                                        {/* Header */}
                                        <div className={`px-4 py-3 border-b flex justify-between items-center shrink-0 ${
                                            theme === 'dark' ? 'bg-zinc-900 border-zinc-800' : 'bg-zinc-50 border-zinc-200'
                                        }`}>
                                            <div className="flex items-center gap-2">
                                                <LayoutGrid size={16} className="text-purple-500"/>
                                                <span className={`font-bold text-xs ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'}`}>
                                                    {node.settings?.projectTitle || '智能分镜表'}
                                                </span>
                                            </div>
                                            {getConnectedVideoAnalyzeNode(node.id) && (
                                                <button 
                                                    onClick={() => importShotsFromAnalysis(node.id)} 
                                                    className="text-xs bg-blue-600 px-2 py-1 rounded text-white hover:bg-blue-500 transition-colors shadow-sm"
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    同步分析结果
                                                </button>
                                            )}
                                        </div>

                                        {/* List */}
                                        <div 
                                            className="flex-1 overflow-y-auto custom-scrollbar p-3 space-y-3 min-h-0 bg-opacity-50"
                                            onWheel={(e) => {
                                                e.stopPropagation();
                                            }}
                                        >
                                            {node.settings?.shots?.length > 0 ? (
                                                node.settings.shots.map((shot, idx) => {
                                                    const isActiveShot = activeShot?.nodeId === node.id && activeShot?.shotId === shot.id;
                                                    return (
                                                    <div 
                                                        key={shot.id}
                                                        tabIndex={0} // 允许聚焦以响应键盘事件
                                                        onClick={(e) => {
                                                            e.stopPropagation(); // 防止触发节点选择
                                                            setActiveShot({ nodeId: node.id, shotId: shot.id });
                                                            e.currentTarget.focus(); // 关键：点击行即聚焦，激活粘贴
                                                        }}
                                                        onPaste={(e) => handleShotPaste(e, shot.id)} // 关键：在行级别监听粘贴
                                                        className={`flex gap-3 p-3 rounded-lg border transition-all group/shot cursor-pointer outline-none focus:ring-2 focus:ring-blue-500/50 ${
                                                            isActiveShot 
                                                                ? 'border-blue-500 ring-1 ring-blue-500 bg-blue-500/5 z-10' 
                                                                : theme === 'dark' 
                                                                    ? 'bg-zinc-900/50 border-zinc-800 hover:border-zinc-600' 
                                                                    : 'bg-white border-zinc-200 hover:border-blue-300 hover:shadow-md'
                                                        }`}
                                                    >
                                                        {/* Index */}
                                                        <div className={`font-mono text-sm w-6 shrink-0 flex items-start pt-1 font-bold ${
                                                            theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'
                                                        }`}>{idx + 1}</div>
                                                        
                                                        {/* Video/Image Preview with Interaction */}
                                                        <div 
                                                            className={`w-32 aspect-video rounded border relative group overflow-hidden shrink-0 transition-colors ${
                                                                theme === 'dark' ? 'bg-black border-zinc-800' : 'bg-zinc-100 border-zinc-300'
                                                            }`}
                                                            onClick={(e) => {
                                                                e.stopPropagation(); // 防止触发行选择
                                                            }}
                                                            onDrop={(e) => handleShotDrop(e, shot.id)}
                                                            onDragOver={(e) => e.preventDefault()}
                                                        >
                                                            {/* 视频预览（优先显示） */}
                                                            {shot.video_url ? (
                                                                <>
                                                                    <video 
                                                                        src={shot.video_url} 
                                                                        className="w-full h-full object-cover rounded"
                                                                        controls
                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                    />
                                                                    {/* 清除/重新生成按钮 */}
                                                                    <button 
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            updateShot(node.id, shot.id, { video_url: '', status: 'draft' });
                                                                        }}
                                                                        className={`absolute top-1 right-1 p-1 rounded opacity-0 group-hover:opacity-100 transition-opacity ${
                                                                            theme === 'dark' 
                                                                                ? 'bg-black/60 hover:bg-red-600 text-white' 
                                                                                : 'bg-white/80 hover:bg-red-500 text-white'
                                                                        }`}
                                                                        title="清除视频"
                                                                    >
                                                                        <X size={10} />
                                                                    </button>
                                                                </>
                                                            ) : shot.status === 'generating' ? (
                                                                /* 生成中状态 */
                                                                <div className={`w-full h-full flex flex-col items-center justify-center text-[10px] gap-2 ${
                                                                    theme === 'dark' ? 'bg-zinc-900 text-zinc-300' : 'bg-zinc-100 text-zinc-600'
                                                                }`}>
                                                                    <Loader2 size={20} className="animate-spin text-blue-500" />
                                                                    <span>视频生成中...</span>
                                                                </div>
                                                            ) : shot.image_url ? (
                                                                /* 图片预览（作为参考图） */
                                                                <>
                                                                    <img src={shot.image_url} className="w-full h-full object-cover" alt={`镜头 ${idx + 1}`} />
                                                                    {/* 删除按钮 UI */}
                                                                    <button 
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            updateShot(node.id, shot.id, { image_url: '' });
                                                                        }}
                                                                        className={`absolute top-1 right-1 p-1 rounded opacity-0 group-hover:opacity-100 transition-opacity ${
                                                                            theme === 'dark' 
                                                                                ? 'bg-black/60 hover:bg-red-600 text-white' 
                                                                                : 'bg-white/80 hover:bg-red-500 text-white'
                                                                        }`}
                                                                        title="移除图片"
                                                                    >
                                                                        <X size={10} />
                                                                    </button>
                                                                </>
                                                            ) : (
                                                                /* 默认状态：显示占位符 */
                                                                <div className={`w-full h-full flex flex-col items-center justify-center text-[10px] gap-1 ${
                                                                    theme === 'dark' ? 'text-zinc-700' : 'text-zinc-400'
                                                                }`}>
                                                                    <ImagePlus size={14}/>
                                                                    <span>点击粘贴/拖入</span>
                                                                </div>
                                                            )}
                                                            
                                                            {/* Hover Overlay for Upload（仅在无视频和图片时显示） */}
                                                            {!shot.video_url && !shot.image_url && (
                                                                <label className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 flex items-center justify-center text-white text-xs transition-opacity cursor-pointer">
                                                                    <span className="flex flex-col items-center gap-1">
                                                                        <FolderOpen size={14}/>
                                                                        选择图片
                                                                    </span>
                                                                    <input 
                                                                        type="file" 
                                                                        className="hidden" 
                                                                        accept="image/*" 
                                                                        onChange={(e) => handleShotImageUpload(e, shot.id)} 
                                                                    />
                                                                </label>
                                                            )}
                                                        </div>

                                                        {/* Content */}
                                                        <div className="flex-1 min-w-0 flex flex-col gap-2">
                                                            {/* Control Bar: Model, Ratio, Duration */}
                                                            <div className="flex gap-2 items-center flex-wrap">
                                                                {/* Video Model Select */}
                                                                <select
                                                                    value={shot.model || (apiConfigs.find(c => c.type === 'Video' && c.id === 'sora-2')?.id || apiConfigs.find(c => c.type === 'Video')?.id || '')}
                                                                    onChange={(e) => {
                                                                        const newModel = e.target.value;
                                                                        const config = apiConfigs.find(c => c.id === newModel);
                                                                        const defaultDuration = getDefaultDurationForModel(newModel);
                                                                        updateShot(node.id, shot.id, { 
                                                                            model: newModel,
                                                                            duration: shot.duration || defaultDuration
                                                                        });
                                                                    }}
                                                                    onClick={(e) => e.stopPropagation()}
                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                    className={`text-xs px-2 py-1 rounded border outline-none transition-colors ${
                                                                        theme === 'dark'
                                                                            ? 'bg-zinc-800 border-zinc-700 text-zinc-200 hover:border-zinc-600'
                                                                            : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                                    }`}
                                                                >
                                                                    {apiConfigs.filter(c => c.type === 'Video').map(config => (
                                                                        <option key={config.id} value={config.id}>
                                                                            {config.provider || config.modelName || config.id}
                                                                        </option>
                                                                    ))}
                                                                </select>
                                                                
                                                                {/* Ratio Select */}
                                                                <select
                                                                    value={shot.ratio || '16:9'}
                                                                    onChange={(e) => updateShot(node.id, shot.id, { ratio: e.target.value })}
                                                                    onClick={(e) => e.stopPropagation()}
                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                    className={`text-xs px-2 py-1 rounded border outline-none transition-colors ${
                                                                        theme === 'dark'
                                                                            ? 'bg-zinc-800 border-zinc-700 text-zinc-200 hover:border-zinc-600'
                                                                            : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                                    }`}
                                                                >
                                                                    {['16:9', '9:16', '1:1', '4:3', '3:4'].map(ratio => (
                                                                        <option key={ratio} value={ratio}>{ratio}</option>
                                                                    ))}
                                                                </select>
                                                                
                                                                {/* Duration Select */}
                                                                {(() => {
                                                                    const currentModel = shot.model || (apiConfigs.find(c => c.type === 'Video' && c.id === 'sora-2')?.id || apiConfigs.find(c => c.type === 'Video')?.id || '');
                                                                    const config = apiConfigs.find(c => c.id === currentModel);
                                                                    const availableDurations = config?.durations || getDefaultDurationsForModel(currentModel);
                                                                    const defaultDuration = getDefaultDurationForModel(currentModel);
                                                                    return (
                                                                        <select
                                                                            value={shot.duration || defaultDuration}
                                                                            onChange={(e) => updateShot(node.id, shot.id, { duration: e.target.value })}
                                                                            onClick={(e) => e.stopPropagation()}
                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                            className={`text-xs px-2 py-1 rounded border outline-none transition-colors ${
                                                                                theme === 'dark'
                                                                                    ? 'bg-zinc-800 border-zinc-700 text-zinc-200 hover:border-zinc-600'
                                                                                    : 'bg-white border-zinc-300 text-zinc-800 hover:border-zinc-400'
                                                                            }`}
                                                                        >
                                                                            {availableDurations.map(duration => (
                                                                                <option key={duration} value={duration}>{duration}</option>
                                                                            ))}
                                                                        </select>
                                                                    );
                                                                })()}
                                                            </div>
                                                            
                                                            <textarea 
                                                                className={`text-sm outline-none resize-none bg-transparent transition-all ${
                                                                    theme === 'dark' 
                                                                        ? 'text-zinc-200 placeholder:text-zinc-700' 
                                                                        : 'text-zinc-800 placeholder:text-zinc-400'
                                                                }`} 
                                                                value={shot.description || ''}
                                                                placeholder="画面描述..."
                                                                onChange={(e) => updateShot(node.id, shot.id, { description: e.target.value })}
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    // 确保点击文本框时也激活卡片
                                                                    if (!isActiveShot) {
                                                                        setActiveShot({ nodeId: node.id, shotId: shot.id });
                                                                    }
                                                                }}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                                onFocus={(e) => {
                                                                    e.stopPropagation();
                                                                    // 确保聚焦时激活卡片
                                                                    if (!isActiveShot) {
                                                                        setActiveShot({ nodeId: node.id, shotId: shot.id });
                                                                    }
                                                                }}
                                                                onInput={(e) => {
                                                                    // 输入时自动调整高度（仅在激活状态下）
                                                                    if (isActiveShot) {
                                                                        e.currentTarget.style.height = 'auto';
                                                                        e.currentTarget.style.height = e.currentTarget.scrollHeight + 'px';
                                                                    }
                                                                }}
                                                                ref={(el) => {
                                                                    // 当卡片激活时，自动调整高度以显示所有内容
                                                                    if (el && isActiveShot) {
                                                                        el.style.height = 'auto';
                                                                        el.style.height = el.scrollHeight + 'px';
                                                                    }
                                                                }}
                                                                style={{
                                                                    minHeight: isActiveShot ? '8rem' : '2.5rem',
                                                                    height: isActiveShot ? 'auto' : '2.5rem',
                                                                    transition: 'all 0.2s ease-in-out'
                                                                }}
                                                            />
                                                            <div className={`p-2 rounded text-xs font-mono border transition-all relative ${
                                                                theme === 'dark' 
                                                                    ? 'bg-zinc-950 border-zinc-800 text-zinc-400' 
                                                                    : 'bg-zinc-50 border-zinc-200 text-zinc-600'
                                                            }`}
                                                            style={{
                                                                minHeight: isActiveShot ? '8rem' : '2rem',
                                                                transition: 'all 0.2s ease-in-out'
                                                            }}>
                                                                <textarea
                                                                    className="w-full bg-transparent outline-none resize-none placeholder:text-opacity-50 transition-all pr-8"
                                                                    value={shot.prompt || ''}
                                                                    placeholder="等待生成提示词..."
                                                                    onChange={(e) => updateShot(node.id, shot.id, { prompt: e.target.value })}
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        // 确保点击文本框时也激活卡片
                                                                        if (!isActiveShot) {
                                                                            setActiveShot({ nodeId: node.id, shotId: shot.id });
                                                                        }
                                                                    }}
                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                    onFocus={(e) => {
                                                                        e.stopPropagation();
                                                                        // 确保聚焦时激活卡片
                                                                        if (!isActiveShot) {
                                                                            setActiveShot({ nodeId: node.id, shotId: shot.id });
                                                                        }
                                                                    }}
                                                                    onInput={(e) => {
                                                                        // 输入时自动调整高度（仅在激活状态下）
                                                                        if (isActiveShot) {
                                                                            e.currentTarget.style.height = 'auto';
                                                                            e.currentTarget.style.height = e.currentTarget.scrollHeight + 'px';
                                                                        }
                                                                    }}
                                                                    ref={(el) => {
                                                                        // 当卡片激活时，自动调整高度以显示所有内容
                                                                        if (el && isActiveShot) {
                                                                            el.style.height = 'auto';
                                                                            el.style.height = el.scrollHeight + 'px';
                                                                        }
                                                                    }}
                                                                    style={{
                                                                        minHeight: isActiveShot ? '8rem' : '2rem',
                                                                        height: isActiveShot ? 'auto' : '2rem',
                                                                        transition: 'all 0.2s ease-in-out'
                                                                    }}
                                                                />
                                                                {(shot.model === 'sora-2' || shot.model === 'sora-2-pro') && characterLibrary.length > 0 && (
                                                                    <button
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            setCharactersOpen(true);
                                                                        }}
                                                                        className={`absolute top-2 right-2 p-1 rounded transition-colors ${
                                                                            theme === 'dark'
                                                                                ? 'text-zinc-500 hover:text-zinc-200 hover:bg-zinc-800'
                                                                                : 'text-zinc-400 hover:text-zinc-700 hover:bg-zinc-200'
                                                                        }`}
                                                                        title="插入角色"
                                                                    >
                                                                        <Users size={12} />
                                                                    </button>
                                                                )}
                                                            </div>
                                                            
                                                            {/* 角色引用栏 (仅 Sora 模型) */}
                                                            {(() => {
                                                                const currentModel = shot.model || '';
                                                                const isSora = currentModel && (currentModel.includes('sora') || currentModel === 'sora-2' || currentModel === 'sora-2-pro');
                                                                
                                                                if (!isSora || characterLibrary.length === 0) return null;
                                                                
                                                                const currentPrompt = shot.prompt || '';
                                                                const expandKey = `${node.id}-${shot.id}`;
                                                                const isExpanded = characterReferenceBarExpanded[expandKey] || false;
                                                                const maxVisible = 5; // 最多显示5个角色，超过则显示展开按钮
                                                                const shouldShowExpand = characterLibrary.length > maxVisible;
                                                                
                                                                return (
                                                                    <div className="border-t border-dashed mt-1" style={{
                                                                        borderColor: theme === 'dark' ? 'rgba(63, 63, 70, 0.5)' : 'rgba(161, 161, 170, 0.5)'
                                                                    }}>
                                                                        <div className="flex items-center justify-between py-1 px-1">
                                                                            <div className="flex gap-2 overflow-x-auto py-2 flex-1 custom-scrollbar">
                                                                                {(isExpanded ? characterLibrary : characterLibrary.slice(0, maxVisible)).map(char => {
                                                                            const tag = `@${char.username}`;
                                                                            const isActive = currentPrompt.includes(tag);
                                                                            
                                                                            return (
                                                                                <button
                                                                                    key={char.id}
                                                                                    onClick={(e) => {
                                                                                        e.stopPropagation();
                                                                                        let newPrompt = currentPrompt || '';
                                                                                        if (isActive) {
                                                                                            // 移除标签，并清理多余空格
                                                                                            newPrompt = newPrompt.replace(tag, '').replace(/\s{2,}/g, ' ').trim();
                                                                                        } else {
                                                                                            // 添加标签到末尾（前后加空格）
                                                                                            newPrompt = newPrompt.trim();
                                                                                            newPrompt = newPrompt ? `${newPrompt} ${tag} ` : `${tag} `;
                                                                                        }
                                                                                        updateShot(node.id, shot.id, { prompt: newPrompt });
                                                                                    }}
                                                                                    className={`relative shrink-0 transition-all ${isActive ? 'scale-110' : 'opacity-70 hover:opacity-100'}`}
                                                                                    title={char.username}
                                                                                >
                                                                                    <img 
                                                                                        src={char.profile_picture_url || ''} 
                                                                                        alt={char.username}
                                                                                        className={`w-8 h-8 rounded-full object-cover border-2 ${
                                                                                            isActive 
                                                                                                ? 'border-blue-500 ring-2 ring-blue-500' 
                                                                                                : 'border-transparent'
                                                                                        }`}
                                                                                        onError={(e) => {
                                                                                            e.target.style.display = 'none';
                                                                                        }}
                                                                                    />
                                                                                    {/* 右下角显示小的链接图标表示可用 */}
                                                                                    <div className="absolute -bottom-0.5 -right-0.5 bg-black/50 rounded-full p-0.5">
                                                                                        <LinkIcon size={8} className="text-green-400" />
                                                                                    </div>
                                                                                </button>
                                                                            );
                                                                        })}
                                                                            </div>
                                                                            {shouldShowExpand && (
                                                                                <button
                                                                                    onClick={(e) => {
                                                                                        e.stopPropagation();
                                                                                        if (isExpanded) {
                                                                                            // 收起：关闭展开状态
                                                                                            setCharacterReferenceBarExpanded(prev => {
                                                                                                const updated = { ...prev };
                                                                                                delete updated[expandKey];
                                                                                                return updated;
                                                                                            });
                                                                                        } else {
                                                                                            // 展开：打开角色库侧边栏
                                                                                            setCharactersOpen(true);
                                                                                            setCharacterReferenceBarExpanded(prev => ({ ...prev, [expandKey]: true }));
                                                                                        }
                                                                                    }}
                                                                                    className={`shrink-0 px-2 py-1 text-[10px] rounded transition-colors ml-2 ${
                                                                                        theme === 'dark'
                                                                                            ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                                                            : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'
                                                                                    }`}
                                                                                    title={isExpanded ? "收起" : "打开角色库"}
                                                                                >
                                                                                    {isExpanded ? '收起' : `+${characterLibrary.length - maxVisible}`}
                                                                                </button>
                                                                            )}
                                                                        </div>
                                                                    </div>
                                                                );
                                                            })()}
                                                            
                                                            <div className="flex gap-1 flex-wrap items-center mt-1">
                                                                {shot.tags?.map((tag, tagIdx) => (
                                                                    <span key={tagIdx} className={`px-1.5 py-0.5 text-[10px] rounded border ${
                                                                        theme === 'dark' 
                                                                            ? 'bg-blue-900/30 text-blue-300 border-blue-800' 
                                                                            : 'bg-blue-50 text-blue-600 border-blue-200'
                                                                    }`}>{tag}</span>
                                                                ))}
                                                                {shot.camera && (
                                                                    <span className={`px-1.5 py-0.5 text-[10px] rounded border flex items-center gap-1 ${
                                                                        theme === 'dark' 
                                                                            ? 'bg-purple-900/30 text-purple-300 border-purple-800' 
                                                                            : 'bg-purple-50 text-purple-600 border-purple-200'
                                                                    }`}>
                                                                        <Video size={8} /> {shot.camera}
                                                                    </span>
                                                                )}
                                                                {shot.time_range && (
                                                                    <span className={`text-[10px] ml-auto font-mono ${
                                                                        theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'
                                                                    }`}>{shot.time_range}</span>
                                                                )}
                                                            </div>
                                                        </div>

                                                        {/* Actions */}
                                                        <div className={`flex flex-col gap-2 justify-center border-l pl-2 shrink-0 ${
                                                            theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                                        }`}>
                                                            <button 
                                                                onClick={() => generateSingleShot(node.id, shot)}
                                                                className={`p-1.5 rounded text-white shadow-sm transition-all active:scale-95 ${
                                                                    shot.status === 'generating' 
                                                                        ? 'bg-zinc-500 cursor-not-allowed' 
                                                                        : 'bg-green-600 hover:bg-green-500'
                                                                }`} 
                                                                title="生成此镜头"
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                                disabled={shot.status === 'generating'}
                                                            >
                                                                {shot.status === 'generating' ? (
                                                                    <Loader2 size={14} className="animate-spin" />
                                                                ) : (
                                                                    <Play size={14} fill="currentColor"/>
                                                                )}
                                                            </button>
                                                            <button 
                                                                onClick={() => deleteShot(node.id, shot.id)}
                                                                className={`p-1.5 transition-colors ${
                                                                    theme === 'dark' 
                                                                        ? 'text-zinc-600 hover:text-red-500' 
                                                                        : 'text-zinc-400 hover:text-red-600'
                                                                }`}
                                                                title="删除镜头"
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            >
                                                                <Trash2 size={14} />
                                                            </button>
                                                        </div>
                                                    </div>
                                                    );
                                                })
                                            ) : (
                                                <div className={`flex flex-col items-center justify-center h-40 gap-3 rounded-lg border-2 border-dashed ${
                                                    theme === 'dark' ? 'border-zinc-800 text-zinc-600' : 'border-zinc-300 text-zinc-400'
                                                }`}>
                                                    <LayoutGrid size={32} className="opacity-50" />
                                                    <span className="text-xs">暂无分镜，请添加或同步分析结果</span>
                                                </div>
                                            )}
                                        </div>
                                        
                                        {/* Footer */}
                                        <div className={`p-3 border-t shrink-0 ${
                                            theme === 'dark' ? 'bg-zinc-900 border-zinc-800' : 'bg-zinc-50 border-zinc-200'
                                        }`}>
                                            <button 
                                                onClick={() => addEmptyShot(node.id)}
                                                className={`w-full py-2 border border-dashed text-xs rounded transition-colors flex items-center justify-center gap-2 ${
                                                    theme === 'dark' 
                                                        ? 'border-zinc-700 text-zinc-400 hover:bg-zinc-800 hover:text-zinc-200' 
                                                        : 'border-zinc-300 text-zinc-500 hover:bg-white hover:text-blue-600 hover:border-blue-400'
                                                }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                            >
                                                <Plus size={14} /> 添加空白镜头
                                            </button>
                                        </div>
                                    </div>
                                );
                            })()}

                            {node.type === 'image-compare' && (
                                <div className="w-full h-full pointer-events-auto">
                                    <ImageCompareView 
                                        img1={connectedImages[0]} 
                                        img2={connectedImages[1]} 
                                    />
                                </div>
                            )}

                            {node.type === 'preview' && (
                                <div className="flex flex-col h-full pointer-events-auto">
                                    <div
                                        className={`flex items-center justify-between px-3 py-2 border-b text-xs font-semibold ${
                                            theme === 'dark'
                                                ? 'border-zinc-800 text-zinc-200'
                                                : 'border-zinc-200 text-zinc-700'
                                        }`}
                                    >
                                        <div className="flex items-center gap-1.5">
                                            <Maximize2 size={13} className="text-blue-500" />
                                            <span>预览窗口</span>
                                        </div>
                                        <span className="text-[10px] text-zinc-500">
                                            {node.previewType === 'video' ? '视频预览' : '图片预览'}
                                        </span>
                                    </div>
                                    <div className="flex-1 flex flex-col p-2 gap-2 min-h-0">
                                        <div
                                            className={`relative flex-1 rounded-lg overflow-hidden flex items-center justify-center min-h-0 ${
                                                theme === 'dark' ? 'bg-zinc-900' : 'bg-zinc-100'
                                            }`}
                                            onContextMenu={(e) => {
                                                const previewUrl = node.content || (node.previewMjImages && node.previewMjImages[0]);
                                                if (previewUrl) {
                                                    handlePreviewRightClick(e, { url: previewUrl, type: node.previewType || (isVideoUrl(previewUrl) ? 'video' : 'image'), sourceNode: node });
                                                }
                                            }}
                                            onDoubleClick={(e) => {
                                                e.stopPropagation();
                                                e.preventDefault();
                                                const previewUrl = node.content || (node.previewMjImages && node.previewMjImages[0]);
                                                if (previewUrl) {
                                                    setLightboxItem({ url: previewUrl, type: node.previewType || (isVideoUrl(previewUrl) ? 'video' : 'image') });
                                                }
                                            }}
                                        >
                                            {node.content || (node.previewMjImages && node.previewMjImages.length > 0) ? (
                                                isVideoUrl(node.content) || node.previewType === 'video' ? (
                                                    <video
                                                        src={node.content}
                                                        className="w-full h-full object-contain bg-black"
                                                        controls
                                                        draggable={false}
                                                    />
                                                ) : node.previewMjImages && (node.previewMjImages.length === 4 || node.previewMjImages.length > 1) ? (
                                                    // 多张图片网格显示（即梦回传的四张图）
                                                    <div className={`w-full h-full grid gap-0.5 p-0.5 ${node.previewMjImages.length === 4 ? 'grid-cols-2 grid-rows-2' : 'grid-cols-2'}`}>
                                                        {node.previewMjImages.map((imgUrl, idx) => (
                                                            <div
                                                                key={idx}
                                                                className="relative w-full h-full overflow-hidden bg-black flex items-center justify-center group"
                                                            >
                                                                <img 
                                                                    src={imgUrl} 
                                                                    className="max-w-full max-h-full w-auto h-auto object-contain" 
                                                                    alt={`预览图 ${idx + 1}`}
                                                                    draggable={false}
                                                                    style={{
                                                                        imageRendering: view.zoom < 1 ? 'crisp-edges' : 'auto',
                                                                        WebkitFontSmoothing: 'antialiased',
                                                                        transform: 'translateZ(0)',
                                                                        backfaceVisibility: 'hidden'
                                                                    }}
                                                                    onError={(e) => {
                                                                        console.error(`预览图片 ${idx + 1} 加载失败`);
                                                                        e.target.style.display = 'none';
                                                                    }}
                                                                    onLoad={(e) => {
                                                                        // 图片加载后，根据实际尺寸自适应
                                                                        const img = e.target;
                                                                        const container = img.parentElement;
                                                                        if (container && img.naturalWidth && img.naturalHeight) {
                                                                            const containerWidth = container.clientWidth;
                                                                            const containerHeight = container.clientHeight;
                                                                            
                                                                            // 如果图片比容器小，保持原始尺寸；否则按比例缩放
                                                                            if (img.naturalWidth <= containerWidth && img.naturalHeight <= containerHeight) {
                                                                                img.style.width = `${img.naturalWidth}px`;
                                                                                img.style.height = `${img.naturalHeight}px`;
                                                                                img.style.maxWidth = '100%';
                                                                                img.style.maxHeight = '100%';
                                                                            } else {
                                                                                img.style.width = '';
                                                                                img.style.height = '';
                                                                                img.style.maxWidth = '100%';
                                                                                img.style.maxHeight = '100%';
                                                                            }
                                                                        }
                                                                    }}
                                                                />
                                                                {/* 局部重绘按钮 */}
                                                                {node.type === 'gen-image' && !node.isMasking && (
                                                                    <div className="absolute inset-0 bg-black/40 transition-opacity opacity-0 group-hover:opacity-100 flex items-center justify-center">
                                                                        <button
                                                                            onClick={(e) => {
                                                                                e.stopPropagation();
                                                                                // 获取图片尺寸
                                                                                const img = e.target.closest('.group').querySelector('img');
                                                                                if (img && img.naturalWidth && img.naturalHeight) {
                                                                                    setNodes((prev) => prev.map((n) => 
                                                                                        n.id === node.id 
                                                                                            ? { 
                                                                                                ...n, 
                                                                                                isMasking: !n.isMasking,
                                                                                                maskingImageUrl: imgUrl,
                                                                                                maskingImageDimensions: { w: img.naturalWidth, h: img.naturalHeight }
                                                                                            }
                                                                                            : n
                                                                                    ));
                                                                                }
                                                                            }}
                                                                            className={`px-3 py-1.5 rounded-lg text-xs backdrop-blur-sm border transition-colors flex items-center gap-1 ${
                                                                                theme === 'dark'
                                                                                    ? node.isMasking
                                                                                        ? 'bg-red-500/80 hover:bg-red-500 text-white border-red-400'
                                                                                        : 'bg-white/10 hover:bg-white/20 text-white border-white/10'
                                                                                    : node.isMasking
                                                                                        ? 'bg-red-500 hover:bg-red-600 text-white border-red-400'
                                                                                        : 'bg-white hover:bg-zinc-100 text-zinc-800 border-zinc-300'
                                                                            }`}
                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                        >
                                                                            <Brush size={12} />
                                                                            局部重绘
                                                                        </button>
                                                                    </div>
                                                                )}
                                                                {/* 非编辑模式下的蒙版回显（gen-image 节点） */}
                                                                {node.type === 'gen-image' && !node.isMasking && node.maskContent && node.maskingImageUrl === imgUrl && (
                                                                    <div 
                                                                        className="absolute inset-0 z-20 pointer-events-none"
                                                                        style={{
                                                                            background: 'rgba(255, 0, 0, 0.3)',
                                                                            mixBlendMode: 'multiply',
                                                                            WebkitMaskImage: `url(${node.maskContent})`,
                                                                            maskImage: `url(${node.maskContent})`,
                                                                            WebkitMaskSize: '100% 100%',
                                                                            maskSize: '100% 100%',
                                                                            WebkitMaskRepeat: 'no-repeat',
                                                                            maskRepeat: 'no-repeat'
                                                                        }}
                                                                    />
                                                                )}
                                                                {/* MaskEditor 组件 */}
                                                                {node.type === 'gen-image' && node.isMasking && node.maskingImageUrl === imgUrl && node.maskingImageDimensions && (
                                                                    <MaskEditor
                                                                        nodeId={node.id}
                                                                        imageUrl={node.maskingImageUrl}
                                                                        imageDimensions={node.maskingImageDimensions}
                                                                        isActive={node.isMasking}
                                                                        onClose={() => {
                                                                            setNodes((prev) => prev.map((n) => 
                                                                                n.id === node.id 
                                                                                    ? { ...n, isMasking: false }
                                                                                    : n
                                                                            ));
                                                                        }}
                                                                        onSave={(maskDataUrl) => {
                                                                            console.log('蒙版已保存:', maskDataUrl);
                                                                        }}
                                                                        onUpdateNode={(nodeId, updates) => {
                                                                            setNodes((prev) => prev.map((n) => 
                                                                                n.id === nodeId 
                                                                                    ? { ...n, ...updates }
                                                                                    : n
                                                                            ));
                                                                        }}
                                                                        theme={theme}
                                                                        view={view}
                                                                        maskContent={node.maskContent}
                                                                    />
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                ) : (
                                                    <img
                                                        src={node.content}
                                                        className="max-w-full max-h-full w-auto h-auto object-contain bg-black"
                                                        draggable={false}
                                                        onLoad={(e) => {
                                                            // 图片加载后，根据实际尺寸自适应
                                                            const img = e.target;
                                                            const container = img.parentElement;
                                                            if (container && img.naturalWidth && img.naturalHeight) {
                                                                const containerWidth = container.clientWidth;
                                                                const containerHeight = container.clientHeight;
                                                                
                                                                // 如果图片比容器小，保持原始尺寸；否则按比例缩放
                                                                if (img.naturalWidth <= containerWidth && img.naturalHeight <= containerHeight) {
                                                                    img.style.width = `${img.naturalWidth}px`;
                                                                    img.style.height = `${img.naturalHeight}px`;
                                                                    img.style.maxWidth = '100%';
                                                                    img.style.maxHeight = '100%';
                                                                } else {
                                                                    img.style.width = '';
                                                                    img.style.height = '';
                                                                    img.style.maxWidth = '100%';
                                                                    img.style.maxHeight = '100%';
                                                                }
                                                            }
                                                        }}
                                                    />
                                                )
                                            ) : (
                                                <div
                                                    className={`flex flex-col items-center justify-center text-[11px] ${
                                                        theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'
                                                    }`}
                                                >
                                                    <ImageIcon className="w-6 h-6 mb-1 text-zinc-400" />
                                                    <span>连接 AI 绘图 / AI 视频 节点</span>
                                                    <span>或从历史记录发送到此处进行预览</span>
                                                </div>
                                            )}
                                        </div>
                                        <div className="flex items-center justify-between gap-2 text-[11px]">
                                            <button
                                                className={`flex-1 inline-flex items-center justify-center gap-1 px-2 py-1 rounded border ${
                                                    theme === 'dark'
                                                        ? 'border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                                        : 'border-zinc-300 text-zinc-700 hover:bg-zinc-100'
                                                }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={async () => {
                                                    if (!node.content) return;
                                                    try {
                                                        await navigator.clipboard.writeText(node.content);
                                                    } catch {}
                                                }}
                                            >
                                                <CopyPlus size={13} />
                                                复制链接
                                            </button>
                                            <button
                                                className={`flex-1 inline-flex items-center justify-center gap-1 px-2 py-1 rounded border ${
                                                    theme === 'dark'
                                                        ? 'border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                                        : 'border-zinc-300 text-zinc-700 hover:bg-zinc-100'
                                                }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={async () => {
                                                    if (!node.content) return;
                                                    const world = screenToWorld(node.x + node.width + 100, node.y + node.height / 2);
                                                    let dims;
                                                    if (!isVideoUrl(node.content)) {
                                                        try {
                                                            const real = await getImageDimensions(node.content);
                                                            if (real?.w && real?.h) dims = { w: real.w, h: real.h };
                                                        } catch {}
                                                    }
                                                    addNode('input-image', world.x, world.y, null, node.content, dims);
                                                }}
                                            >
                                                <ArrowRightSquare size={13} />
                                                发送到画布
                                            </button>
                                            <button
                                                className={`flex-1 inline-flex items-center justify-center gap-1 px-2 py-1 rounded border ${
                                                    theme === 'dark'
                                                        ? 'border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                                        : 'border-zinc-300 text-zinc-700 hover:bg-zinc-100'
                                                }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={() => {
                                                    if (!node.content) return;
                                                    const newFile = {
                                                        name: node.previewType === 'video' ? 'Preview.mp4' : 'Preview.png',
                                                        type: node.previewType === 'video' ? 'video/mp4' : 'image/png',
                                                        content: node.content,
                                                        isImage: node.previewType !== 'video',
                                                        isVideo: node.previewType === 'video',
                                                        isAudio: false,
                                                        fromPreview: true
                                                    };
                                                    setChatFiles((prev) => [...prev, newFile]);
                                                    setIsChatOpen(true);
                                                }}
                                            >
                                                <MessageSquare size={13} />
                                                发送到对话
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {(node.type === 'gen-image' || node.type === 'gen-video') && (() => {
                                // 查找当前节点对应的正在生成的历史记录
                                const activeTask = history.find(h => 
                                    h.sourceNodeId === node.id && 
                                    (h.status === 'generating' || h.status === 'completed')
                                );
                                const isGenerating = activeTask && activeTask.status === 'generating';
                                const finalDuration = activeTask?.durationMs 
                                    ? (activeTask.durationMs / 1000).toFixed(1) 
                                    : null;
                                const elapsedSeconds = nodeTimers[node.id] || 0;
                                
                                return (
                                <div className="p-3 flex flex-col h-full pointer-events-auto">
                                    {/* 计时器显示 */}
                                    {(isGenerating || finalDuration) && (
                                        <div
                                            className={`mb-2 px-2 py-1 rounded text-[10px] font-mono text-center ${
                                                theme === 'dark'
                                                    ? 'bg-blue-500/20 text-blue-400 border border-blue-500/30'
                                                    : 'bg-blue-50 text-blue-600 border border-blue-200'
                                            }`}
                                        >
                                            {isGenerating ? (
                                                <span>⏱ {elapsedSeconds.toFixed(1)}s</span>
                                            ) : (
                                                <span>✓ 完成 {finalDuration}s</span>
                                            )}
                                        </div>
                                    )}
                                    <div
                                        className={`flex items-center gap-1.5 mb-2 text-xs font-semibold shrink-0 ${
                                            theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                        }`}
                                    >
                                        {node.type === 'gen-image' ? <Wand2 size={12} className="text-blue-400" /> : <Video size={12} className="text-purple-400" />}
                                        <span>{node.type === 'gen-image' ? 'AI 绘图' : 'AI 视频'}</span>
                                    </div>
                                    {connectedImages.length > 0 && (
                                        <div
                                            className={`mb-2 rounded-lg border p-2 relative group/ref ${
                                                theme === 'dark'
                                                    ? 'bg-zinc-900/50 border-purple-500/20'
                                                    : 'bg-violet-50 border-violet-200'
                                            }`}
                                        >
                                             <div className="flex justify-between items-center mb-1.5">
                                                <span
                                                    className={`text-[10px] font-medium flex items-center gap-1 ${
                                                        theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                                    }`}
                                                >
                                                    <ImagePlus size={10} />
                                                    引用成功
                                                </span>
                                                <span
                                                    className={`text-[9px] font-mono ${
                                                        theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'
                                                    }`}
                                                >
                                                    {connectedImages.length}/10
                                                </span>
                                             </div>
                                             <div className="flex -space-x-2 overflow-visible pb-1 items-center custom-scrollbar pl-1">
                                                {connectedImages.map((imgSrc, idx) => (
                                                    <div
                                                        key={idx}
                                                        className={`relative shrink-0 flex flex-col items-center gap-0 ${
                                                            theme === 'dark' ? '' : ''
                                                        }`}
                                                    >
                                                        <div className="relative">
                                                            <span
                                                                className="absolute -top-1 -left-1 w-4 h-4 text-[9px] font-semibold rounded-full bg-zinc-700 text-white select-none flex items-center justify-center border border-white/70 shadow-sm leading-none pointer-events-none"
                                                                style={{ zIndex: 30 }}
                                                            >
                                                                {idx + 1}
                                                            </span>
                                                            <div
                                                                className={`relative w-8 h-8 rounded-full border-2 thumb-stack-item cursor-pointer overflow-hidden ${
                                                                    theme === 'dark'
                                                                        ? 'border-[#18181b] bg-zinc-800'
                                                                        : 'border-white bg-zinc-200'
                                                                }`}
                                                                style={{ zIndex: 10 - idx }}
                                                            >
                                                                <img src={imgSrc} className="w-full h-full object-cover" />
                                                            </div>
                                                        </div>
                                                    </div>
                                                ))}
                                             </div>
                                        </div>
                                    )}
                                    <div
                                        className={`rounded-lg p-3 mb-2 border focus-within:border-blue-500/30 transition-colors flex-1 flex flex-col ${
                                            theme === 'dark'
                                                ? 'bg-zinc-950/50 border-zinc-800'
                                                : 'bg-zinc-50 border-zinc-200'
                                        }`}
                                    >
                                        {/* 蒙版已连接状态提示（仅 gen-image 节点） */}
                                        {node.type === 'gen-image' && (() => {
                                            // 检查当前节点或上游节点是否有蒙版
                                            const hasMaskInCurrent = node?.maskContent;
                                            
                                            // 查找连接到当前节点的源节点（优先查找 default 输入，如果没有则查找所有输入）
                                            let incomingConn = connections.find(c => c.to === node.id && (!c.inputType || c.inputType === 'default'));
                                            if (!incomingConn) {
                                                // 如果没有 default 连接，查找任何连接到该节点的连接
                                                incomingConn = connections.find(c => c.to === node.id);
                                            }
                                            
                                            // 使用 nodesMap 进行 O(1) 查找
                                            const sourceNode = incomingConn ? nodesMap.get(incomingConn.from) : null;
                                            const hasMaskFromSource = sourceNode && sourceNode.maskContent;
                                            const hasMask = hasMaskInCurrent || hasMaskFromSource;
                                            
                                            if (hasMask) {
                                                return (
                                                    <div className={`flex items-center gap-1.5 mb-2 px-2 py-1 rounded text-[10px] font-medium ${
                                                        theme === 'dark'
                                                            ? 'bg-purple-900/30 text-purple-300 border border-purple-800'
                                                            : 'bg-purple-50 text-purple-600 border border-purple-200'
                                                    }`}>
                                                        <Eraser size={12} />
                                                        <span>{hasMaskFromSource ? '已链接蒙版区域' : '已设置蒙版区域'}</span>
                                                    </div>
                                                );
                                            }
                                            return null;
                                        })()}
                                        <div className="flex items-start gap-2 mb-1 flex-1 h-full min-h-0">
                                        <textarea
                                                className={`flex-1 h-full bg-transparent text-xs outline-none resize-none custom-scrollbar ${
                                                theme === 'dark'
                                                    ? 'text-zinc-300 placeholder-zinc-600'
                                                    : 'text-zinc-800 placeholder-zinc-400'
                                            }`}
                                            placeholder="输入提示词..."
                                            value={node.type === 'gen-image' ? (node.settings?.prompt || '') : (node.settings?.videoPrompt || '')}
                                            onChange={(e) => updateNodeSettings(node.id, node.type === 'gen-image' ? { prompt: e.target.value } : { videoPrompt: e.target.value })}
                                            onMouseDown={(e) => e.stopPropagation()}
                                        />
                                            {(node.type === 'gen-video' && (node.settings?.model === 'sora-2' || node.settings?.model === 'sora-2-pro')) && characterLibrary.length > 0 && (
                                                <div className="relative shrink-0">
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            setCharactersOpen(true);
                                                        }}
                                                        className={`p-1.5 rounded transition-colors ${
                                                            theme === 'dark'
                                                                ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                                                : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                                        }`}
                                                        title="插入角色"
                                                    >
                                                        <Users size={14} />
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                    
                                    {/* 角色引用栏 (仅 Sora 模型) */}
                                    {node.type === 'gen-video' && (() => {
                                        const currentModel = node.settings?.model || '';
                                        const modelConfig = apiConfigsMap.get(currentModel);
                                        const modelName = modelConfig?.modelName || modelConfig?.id || currentModel;
                                        const isSora = modelName && (modelName.includes('sora') || currentModel.includes('sora'));
                                        
                                        if (!isSora || characterLibrary.length === 0) return null;
                                        
                                        const currentPrompt = node.settings?.videoPrompt || '';
                                        const isExpanded = characterReferenceBarExpanded[node.id] || false;
                                        const maxVisible = 5; // 最多显示5个角色，超过则显示展开按钮
                                        const shouldShowExpand = characterLibrary.length > maxVisible;
                                        
                                        return (
                                            <div className="border-t border-dashed mt-1" style={{
                                                borderColor: theme === 'dark' ? 'rgba(63, 63, 70, 0.5)' : 'rgba(161, 161, 170, 0.5)'
                                            }}>
                                                <div className="flex items-center justify-between py-1 px-1">
                                                    <div className="flex gap-2 overflow-x-auto py-2 flex-1 custom-scrollbar">
                                                        {(isExpanded ? characterLibrary : characterLibrary.slice(0, maxVisible)).map(char => {
                                                    const tag = `@${char.username}`;
                                                    const isActive = currentPrompt.includes(tag);
                                                    
                                                    return (
                                                        <button
                                                            key={char.id}
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                let newPrompt = currentPrompt || '';
                                                                if (isActive) {
                                                                    // 移除标签，并清理多余空格
                                                                    newPrompt = newPrompt.replace(tag, '').replace(/\s{2,}/g, ' ').trim();
                                                                } else {
                                                                    // 添加标签到末尾（前后加空格）
                                                                    newPrompt = newPrompt.trim();
                                                                    newPrompt = newPrompt ? `${newPrompt} ${tag} ` : `${tag} `;
                                                                }
                                                                updateNodeSettings(node.id, { videoPrompt: newPrompt });
                                                            }}
                                                            className={`relative shrink-0 transition-all ${isActive ? 'scale-110' : 'opacity-70 hover:opacity-100'}`}
                                                            title={char.username}
                                                        >
                                                            <img 
                                                                src={char.profile_picture_url || ''} 
                                                                alt={char.username}
                                                                className={`w-8 h-8 rounded-full object-cover border-2 ${
                                                                    isActive 
                                                                        ? 'border-blue-500 ring-2 ring-blue-500' 
                                                                        : 'border-transparent'
                                                                }`}
                                                                onError={(e) => {
                                                                    e.target.style.display = 'none';
                                                                }}
                                                            />
                                                            {/* 右下角显示小的链接图标表示可用 */}
                                                            <div className="absolute -bottom-0.5 -right-0.5 bg-black/50 rounded-full p-0.5">
                                                                <LinkIcon size={8} className="text-green-400" />
                                                            </div>
                                                        </button>
                                                    );
                                                        })}
                                                    </div>
                                                    {shouldShowExpand && (
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                if (isExpanded) {
                                                                    // 收起：关闭展开状态
                                                                    setCharacterReferenceBarExpanded(prev => {
                                                                        const updated = { ...prev };
                                                                        delete updated[node.id];
                                                                        return updated;
                                                                    });
                                                                } else {
                                                                    // 展开：打开角色库侧边栏
                                                                    setCharactersOpen(true);
                                                                    setCharacterReferenceBarExpanded(prev => ({ ...prev, [node.id]: true }));
                                                                }
                                                            }}
                                                            className={`shrink-0 px-2 py-1 text-[10px] rounded transition-colors ml-2 ${
                                                                theme === 'dark'
                                                                    ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                                    : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'
                                                            }`}
                                                            title={isExpanded ? "收起" : "打开角色库"}
                                                        >
                                                            {isExpanded ? '收起' : `+${characterLibrary.length - maxVisible}`}
                                                        </button>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    })()}
                                    
                                    {/* Midjourney指令UI: oref, ow, sref */}
                                    {node.type === 'gen-image' && (() => {
                                        const currentModel = apiConfigsMap.get(node.settings?.model);
                                        const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                        return isMidjourney;
                                    })() && (() => {
                                        const orefConnected = getConnectedImageForInput(node.id, 'oref');
                                        const srefConnected = getConnectedImageForInput(node.id, 'sref');
                                        return (
                                            <div className="flex flex-col gap-1.5 mb-2 relative" data-mj-instructions="true">
                                                {/* oref指令 */}
                                                <div className="relative flex items-center gap-1.5" data-mj-oref="true">
                                                    <div className={`input-point ${orefConnected ? 'connected' : ''} ${connectingTarget === node.id && connectingInputType === 'oref' ? 'active' : ''}`} 
                                                         title="oref输入" 
                                                         onMouseDown={(e) => { 
                                                             e.stopPropagation(); 
                                                             e.preventDefault(); 
                                                             // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                                                             const world = screenToWorld(e.clientX, e.clientY);
                                                             setMousePos(world); 
                                                             setConnectingTarget(node.id); 
                                                             setConnectingInputType('oref'); 
                                                         }}
                                                         onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'oref')}
                                                         data-input-type="oref"
                                                         style={{ position: 'absolute', top: '50%', left: '-0.25rem', transform: 'translateY(-50%)', width: '0.5rem', height: '0.5rem', marginRight: '0.25rem', zIndex: 20, cursor: 'crosshair' }}
                                                    />
                                                    <div className="flex items-center gap-1.5 flex-1 ml-2">
                                                        <span className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>oref</span>
                                                        {orefConnected && (
                                                            <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>
                                                        )}
                                                    </div>
                                                </div>
                                                
                                                {/* ow指令 */}
                                                <div className="relative flex items-center gap-1.5">
                                                    <div className="w-0.5rem h-0.5rem mr-0.25rem ml-2"></div>
                                                    <div className="flex items-center gap-1.5 flex-1">
                                                        <span className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>ow</span>
                                                        {node.settings?.mjOw && node.settings.mjOw > 0 && (
                                                            <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>
                                                        )}
                                                    </div>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        max="1000"
                                                        placeholder="1-1000"
                                                        value={node.settings?.mjOw || ''}
                                                        onChange={(e) => {
                                                            const val = parseInt(e.target.value, 10);
                                                            if (isNaN(val) || val < 1) {
                                                                updateNodeSettings(node.id, { mjOw: '' });
                                                            } else if (val > 1000) {
                                                                updateNodeSettings(node.id, { mjOw: 1000 });
                                                            } else {
                                                                updateNodeSettings(node.id, { mjOw: val });
                                                            }
                                                        }}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        className={`flex-1 px-2 py-1 rounded text-[10px] border outline-none focus:border-blue-500/50 ${
                                                            theme === 'dark'
                                                                ? 'bg-zinc-900/50 border-zinc-700 text-zinc-300 placeholder-zinc-600'
                                                                : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                                        }`}
                                                    />
                                                </div>
                                                
                                                {/* sref指令 */}
                                                <div className="relative flex items-center gap-1.5" data-mj-sref="true">
                                                    <div className={`input-point ${srefConnected ? 'connected' : ''} ${connectingTarget === node.id && connectingInputType === 'sref' ? 'active' : ''}`} 
                                                         title="sref输入" 
                                                         onMouseDown={(e) => { 
                                                             e.stopPropagation(); 
                                                             e.preventDefault(); 
                                                             // 立即计算并更新当前鼠标的世界坐标，防止线条乱飞
                                                             const world = screenToWorld(e.clientX, e.clientY);
                                                             setMousePos(world); 
                                                             setConnectingTarget(node.id); 
                                                             setConnectingInputType('sref'); 
                                                         }}
                                                         onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'sref')}
                                                         data-input-type="sref"
                                                         style={{ position: 'absolute', top: '50%', left: '-0.25rem', transform: 'translateY(-50%)', width: '0.5rem', height: '0.5rem', marginRight: '0.25rem', zIndex: 20, cursor: 'crosshair' }}
                                                    />
                                                    <div className="flex items-center gap-1.5 flex-1 ml-2">
                                                        <span className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>sref</span>
                                                        {srefConnected && (
                                                            <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })()}
                                    {node.type === 'gen-image' && isNanoBanana2 && (
                                        <div
                                            className={`mb-2 rounded-lg border p-3 space-y-2 ${
                                                theme === 'dark'
                                                    ? 'bg-zinc-900/50 border-zinc-800'
                                                    : 'bg-white border-zinc-200'
                                            }`}
                                        >
                                            <div className="flex items-center justify-between">
                                                <button
                                                    className="flex items-center gap-1 text-[11px] font-semibold"
                                                    onClick={() => setPromptLibraryCollapsed((v) => !v)}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    <span className={theme === 'dark' ? 'text-zinc-200' : 'text-zinc-700'}>常用提示词库</span>
                                                    <ChevronRight
                                                        size={12}
                                                        className={`transition-transform ${promptLibraryCollapsed ? '' : 'rotate-90'} ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}
                                                    />
                                                </button>
                                                <div className="flex items-center gap-2 text-[10px]">
                                                    <span className={theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'}>{promptLibrary.length} 项</span>
                                                    <button
                                                        className={`px-2 py-0.5 rounded text-[10px] border ${theme === 'dark' ? 'border-zinc-700 text-zinc-300 hover:bg-zinc-800' : 'border-zinc-300 text-zinc-700 hover:bg-zinc-100'}`}
                                                        onClick={() => setPromptLibraryEditorOpen((v) => !v)}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        {promptLibraryEditorOpen ? '收起' : '管理'}
                                                    </button>
                                                </div>
                                            </div>
                                            {!promptLibraryCollapsed && (
                                                <div className="space-y-2">
                                                    <div className="max-h-36 overflow-y-auto custom-scrollbar flex flex-wrap gap-2">
                                                        {promptLibrary.map((item) => (
                                                            <div
                                                                key={item.id}
                                                                className={`border rounded-lg px-2 py-1.5 flex items-center gap-2 text-[11px] ${theme === 'dark' ? 'border-zinc-700 bg-zinc-950/50 text-zinc-200' : 'border-zinc-200 bg-zinc-50 text-zinc-700'}`}
                                                            >
                                                                <span className="font-medium whitespace-nowrap">{item.name}</span>
                                                                <button
                                                                    onClick={() => applyLibraryPrompt(node.id, item.prompt)}
                                                                    className="px-2 py-0.5 rounded text-[10px] bg-blue-600 text-white hover:bg-blue-500 transition-colors"
                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                >
                                                                    应用
                                                                </button>
                                                                {promptLibraryEditorOpen && (
                                                                    <button
                                                                        onClick={() => removePromptLibraryItem(item.id)}
                                                                        className={`px-2 py-0.5 rounded text-[10px] border ${theme === 'dark' ? 'border-red-500/50 text-red-400 hover:bg-red-500/10' : 'border-red-200 text-red-600 hover:bg-red-50'}`}
                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                    >
                                                                        删除
                                                                    </button>
                                                                )}
                                                            </div>
                                                        ))}
                                                        {promptLibrary.length === 0 && (
                                                            <div className={`text-[11px] ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`}>暂无常用提示词</div>
                                                        )}
                                                    </div>
                                                    {promptLibraryEditorOpen && (
                                                        <div className="grid grid-cols-1 gap-1.5">
                                                            <input
                                                                type="text"
                                                                value={promptLibraryForm.name}
                                                                onChange={(e) => setPromptLibraryForm((prev) => ({ ...prev, name: e.target.value }))}
                                                                placeholder="自定义名称（例如：柔光人像）"
                                                                className={`w-full px-2 py-1 text-[11px] rounded border ${theme === 'dark' ? 'bg-zinc-900 border-zinc-700 text-zinc-200 placeholder:text-zinc-600' : 'bg-white border-zinc-300 text-zinc-800 placeholder:text-zinc-400'}`}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            />
                                                            <textarea
                                                                value={promptLibraryForm.prompt}
                                                                onChange={(e) => setPromptLibraryForm((prev) => ({ ...prev, prompt: e.target.value }))}
                                                                placeholder="输入提示词内容..."
                                                                className={`w-full min-h-[70px] px-2 py-1 text-[11px] rounded border resize-none custom-scrollbar ${theme === 'dark' ? 'bg-zinc-900 border-zinc-700 text-zinc-200 placeholder:text-zinc-600' : 'bg-white border-zinc-300 text-zinc-800 placeholder:text-zinc-400'}`}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            />
                                                            <button
                                                                onClick={addPromptLibraryItem}
                                                                className="w-full py-1.5 rounded text-[11px] font-medium bg-blue-600 hover:bg-blue-500 text-white transition-colors"
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            >
                                                                添加到常用提示词库
                                                            </button>
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    )}
                                    <div
                                        className={`mt-auto pt-2 flex items-center justify-between shrink-0 relative gap-2 border-t ${
                                            theme === 'dark' ? 'border-zinc-800/50' : 'border-zinc-200'
                                        }`}
                                    >
                                        <div className="relative flex-1 min-w-0">
                                            <button 
                                                title={apiConfigsMap.get(node.settings?.model)?.provider}
                                                onClick={(e) => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'model' ? null : { nodeId: node.id, type: 'model' }); }} 
                                                className={`flex items-center gap-2 pl-1 pr-2 py-1 rounded text-[10px] transition-colors border w-full ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-300 border-zinc-700/50'
                                                        : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-700 border-zinc-300'
                                                }`}
                                            >
                                                <span className={`w-2 h-2 rounded-full ${getStatusColor(node.settings?.model)}`}></span>
                                                <span className="truncate">{apiConfigsMap.get(node.settings?.model)?.provider || 'Model'}</span>
                                            </button>
                                            {activeDropdown?.nodeId === node.id && activeDropdown.type === 'model' && (
                                                <div
                                                    className={`absolute bottom-full left-0 mb-1 w-48 rounded-lg shadow-xl p-1 z-[60] border ${
                                                        theme === 'dark'
                                                            ? 'bg-[#18181b] border-zinc-700'
                                                            : 'bg-white border-zinc-200'
                                                    }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    {apiConfigs
                                                        .filter((m) => m.type === (node.type === 'gen-image' ? 'Image' : 'Video') && !DELETED_MODEL_IDS.includes(m.id))
                                                        .map((m) => (
                                                            <button
                                                                key={m.id}
                                                                onClick={() => {
                                                                    const nextSettings = { model: m.id };
                                                                    if (m.id === 'grok-3') {
                                                                        nextSettings.ratio = '3:2';
                                                                        nextSettings.duration = '8s';
                                                                        nextSettings.resolution = '1080P';
                                                                    }
                                                                    updateNodeSettings(node.id, nextSettings);
                                                                    setActiveDropdown(null);
                                                                }}
                                                                className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${
                                                                    theme === 'dark'
                                                                        ? 'hover:bg-zinc-800 text-zinc-300'
                                                                        : 'hover:bg-zinc-100 text-zinc-700'
                                                                }`}
                                                            >
                                                            <span className="text-xs font-medium">{m.provider}</span>
                                                            <div className={`w-1.5 h-1.5 rounded-full ${getStatusColor(m.id)}`}></div>
                                                        </button>
                                                    ))}
                                                </div>
                                            )}
                                        </div>

                                        {/* Midjourney版本选择器 */}
                                        {node.type === 'gen-image' && (() => {
                                            const currentModel = apiConfigsMap.get(node.settings?.model);
                                            return currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                        })() && (
                                            <div className="relative flex-1 min-w-0">
                                                <button
                                                    title={MJ_VERSIONS.find(v => v.value === node.settings?.mjVersion)?.label || 'MJ V7'}
                                                    onClick={(e) => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'mjVersion' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'mjVersion' }); }}
                                                    className={`flex items-center gap-2 pl-1 pr-2 py-1 rounded text-[10px] transition-colors border w-full ${
                                                        theme === 'dark'
                                                            ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-300 border-zinc-700/50'
                                                            : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-700 border-zinc-300'
                                                    }`}
                                                >
                                                    <span className="truncate">{MJ_VERSIONS.find(v => v.value === node.settings?.mjVersion)?.label || 'MJ V7'}</span>
                                                </button>
                                                {activeDropdown?.nodeId === node.id && activeDropdown.type === 'mjVersion' && (
                                                    <div
                                                        className={`absolute bottom-full left-0 mb-1 w-32 rounded-lg shadow-xl p-1 z-[60] border max-h-64 overflow-y-auto custom-scrollbar ${
                                                            theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : 'bg-white border-zinc-200'
                                                        }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        {MJ_VERSIONS.map((v) => (
                                                            <button
                                                                key={v.value}
                                                                onClick={() => {
                                                                    updateNodeSettings(node.id, { mjVersion: v.value });
                                                                    setActiveDropdown(null);
                                                                }}
                                                                className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${
                                                                    theme === 'dark'
                                                                        ? 'hover:bg-zinc-800 text-zinc-300'
                                                                        : 'hover:bg-zinc-100 text-zinc-700'
                                                                } ${node.settings?.mjVersion === v.value ? (theme === 'dark' ? 'bg-zinc-800' : 'bg-zinc-100') : ''}`}
                                                            >
                                                                <span className="text-xs font-medium">{v.label}</span>
                                                                {node.settings?.mjVersion === v.value && (
                                                                    <svg className="w-3 h-3 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                                                                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                                                                    </svg>
                                                                )}
                                                            </button>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                        )}

                                        <div className="flex gap-1 shrink-0">
                                            <div className="relative">
                                                <button
                                                    onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'ratio' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'ratio' }); }}
                                                    className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${
                                                        theme === 'dark'
                                                            ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                            : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                    }`}
                                                >
                                                    {node.settings?.ratio || 'Auto'}
                                                </button>
                                                {activeDropdown?.nodeId === node.id && activeDropdown.type === 'ratio' && (
                                                    <div
                                                        className={`absolute bottom-full left-1/2 -translate-x-1/2 mb-1 w-20 rounded-lg shadow-xl p-1 z-[60] border ${
                                                            theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : 'bg-white border-zinc-200'
                                                        }`}
                                                        onMouseDown={e => e.stopPropagation()}
                                                    >
                                                        {getRatiosForModel(node.settings?.model).map(r => (
                                                            <button
                                                                key={r}
                                                                onClick={() => {
                                                                    updateNodeSettings(node.id, { ratio: r });
                                                                    setActiveDropdown(null);
                                                                }}
                                                                className={`w-full text-center py-1 text-[10px] rounded ${
                                                                    theme === 'dark'
                                                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                                                        : 'text-zinc-700 hover:bg-zinc-100'
                                                                }`}
                                                            >
                                                                {r}
                                                            </button>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>

                                            {node.type === 'gen-video' && (() => {
                                                const currentModel = apiConfigsMap.get(node.settings?.model);
                                                const modelId = currentModel?.id || currentModel?.modelName || '';
                                                const isGrok = modelId.includes('grok');
                                                return isGrok ? (
                                                <div className="relative">
                                                    <button
                                                        onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'vres' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'vres' }); }}
                                                        className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${
                                                            theme === 'dark'
                                                                ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                        }`}
                                                    >
                                                        {node.settings?.resolution || '1080P'}
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'vres' && (
                                                        <div
                                                            className={`absolute bottom-full left-1/2 -translate-x-1/2 mb-1 w-24 rounded-lg shadow-xl p-1 z-[60] border ${
                                                                theme === 'dark'
                                                                    ? 'bg-[#18181b] border-zinc-700'
                                                                    : 'bg-white border-zinc-200'
                                                            }`}
                                                            onMouseDown={e => e.stopPropagation()}
                                                        >
                                                            {VIDEO_RES_OPTIONS.map(r => (
                                                                <button
                                                                    key={r}
                                                                    onClick={() => {
                                                                        updateNodeSettings(node.id, { resolution: r });
                                                                        setActiveDropdown(null);
                                                                    }}
                                                                    className={`w-full text-center py-1 text-[10px] rounded ${
                                                                        theme === 'dark'
                                                                            ? 'text-zinc-300 hover:bg-zinc-800'
                                                                            : 'text-zinc-700 hover:bg-zinc-100'
                                                                    }`}
                                                                >
                                                                    {r}
                                                                </button>
                                                            ))}
                                                        </div>
                                                    )}
                                                </div>
                                                ) : null;
                                            })()}

                                            {node.type === 'gen-image' && (() => {
                                                const currentModel = apiConfigsMap.get(node.settings?.model);
                                                const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                                return !isMidjourney;
                                            })() ? (
                                                <div className="relative">
                                                    <button
                                                        onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'res' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'res' }); }}
                                                        className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${
                                                            theme === 'dark'
                                                                ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                        }`}
                                                    >
                                                        {(() => {
                                                            const currentModel = apiConfigsMap.get(node.settings?.model);
                                                            const modelId = currentModel?.id || currentModel?.modelName || '';
                                                            const availableResolutions = getResolutionsForModel(modelId);
                                                            const currentResolution = node.settings?.resolution || 'Auto';
                                                            // 如果当前分辨率不在可用选项中，使用第一个可用选项作为显示值
                                                            const displayResolution = availableResolutions.includes(currentResolution) 
                                                                ? currentResolution 
                                                                : (availableResolutions[0] || 'Auto');
                                                            // 如果当前分辨率不在可用选项中，自动更新
                                                            if (!availableResolutions.includes(currentResolution) && availableResolutions.length > 0) {
                                                                setTimeout(() => {
                                                                    updateNodeSettings(node.id, { resolution: availableResolutions[0] });
                                                                }, 0);
                                                            }
                                                            return displayResolution;
                                                        })()}
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'res' && (() => {
                                                        const currentModel = apiConfigsMap.get(node.settings?.model);
                                                        const modelId = currentModel?.id || currentModel?.modelName || '';
                                                        const availableResolutions = getResolutionsForModel(modelId);
                                                        return (
                                                            <div
                                                                className={`absolute bottom-full right-0 mb-1 w-24 rounded-lg shadow-xl p-1 z-[60] border ${
                                                                    theme === 'dark'
                                                                        ? 'bg-[#18181b] border-zinc-700'
                                                                        : 'bg-white border-zinc-200'
                                                                }`}
                                                                onMouseDown={e => e.stopPropagation()}
                                                            >
                                                                {availableResolutions.map(r => (
                                                                    <button
                                                                        key={r}
                                                                        onClick={() => {
                                                                            updateNodeSettings(node.id, { resolution: r });
                                                                            setActiveDropdown(null);
                                                                        }}
                                                                        className={`w-full text-center py-1 text-[10px] rounded ${
                                                                            theme === 'dark'
                                                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                                                : 'text-zinc-700 hover:bg-zinc-100'
                                                                        }`}
                                                                    >
                                                                        {r}
                                                                    </button>
                                                                ))}
                                                            </div>
                                                        );
                                                    })()}
                                                </div>
                                            ) : (
                                                (() => {
                                                    const currentModel = apiConfigsMap.get(node.settings?.model);
                                                    const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                                    return !isMidjourney ? (
                                                <>
                                                <div className="relative">
                                                            <button
                                                                onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'duration' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'duration' }); }}
                                                                className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${
                                                                    theme === 'dark'
                                                                        ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                        : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                                }`}
                                                            >
                                                        {node.settings?.duration || '5s'}
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'duration' && (
                                                                <div
                                                                    className={`absolute bottom-full left-1/2 -translate-x-1/2 mb-1 w-20 rounded-lg shadow-xl p-1 z-[60] border ${
                                                                        theme === 'dark'
                                                                            ? 'bg-[#18181b] border-zinc-700'
                                                                            : 'bg-white border-zinc-200'
                                                                    }`}
                                                                    onMouseDown={e => e.stopPropagation()}
                                                                >
                                                                    {(apiConfigs.find(c => c.id === node.settings?.model)?.durations || ['5s', '10s']).map(d => (
                                                                        <button
                                                                            key={d}
                                                                            onClick={() => {
                                                                                updateNodeSettings(node.id, { duration: d });
                                                                                setActiveDropdown(null);
                                                                            }}
                                                                            className={`w-full text-center py-1 text-[10px] rounded ${
                                                                                theme === 'dark'
                                                                                    ? 'text-zinc-300 hover:bg-zinc-800'
                                                                                    : 'text-zinc-700 hover:bg-zinc-100'
                                                                            }`}
                                                                        >
                                                                            {d}
                                                                        </button>
                                                                    ))}
                                                        </div>
                                                    )}
                                                </div>
                                                    {node.type === 'gen-video' && node.settings?.model === 'sora-2' && (
                                                        <label className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border cursor-pointer transition-colors ${
                                                            theme === 'dark'
                                                                ? node.settings?.isHD ? 'bg-blue-600/30 border-blue-500 text-blue-300' : 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                : node.settings?.isHD ? 'bg-blue-500/30 border-blue-400 text-blue-700' : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                        }`} onClick={e => e.stopPropagation()}>
                                                            <input
                                                                type="checkbox"
                                                                checked={node.settings?.isHD || false}
                                                                onChange={(e) => {
                                                                    e.stopPropagation();
                                                                    updateNodeSettings(node.id, { isHD: e.target.checked });
                                                                }}
                                                                className="w-3 h-3 cursor-pointer"
                                                                onMouseDown={e => e.stopPropagation()}
                                                            />
                                                            <span>HD</span>
                                                        </label>
                                                    )}
                                                </>
                                                    ) : null;
                                                })()
                                            )}
                                        </div>
                                        <button onClick={() => {
                                            const basePrompt = node.type === 'gen-image' ? node.settings?.prompt || '' : node.settings?.videoPrompt || '';
                                            const connectedTexts = getConnectedTextNodes(node.id);
                                            const finalPrompt = connectedTexts.length > 0 ? connectedTexts.join(' ') + (basePrompt ? ' ' + basePrompt : '') : basePrompt;
                                            startGeneration(finalPrompt, node.type === 'gen-image' ? 'image' : 'video', connectedImages, node.id);
                                        }} className="bg-blue-600 hover:bg-blue-500 text-white p-1.5 rounded-md shadow-lg active:scale-95 transition-transform shrink-0" title="生成">
                                            <Play size={12} fill="currentColor" />
                                        </button>
                                    </div>
                                </div>
                                );
                            })()}
                        </div>
                    </div>
                );
            }, [selectedNodeId, selectedNodeIds, hoverTargetId, nodeConnectedStatus, adjacentNodesCache, apiConfigsMap, getConnectedInputImages, theme, view, dragNodeId, connectingSource, connectingTarget, connectingInputType, deleteNode, handleNodeMouseUp, screenToWorld, setDragNodeId, setSelectedNodeId, setSelectedNodeIds, setActiveDropdown, setHoverTargetId, setConnectingSource, setConnectingTarget, setConnectingInputType, setResizingNodeId, setLightboxItem, isVideoUrl, updateNodeSettings, getConnectedTextNodes, startGeneration, getDefaultDurationForModel, getDefaultDurationsForModel, getConnectedGenNodes, getConnectedVideoInputNode, getConnectedVideoAnalyzeNode]);

            // 高性能模式：当节点数量超过 50 时自动启用
            const isPerfMode = nodes.length > 50;
            // 交互模式：正在拖拽或缩放时启用
            const isInteracting = isDragging || isPanning;
            
            return (
                <div
                    className={`w-full h-screen font-sans overflow-hidden select-none flex flex-col transition-colors duration-300 ${
                        theme === 'dark' ? 'bg-[#09090b] text-white' : 'bg-zinc-100 text-zinc-900'
                    } ${isPerfMode ? 'perf-mode' : ''} ${isInteracting ? 'interacting' : ''}`}
                    onClick={() => { 
                        if(historyContextMenu.visible) setHistoryContextMenu(prev => ({ ...prev, visible: false }));
                        if(frameContextMenu.visible) setFrameContextMenu(prev => ({ ...prev, visible: false }));
                    }}
                >
                    {/* Top Bar */}
                    <div
                        className={`h-12 flex items-center justify-between px-4 z-50 shrink-0 border-b transition-colors duration-300 ${
                            theme === 'dark' ? 'bg-[#09090b] border-zinc-800' : 'bg-white border-zinc-200'
                        }`}
                    >
                        <div className="flex items-center gap-3">
                            <div className="w-7 h-7 bg-gradient-to-br from-blue-600 to-indigo-600 rounded-md flex items-center justify-center">
                                <Layers size={16} className="text-white" />
                            </div>
                            <span
                                className={`font-bold text-sm tracking-wide ${
                                    theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'
                                }`}
                            >
                                Tapnow Studio
                            </span>
                            {/* 功能4：项目名称编辑 */}
                            {isEditingProjectName ? (
                                <input
                                    ref={projectNameInputRef}
                                    type="text"
                                    value={projectName}
                                    onChange={(e) => setProjectName(e.target.value)}
                                    onBlur={() => {
                                        setIsEditingProjectName(false);
                                        try {
                                            localStorage.setItem('tapnow_project_name', projectName);
                                        } catch (e) {}
                                    }}
                                    onKeyDown={(e) => {
                                        if (e.key === 'Enter') {
                                            setIsEditingProjectName(false);
                                            try {
                                                localStorage.setItem('tapnow_project_name', projectName);
                                            } catch (e) {}
                                        }
                                    }}
                                    className={`ml-2 px-2 py-0.5 text-xs border rounded outline-none ${
                                        theme === 'dark'
                                            ? 'bg-zinc-800 border-zinc-700 text-zinc-200'
                                            : 'bg-white border-zinc-300 text-zinc-800'
                                    }`}
                                    style={{ minWidth: '100px', maxWidth: '200px' }}
                                />
                            ) : (
                                <span
                                    onClick={() => {
                                        setIsEditingProjectName(true);
                                        setTimeout(() => projectNameInputRef.current?.focus(), 0);
                                    }}
                                    className={`ml-2 text-xs cursor-pointer hover:underline ${
                                        theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'
                                    }`}
                                    title="点击编辑项目名称"
                                >
                                    {projectName}
                                </span>
                            )}
                        </div>
                        <div className="flex items-center gap-2">
                            {/* 功能1：下载按钮 */}
                            <button
                                onClick={handleBatchDownload}
                                className={`flex items-center gap-1 px-3 py-1.5 rounded-lg text-xs font-medium transition-colors border ${
                                    theme === 'dark'
                                        ? 'bg-zinc-900 border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                        : 'bg-zinc-100 border-zinc-300 text-zinc-700 hover:bg-zinc-200'
                                }`}
                                title="批量下载选中的图片/视频节点"
                            >
                                <Download size={14} />
                                <span>下载</span>
                            </button>
                            <button
                                onClick={handleToggleTheme}
                                className={`flex items-center gap-1 px-3 py-1.5 rounded-lg text-xs font-medium transition-colors border ${
                                    theme === 'dark'
                                        ? 'bg-zinc-900 border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                        : 'bg-zinc-100 border-zinc-300 text-zinc-700 hover:bg-zinc-200'
                                }`}
                                title="切换明暗主题"
                            >
                                {theme === 'dark' ? (
                                    <>
                                        <Sun size={14} className="text-amber-400" />
                                        <span>亮色</span>
                                    </>
                                ) : (
                                    <>
                                        <Moon size={14} className="text-blue-500" />
                                        <span>暗色</span>
                                    </>
                                )}
                            </button>
                            <Button variant="ghost" onClick={() => { setNodes([]); setConnections([]); }}>清空</Button>
                            <Button variant="secondary" icon={Settings} onClick={() => setSettingsOpen(true)}>API 设置</Button>
                        </div>
                    </div>

                    <div className={`flex-1 relative overflow-hidden flex transition-colors duration-300 ${
                        theme === 'dark' ? 'bg-[#09090b]' : 'bg-zinc-100'
                    }`}>
                        {/* Sidebar */}
                        <div
                            className={`w-14 border-r flex flex-col items-center py-3 gap-3 z-40 shrink-0 transition-colors duration-300 ${
                                theme === 'dark' ? 'bg-[#09090b] border-zinc-800' : 'bg-white border-zinc-200'
                            }`}
                        >
                            <button
                                onClick={autoArrangeNodes}
                                className={`p-2.5 rounded-lg transition-all mb-2 ${
                                    theme === 'dark'
                                        ? 'text-zinc-500 hover:text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-500 hover:text-zinc-800 hover:bg-zinc-200'
                                }`}
                                title="自动整理节点（对齐、排列、去除堆叠）"
                            >
                                <Layout size={18} />
                            </button>
                            {[ { id: 'select', icon: MousePointer2 }, { id: 'history', icon: History }, { id: 'characters', icon: Users } ].map((tool) => (
                                <button
                                    key={tool.id}
                                    onClick={() => { 
                                        setActiveTool(tool.id); 
                                        if (tool.id === 'history') setHistoryOpen(!historyOpen);
                                        if (tool.id === 'characters') setCharactersOpen(!charactersOpen);
                                    }}
                                    className={`p-2.5 rounded-lg transition-all ${
                                        activeTool === tool.id
                                            ? theme === 'dark'
                                                ? 'bg-zinc-800 text-white'
                                                : 'bg-zinc-200 text-zinc-900'
                                            : theme === 'dark'
                                                ? 'text-zinc-500 hover:text-zinc-300'
                                                : 'text-zinc-500 hover:text-zinc-800'
                                    }`}
                                >
                                    <tool.icon size={18} />
                                </button>
                            ))}
                            <div className="flex-1"></div>
                            <button
                                onClick={() => setIsChatOpen(!isChatOpen)}
                                className={`p-2.5 rounded-lg transition-all mb-2 ${
                                    isChatOpen
                                        ? 'bg-blue-600 text-white'
                                        : theme === 'dark'
                                            ? 'text-zinc-500 hover:text-zinc-300'
                                            : 'text-zinc-500 hover:text-zinc-800'
                                }`}
                                title="AI 对话"
                            >
                                <MessageSquare size={18} />
                            </button>
                            {/* 功能5：保存和加载按钮 */}
                            <button
                                onClick={handleSaveProject}
                                className={`p-2.5 rounded-lg transition-all ${
                                    theme === 'dark'
                                        ? 'text-zinc-500 hover:text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-500 hover:text-zinc-800 hover:bg-zinc-200'
                                }`}
                                title="保存项目"
                            >
                                <Save size={18} />
                            </button>
                            <button
                                onClick={handleLoadProject}
                                className={`p-2.5 rounded-lg transition-all mb-2 ${
                                    theme === 'dark'
                                        ? 'text-zinc-500 hover:text-zinc-300 hover:bg-zinc-800'
                                        : 'text-zinc-500 hover:text-zinc-800 hover:bg-zinc-200'
                                }`}
                                title="加载项目"
                            >
                                <FolderOpen size={18} />
                            </button>
                        </div>

                            {/* History Panel */}
                        {historyOpen && (
                            <div
                                className={`w-72 z-30 flex flex-col animate-in slide-in-from-left border-r transition-colors duration-300 ${
                                    theme === 'dark' ? 'bg-[#121214] border-zinc-800' : 'bg-zinc-50 border-zinc-200'
                                }`}
                            >
                                <div
                                    className={`p-3 border-b flex justify-between items-center ${
                                        theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}
                                >
                                    <h3
                                        className={`font-bold text-xs ${
                                            theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                        }`}
                                    >
                                        生成历史
                                    </h3>
                                    <div className="flex items-center gap-2">
                                        <button
                                            onClick={() => {
                                                setBatchModalOpen(true);
                                                setBatchSelectedIds(new Set());
                                            }}
                                            className={`p-1.5 rounded transition-colors ${
                                                theme === 'dark'
                                                    ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                            }`}
                                            title="批量管理"
                                        >
                                            <LayoutGrid size={14} />
                                        </button>
                                        <button onClick={() => setHistoryOpen(false)}>
                                            <X
                                                size={12}
                                                className={theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}
                                            />
                                        </button>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto custom-scrollbar p-3 space-y-3">
                                    {history.map((item) => (
                                        <HistoryItem
                                            key={item.id}
                                            item={item}
                                            theme={theme}
                                            lightboxItem={lightboxItem}
                                            onDelete={deleteHistoryItem}
                                            onClick={() => {
                                                if (item.url) {
                                                    const currentIndex = item.mjImages && item.mjImages.length > 1 
                                                        ? (item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0)
                                                        : 0;
                                                    setLightboxItem({
                                                        ...item,
                                                        url: item.mjImages && item.mjImages.length > 1 
                                                            ? item.mjImages[currentIndex] 
                                                            : item.url,
                                                        selectedMjImageIndex: currentIndex
                                                    });
                                                }
                                            }}
                                            onContextMenu={(e) => handleHistoryRightClick(e, item)}
                                            onImageClick={(e, item, imgUrl, idx) => {
                                                e.stopPropagation();
                                                setHistory((prev) => prev.map((hItem) => 
                                                    hItem.id === item.id 
                                                        ? { ...hItem, url: imgUrl, selectedMjImageIndex: idx } 
                                                        : hItem
                                                ));
                                                const updatedItem = { 
                                                    ...item, 
                                                    url: imgUrl,
                                                    selectedMjImageIndex: idx
                                                };
                                                setLightboxItem(updatedItem);
                                            }}
                                            onImageContextMenu={(e, item, imgUrl, idx) => handleHistoryRightClick(e, item, imgUrl, idx)}
                                            onRefresh={(item) => {
                                                if (item.apiConfig) {
                                                    setHistory(prev => prev.map(h => h.id === item.id ? { ...h, status: 'generating', errorMsg: null, progress: 5 } : h));
                                                    if (item.modelName.includes('veo')) pollVeoJob(item.remoteTaskId, item.id, item.apiConfig.baseUrl, item.apiConfig.apiKey, item.width, item.height);
                                                    else pollSoraJob(item.remoteTaskId, item.id, item.apiConfig.baseUrl, item.apiConfig.apiKey, item.width, item.height, item.apiConfig.modelId || '');
                                                }
                                            }}
                                            Loader2={Loader2}
                                            Trash2={Trash2}
                                            RefreshCw={RefreshCw}
                                        />
                                    ))}
                                </div>
                            </div>
                        )}

                            {/* Characters Panel */}
                        {charactersOpen && (
                            <div
                                className={`w-72 z-30 flex flex-col animate-in slide-in-from-left border-r transition-colors duration-300 ${
                                    theme === 'dark' ? 'bg-[#121214] border-zinc-800' : 'bg-zinc-50 border-zinc-200'
                                }`}
                            >
                                <div
                                    className={`p-3 border-b flex justify-between items-center ${
                                        theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}
                                >
                                    <h3
                                        className={`font-bold text-xs ${
                                            theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                        }`}
                                    >
                                        Sora 角色库
                                    </h3>
                                    <div className="flex items-center gap-2">
                                        <button
                                            onClick={() => {
                                                // 自动计算默认 endpoint
                                                const soraConfig = apiConfigs.find(c => c.type === 'Video' && (c.id === 'sora-2' || c.id === 'sora-2-pro'));
                                                if (soraConfig) {
                                                    const baseUrl = (soraConfig.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                                                    setCreateCharacterEndpoint(`${baseUrl}/sora/v1/characters`);
                                                } else {
                                                    const baseUrl = DEFAULT_BASE_URL.replace(/\/+$/, '');
                                                    setCreateCharacterEndpoint(`${baseUrl}/sora/v1/characters`);
                                                }
                                                setCreateCharacterOpen(true);
                                            }}
                                            className={`px-2 py-1 text-[10px] rounded transition-colors ${
                                                theme === 'dark'
                                                    ? 'bg-blue-600 hover:bg-blue-500 text-white'
                                                    : 'bg-blue-500 hover:bg-blue-600 text-white'
                                            }`}
                                        >
                                            新建角色
                                        </button>
                                        <button onClick={() => setCharactersOpen(false)}>
                                            <X
                                                size={12}
                                                className={theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}
                                            />
                                        </button>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto custom-scrollbar p-3">
                                    {characterLibrary.length === 0 ? (
                                        <div className={`text-center py-8 text-sm ${
                                            theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'
                                        }`}>
                                            暂无角色，点击"新建角色"开始创建
                                        </div>
                                    ) : (
                                        <div className="grid grid-cols-2 gap-3">
                                            {characterLibrary.map((character) => (
                                                <div
                                                    key={character.id}
                                                    className={`group rounded-lg overflow-hidden border cursor-pointer hover:border-blue-500/50 transition-colors ${
                                                        theme === 'dark' ? 'bg-zinc-900 border-zinc-800' : 'bg-white border-zinc-200'
                                                    }`}
                                                    onClick={() => {
                                                        const tag = ` @${character.username} `;
                                                        // 尝试找到当前激活的输入框
                                                        const activeElement = document.activeElement;
                                                        if (activeElement && (activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'INPUT')) {
                                                            const textarea = activeElement;
                                                            const start = textarea.selectionStart || 0;
                                                            const end = textarea.selectionEnd || 0;
                                                            const text = textarea.value;
                                                            const newText = text.slice(0, start) + tag + text.slice(end);
                                                            textarea.value = newText;
                                                            const newCursorPos = start + tag.length;
                                                            textarea.setSelectionRange(newCursorPos, newCursorPos);
                                                            textarea.dispatchEvent(new Event('input', { bubbles: true }));
                                                            textarea.focus();
                                                        } else {
                                                            // 复制到剪贴板
                                                            navigator.clipboard.writeText(tag.trim()).then(() => {
                                                                alert(`已复制角色标签: ${tag.trim()}`);
                                                            });
                                                        }
                                                    }}
                                                >
                                                    <div className="aspect-square bg-zinc-800 relative group/char">
                                                        {character.profile_picture_url ? (
                                                            <img
                                                                src={character.profile_picture_url}
                                                                alt={character.username}
                                                                className="w-full h-full object-cover"
                                                                onError={(e) => {
                                                                    e.target.style.display = 'none';
                                                                }}
                                                            />
                                                        ) : (
                                                            <div className="w-full h-full flex items-center justify-center text-zinc-500">
                                                                <User size={24} />
                                                            </div>
                                                        )}
                                                        {/* 删除按钮 */}
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                if (confirm(`确定要删除角色 "${character.username}" 吗？`)) {
                                                                    const updated = characterLibrary.filter(c => c.id !== character.id);
                                                                    setCharacterLibrary(updated);
                                                                    try {
                                                                        localStorage.setItem('tapnow_characters', JSON.stringify(updated));
                                                                    } catch (err) {
                                                                        console.error('保存角色库失败:', err);
                                                                    }
                                                                }
                                                            }}
                                                            className="absolute top-1 right-1 p-1.5 rounded-full bg-black/50 text-white opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-600 z-10"
                                                            title="删除角色"
                                                        >
                                                            <Trash2 size={12} />
                                                        </button>
                                                    </div>
                                                    <div className="p-2 relative">
                                                        <p className={`text-xs truncate flex items-center gap-1 ${
                                                            theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                                        }`}>
                                                            {character.username}
                                                            <LinkIcon 
                                                                size={12} 
                                                                className="text-green-500 shrink-0" 
                                                                title="Sora 2 已同步"
                                                            />
                                                        </p>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        {/* Create Character Modal */}
                        {createCharacterOpen && (
                            <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center" onClick={() => setCreateCharacterOpen(false)}>
                                <div 
                                    className={`w-[500px] max-h-[90vh] overflow-y-auto rounded-lg shadow-2xl flex flex-col ${
                                        theme === 'dark' ? 'bg-[#121214] border-zinc-800' : 'bg-white border-zinc-200'
                                    } border`}
                                    onClick={(e) => e.stopPropagation()}
                                >
                                    <div className={`p-4 border-b flex justify-between items-center ${
                                        theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}>
                                        <h3 className={`font-bold text-sm ${
                                            theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                        }`}>
                                            新建角色
                                        </h3>
                                        <button onClick={() => setCreateCharacterOpen(false)}>
                                            <X size={16} className={theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'} />
                                        </button>
                                    </div>
                                    <div className="p-4 space-y-4">
                                        {/* 视频源选择 */}
                                        <div>
                                            <label className={`block text-xs mb-2 ${
                                                theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                            }`}>
                                                视频源
                                            </label>
                                            <div className="flex gap-2 mb-2">
                                                <button
                                                    onClick={() => {
                                                        setCreateCharacterVideoSourceType('url');
                                                        setCreateCharacterSelectedTaskId('');
                                                    }}
                                                    className={`px-3 py-1.5 text-xs rounded transition-colors ${
                                                        createCharacterVideoSourceType === 'url'
                                                            ? theme === 'dark'
                                                                ? 'bg-blue-600 text-white'
                                                                : 'bg-blue-500 text-white'
                                                            : theme === 'dark'
                                                                ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                                                                : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'
                                                    }`}
                                                >
                                                    输入视频 URL
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        setCreateCharacterVideoSourceType('history');
                                                        setCreateCharacterVideoUrl('');
                                                        setCreateCharacterVideoError(null);
                                                    }}
                                                    className={`px-3 py-1.5 text-xs rounded transition-colors ${
                                                        createCharacterVideoSourceType === 'history'
                                                            ? theme === 'dark'
                                                                ? 'bg-blue-600 text-white'
                                                                : 'bg-blue-500 text-white'
                                                            : theme === 'dark'
                                                                ? 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                                                                : 'bg-zinc-100 text-zinc-600 hover:bg-zinc-200'
                                                    }`}
                                                >
                                                    从历史记录选择
                                                </button>
                                            </div>
                                            
                                            {createCharacterVideoSourceType === 'url' ? (
                                                <input
                                                    type="text"
                                                    value={createCharacterVideoUrl}
                                                    onChange={(e) => setCreateCharacterVideoUrl(e.target.value)}
                                                    placeholder="输入视频 URL..."
                                                    className={`w-full px-3 py-2 text-xs rounded border outline-none ${
                                                        theme === 'dark'
                                                            ? 'bg-zinc-900 border-zinc-700 text-zinc-200 placeholder-zinc-600'
                                                            : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                                    }`}
                                                />
                                            ) : (
                                                <select
                                                    value={createCharacterSelectedTaskId}
                                                    onChange={(e) => {
                                                        const taskId = e.target.value;
                                                        setCreateCharacterSelectedTaskId(taskId);
                                                        // 当选中历史视频时，自动获取视频URL并填充到URL输入框
                                                        if (taskId) {
                                                            const selectedHistoryItem = historyMap.get(taskId);
                                                            if (selectedHistoryItem && selectedHistoryItem.url) {
                                                                // 切换到URL输入模式并填充URL
                                                                setCreateCharacterVideoSourceType('url');
                                                                setCreateCharacterVideoUrl(selectedHistoryItem.url);
                                                                setCreateCharacterSelectedTaskId(''); // 清空选择
                                                            }
                                                        }
                                                    }}
                                                    className={`w-full px-3 py-2 text-xs rounded border outline-none ${
                                                        theme === 'dark'
                                                            ? 'bg-zinc-900 border-zinc-700 text-zinc-200'
                                                            : 'bg-white border-zinc-300 text-zinc-800'
                                                    }`}
                                                >
                                                    <option value="">选择历史记录中的视频...</option>
                                                    {history.filter(h => h.type === 'video' && h.status === 'completed' && h.url).map(item => (
                                                        <option key={item.id} value={item.id}>
                                                            {item.prompt?.slice(0, 50) || 'Untitled'} - {item.time}
                                                        </option>
                                                    ))}
                                                </select>
                                            )}
                                            
                                            {/* 视频预览区域 */}
                                            {(() => {
                                                let currentVideoUrl = null;
                                                if (createCharacterVideoSourceType === 'url' && createCharacterVideoUrl.trim()) {
                                                    currentVideoUrl = createCharacterVideoUrl.trim();
                                                } else if (createCharacterVideoSourceType === 'history' && createCharacterSelectedTaskId) {
                                                    const selectedHistoryItem = historyMap.get(createCharacterSelectedTaskId);
                                                    if (selectedHistoryItem && selectedHistoryItem.url) {
                                                        currentVideoUrl = selectedHistoryItem.url;
                                                    }
                                                }
                                                
                                                return currentVideoUrl ? (
                                                    <div className="mt-2 mb-2">
                                                        <video 
                                                            key={currentVideoUrl}
                                                            controls 
                                                            crossOrigin="anonymous"
                                                            className="w-full h-40 object-contain bg-black rounded-lg" 
                                                            src={currentVideoUrl}
                                                            onError={(e) => {
                                                                console.error('视频加载失败:', currentVideoUrl, e);
                                                                setCreateCharacterVideoError('无法加载视频预览，请检查链接有效性或跨域限制');
                                                            }}
                                                            onLoadStart={() => {
                                                                // 清除错误提示
                                                                setCreateCharacterVideoError(null);
                                                            }}
                                                            onLoadedData={() => {
                                                                // 视频加载成功，清除错误
                                                                setCreateCharacterVideoError(null);
                                                            }}
                                                        />
                                                        {createCharacterVideoError && (
                                                            <div className="text-red-500 text-xs mt-1 text-center">
                                                                {createCharacterVideoError}
                                                            </div>
                                                        )}
                                                    </div>
                                                ) : null;
                                            })()}
                                        </div>
                                        
                                        {/* 时间范围 */}
                                        <div>
                                            <label className={`block text-xs mb-2 ${
                                                theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                            }`}>
                                                时间范围（秒，间隔需在 1-3 秒之间）
                                            </label>
                                            <div className="flex gap-2 items-center">
                                                <input
                                                    type="number"
                                                    min="0"
                                                    step="0.1"
                                                    value={createCharacterStartSecond}
                                                    onChange={(e) => setCreateCharacterStartSecond(parseFloat(e.target.value) || 0)}
                                                    className={`w-20 px-2 py-1.5 text-xs rounded border outline-none ${
                                                        theme === 'dark'
                                                            ? 'bg-zinc-900 border-zinc-700 text-zinc-200'
                                                            : 'bg-white border-zinc-300 text-zinc-800'
                                                    }`}
                                                />
                                                <span className={`text-xs ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>到</span>
                                                <input
                                                    type="number"
                                                    min="0"
                                                    step="0.1"
                                                    value={createCharacterEndSecond}
                                                    onChange={(e) => setCreateCharacterEndSecond(parseFloat(e.target.value) || 0)}
                                                    className={`w-20 px-2 py-1.5 text-xs rounded border outline-none ${
                                                        theme === 'dark'
                                                            ? 'bg-zinc-900 border-zinc-700 text-zinc-200'
                                                            : 'bg-white border-zinc-300 text-zinc-800'
                                                    }`}
                                                />
                                                <span className={`text-xs ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>
                                                    秒（间隔: {(createCharacterEndSecond - createCharacterStartSecond).toFixed(1)}s）
                                                </span>
                                            </div>
                                        </div>
                                        
                                        {/* 高级设置：API 接口地址 */}
                                        <div>
                                            <label className={`block text-xs mb-2 ${
                                                theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                            }`}>
                                                API 接口地址 (API Endpoint)
                                            </label>
                                            <input
                                                type="text"
                                                value={createCharacterEndpoint}
                                                onChange={(e) => setCreateCharacterEndpoint(e.target.value)}
                                                placeholder="例如: https://your-domain.com/sora/v1/characters"
                                                className={`w-full px-3 py-2 text-xs rounded border outline-none font-mono ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-900 border-zinc-700 text-zinc-200 placeholder-zinc-600'
                                                        : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                                }`}
                                                onFocus={(e) => {
                                                    // 如果为空，自动填充默认值
                                                    if (!e.target.value) {
                                                        const soraConfig = apiConfigs.find(c => c.type === 'Video' && (c.id === 'sora-2' || c.id === 'sora-2-pro'));
                                                        const baseUrl = soraConfig 
                                                            ? (soraConfig.url || DEFAULT_BASE_URL).replace(/\/+$/, '')
                                                            : DEFAULT_BASE_URL.replace(/\/+$/, '');
                                                        setCreateCharacterEndpoint(`${baseUrl}/sora/v1/characters`);
                                                    }
                                                }}
                                            />
                                            <p className={`text-[10px] mt-1 ${
                                                theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'
                                            }`}>
                                                默认自动填充，可根据服务商要求修改路径
                                            </p>
                                        </div>
                                        
                                        {/* 提交按钮 */}
                                        <div className="flex justify-end gap-2 pt-2">
                                            <button
                                                onClick={() => setCreateCharacterOpen(false)}
                                                className={`px-4 py-2 text-xs rounded transition-colors ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                        : 'bg-zinc-100 text-zinc-700 hover:bg-zinc-200'
                                                }`}
                                            >
                                                取消
                                            </button>
                                            <button
                                                onClick={async () => {
                                                    if (createCharacterVideoSourceType === 'url' && !createCharacterVideoUrl.trim()) {
                                                        alert('请输入视频 URL');
                                                        return;
                                                    }
                                                    if (createCharacterVideoSourceType === 'history' && !createCharacterSelectedTaskId) {
                                                        alert('请选择历史记录中的视频');
                                                        return;
                                                    }
                                                    if (createCharacterEndSecond - createCharacterStartSecond < 1 || createCharacterEndSecond - createCharacterStartSecond > 3) {
                                                        alert('时间范围必须在 1-3 秒之间');
                                                        return;
                                                    }
                                                    setCreateCharacterSubmitting(true);
                                                    try {
                                                        // 优先使用用户手动输入的 API 地址，如果为空则使用默认地址
                                                        const endpointToUse = createCharacterEndpoint.trim() || null;
                                                        
                                                        if (createCharacterVideoSourceType === 'url') {
                                                            await createCharacter(createCharacterVideoUrl, createCharacterStartSecond, createCharacterEndSecond, null, endpointToUse);
                                                        } else {
                                                            await createCharacter('', createCharacterStartSecond, createCharacterEndSecond, createCharacterSelectedTaskId, endpointToUse);
                                                        }
                                                    } finally {
                                                        setCreateCharacterSubmitting(false);
                                                    }
                                                }}
                                                disabled={createCharacterSubmitting}
                                                className={`px-4 py-2 text-xs rounded transition-colors ${
                                                    createCharacterSubmitting
                                                        ? 'bg-zinc-400 text-zinc-200 cursor-not-allowed'
                                                        : theme === 'dark'
                                                            ? 'bg-blue-600 text-white hover:bg-blue-500'
                                                            : 'bg-blue-500 text-white hover:bg-blue-600'
                                                }`}
                                            >
                                                {createCharacterSubmitting ? '创建中...' : '创建角色'}
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Main Canvas Area */}
                        <div className="flex-1 relative overflow-hidden flex">
                             <div ref={canvasRef} id="canvas-bg" className="flex-1 h-full cursor-default relative"
                                onMouseDown={handleMouseDown} onClick={handleBackgroundClick} onDoubleClick={handleDoubleClick}
                                style={{ 
                                    backgroundImage: theme === 'dark' 
                                        ? 'radial-gradient(#27272a 1px, transparent 1px)' 
                                        : 'radial-gradient(rgba(0, 0, 0, 0.08) 0.5px, transparent 0.5px)', 
                                    backgroundSize: `${20 * view.zoom}px ${20 * view.zoom}px`, 
                                    backgroundPosition: `${view.x}px ${view.y}px`,
                                    WebkitFontSmoothing: 'antialiased',
                                    MozOsxFontSmoothing: 'grayscale',
                                    textRendering: 'optimizeLegibility',
                                    transform: 'translateZ(0)',
                                    backfaceVisibility: 'hidden'
                                }}>
                                <div className="absolute origin-top-left will-change-transform" style={{ 
                                    transform: `translate3d(${view.x}px, ${view.y}px, 0) scale(${view.zoom})`, 
                                    width: VIRTUAL_CANVAS_WIDTH, 
                                    height: VIRTUAL_CANVAS_HEIGHT,
                                    WebkitFontSmoothing: 'antialiased',
                                    MozOsxFontSmoothing: 'grayscale',
                                    textRendering: 'optimizeLegibility',
                                    transformOrigin: 'top left',
                                    imageRendering: view.zoom >= 1 ? 'auto' : 'crisp-edges'
                                }}>
                                    <ConnectionLayer
                                        connections={connections}
                                        nodesMap={nodesMap}
                                        connectionsByNode={connectionsByNode}
                                        connectingSource={connectingSource}
                                        connectingTarget={connectingTarget}
                                        connectingInputType={connectingInputType}
                                        mousePos={mousePos}
                                        apiConfigsMap={apiConfigsMap}
                                        selectedNodeId={selectedNodeId}
                                        onDisconnectConnection={disconnectConnection}
                                        visibleNodes={visibleNodes}
                                    />
                                    {visibleNodes.map((node) => renderNode(node))}
                                </div>
                                
                                {/* 框选框 */}
                                {selectionBox && (
                                    <div
                                        className="absolute border-2 border-blue-500 bg-blue-500/10 pointer-events-none z-50"
                                        style={{
                                            left: Math.min(selectionBox.startX, selectionBox.endX),
                                            top: Math.min(selectionBox.startY, selectionBox.endY),
                                            width: Math.abs(selectionBox.endX - selectionBox.startX),
                                            height: Math.abs(selectionBox.endY - selectionBox.startY),
                                        }}
                                    />
                                )}
                            </div>

                            {/* Chat Sidebar Panel */}
                            <div
                                className={`fixed right-0 top-12 bottom-0 border-l shadow-2xl flex flex-col z-50 transition-transform duration-300 ease-in-out ${
                                    theme === 'dark' ? 'bg-[#121214] border-zinc-800' : 'bg-white border-zinc-200'
                                } ${isChatOpen ? 'translate-x-0' : 'translate-x-full'}`}
                                style={{ width: chatWidth }}
                            >
                                <div
                                    className={`absolute left-0 top-0 bottom-0 w-1.5 cursor-ew-resize transition-colors z-50 flex items-center justify-center group ${
                                        theme === 'dark' ? 'hover:bg-blue-600/50' : 'hover:bg-blue-400/30'
                                    }`}
                                    onMouseDown={handleChatResizeStart}
                                >
                                    <div
                                        className={`h-8 w-1 rounded transition-colors ${
                                            theme === 'dark'
                                                ? 'bg-zinc-700 group-hover:bg-blue-500'
                                                : 'bg-zinc-300 group-hover:bg-blue-500'
                                        }`}
                                    ></div>
                                </div>
                                <div
                                    className={`h-12 flex items-center justify-between px-3 shrink-0 border-b ${
                                        theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}
                                >
                                    <div className="flex items-center gap-2 overflow-hidden">
                                        <div className="relative">
                                            <select
                                                value={chatModel}
                                                onChange={(e) => setChatModel(e.target.value)}
                                                className={`text-xs border rounded pl-2 pr-6 py-1 appearance-none outline-none focus:border-blue-500 cursor-pointer max-w-[180px] truncate ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-800 text-zinc-300 border-zinc-700'
                                                        : 'bg-white text-zinc-800 border-zinc-300'
                                                }`}
                                            >
                                                {apiConfigs.filter(c => c.type === 'Chat').map(c => <option key={c.id} value={c.id}>{c.provider} ({c.modelName})</option>)}
                                            </select>
                                            <div className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none"><div className={`w-1.5 h-1.5 rounded-full ${getStatusColor(chatModel)}`}></div></div>
                                        </div>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <button
                                            onClick={createNewChat}
                                            className={`p-1.5 rounded ${
                                                theme === 'dark'
                                                    ? 'text-zinc-400 hover:text-white hover:bg-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-900 hover:bg-zinc-100'
                                            }`}
                                            title="新对话"
                                        >
                                            <Plus size={16} />
                                        </button>
                                        {chatSessions.length > 1 && (
                                            <div className="relative">
                                                <button
                                                    onClick={() => setChatSessionDropdownOpen(!chatSessionDropdownOpen)}
                                                    className={`p-1.5 rounded ${
                                                        theme === 'dark'
                                                        ? 'text-zinc-400 hover:text-white hover:bg-zinc-800'
                                                            : 'text-zinc-500 hover:text-zinc-900 hover:bg-zinc-100'
                                                    }`}
                                                >
                                                    <History size={16} />
                                                </button>
                                                {chatSessionDropdownOpen && (
                                                    <div
                                                        className={`absolute right-0 top-full mt-1 w-48 rounded-lg shadow-xl py-1 z-50 border ${
                                                            theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : 'bg-white border-zinc-200'
                                                        }`}
                                                        onMouseLeave={() => setChatSessionDropdownOpen(false)}
                                                    >
                                                        {chatSessions.map(s => (
                                                            <div
                                                                key={s.id}
                                                                className={`flex items-center justify-between px-3 py-2 text-xs cursor-pointer ${
                                                                    currentChatId === s.id
                                                                        ? theme === 'dark'
                                                                            ? 'bg-zinc-800 text-white'
                                                                            : 'bg-zinc-100 text-zinc-900'
                                                                        : theme === 'dark'
                                                                            ? 'text-zinc-400 hover:bg-zinc-800/50'
                                                                            : 'text-zinc-500 hover:bg-zinc-100'
                                                                }`}
                                                                onClick={() => {
                                                                    setCurrentChatId(s.id);
                                                                    setChatSessionDropdownOpen(false);
                                                                }}
                                                            >
                                                                <span className="truncate flex-1">{s.title}</span>
                                                                <button
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        deleteChatSession(e, s.id);
                                                                    }}
                                                                    className={`p-1 ${
                                                                        theme === 'dark'
                                                                            ? 'text-zinc-600 hover:text-red-500'
                                                                            : 'text-zinc-400 hover:text-red-500'
                                                                    }`}
                                                                >
                                                                    <X size={10} />
                                                                </button>
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                        <button
                                            onClick={() => setIsChatOpen(false)}
                                            className={`p-1.5 rounded ${
                                                theme === 'dark'
                                                    ? 'text-zinc-400 hover:text-white hover:bg-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-900 hover:bg-zinc-100'
                                            }`}
                                        >
                                            <ChevronRight size={16} />
                                        </button>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto custom-scrollbar p-4 space-y-4">
                                    {currentSession?.messages.map((msg) => (
                                        <div key={msg.id || msg.timestamp || `msg-${Math.random()}`} className={`flex gap-3 ${msg.role === 'user' ? 'flex-row-reverse' : ''}`}>
                                            <div className={`w-8 h-8 rounded-full flex items-center justify-center shrink-0 ${msg.role === 'user' ? 'bg-blue-600' : 'bg-green-600'}`}>{msg.role === 'user' ? <User size={16} className="text-white" /> : <Bot size={16} className="text-white" />}</div>
                                            <div className={`flex flex-col gap-1 max-w-[85%] ${msg.role === 'user' ? 'items-end' : 'items-start'}`}>
                                                {msg.files && msg.files.length > 0 && (
                                                    <div className={`flex flex-wrap gap-2 mb-1 ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                                        {msg.files.map((f, i) => (
                                                            <div
                                                                key={i}
                                                                className={`rounded p-1 border flex items-center gap-1 ${
                                                                    theme === 'dark'
                                                                        ? 'bg-zinc-800 border-zinc-700'
                                                                        : 'bg-zinc-100 border-zinc-300'
                                                                }`}
                                                            >
                                                                {f.isImage ? (
                                                                    <img src={f.content} className="w-16 h-16 object-cover rounded" alt={f.name} />
                                                                ) : f.isVideo ? (
                                                                    <video
                                                                        src={f.content}
                                                                        controls
                                                                        className={`max-w-full rounded-lg bg-black max-h-[300px] border ${
                                                                            theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'
                                                                        }`}
                                                                        playsInline
                                                                    />
                                                                ) : f.isAudio ? (
                                                                    <div
                                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                            theme === 'dark'
                                                                                ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                                : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                    >
                                                                        <FileAudio size={16} />
                                                                        <span className="text-[8px] mt-1">音频</span>
                                                                    </div>
                                                                ) : f.isPDF ? (
                                                                    <div
                                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                            theme === 'dark'
                                                                                ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                                : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                    >
                                                                        <FileText size={16} />
                                                                        <span className="text-[8px] mt-1">PDF</span>
                                                                    </div>
                                                                ) : f.isDoc ? (
                                                                    <div
                                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                            theme === 'dark'
                                                                                ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                                : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                    >
                                                                        <FileText size={16} />
                                                                        <span className="text-[8px] mt-1">DOC</span>
                                                                    </div>
                                                                ) : f.isExcel ? (
                                                                    <div
                                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                            theme === 'dark'
                                                                                ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                                : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                    >
                                                                        <FileText size={16} />
                                                                        <span className="text-[8px] mt-1">XLS</span>
                                                                    </div>
                                                                ) : (
                                                                    <div
                                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                            theme === 'dark'
                                                                                ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                                : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                    >
                                                                        <FileText size={16} />
                                                                        <span className="text-[8px] mt-1 max-w-full truncate px-1">
                                                                            {f.fileExt || f.name.split('.').pop() || '文件'}
                                                                        </span>
                                                                    </div>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                {(msg.content || (msg.files && msg.files.length > 0)) && (
                                                    <div
                                                        className={`rounded-2xl px-4 py-2 text-sm select-text break-words whitespace-pre-wrap ${
                                                            msg.role === 'user'
                                                                ? theme === 'dark'
                                                                    ? 'bg-zinc-800 text-white rounded-tr-none'
                                                                    : 'bg-zinc-300 text-zinc-900 rounded-tr-none'
                                                                : theme === 'dark'
                                                                    ? 'bg-zinc-800/50 text-zinc-300 rounded-tl-none border border-zinc-800'
                                                                    : 'bg-zinc-100 text-zinc-800 rounded-tl-none border border-zinc-200'
                                                        }`}
                                                    >
                                                        {msg.isError ? (
                                                            <span className="text-red-500">{msg.content}</span>
                                                        ) : msg.content ? (
                                                            <div className="markdown-body" dangerouslySetInnerHTML={{ __html: marked.parse(msg.content) }}></div>
                                                        ) : null}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    ))}
                                    {isChatSending && (
                                        <div className="flex gap-3">
                                            <div className="w-8 h-8 rounded-full bg-green-600 flex items-center justify-center shrink-0">
                                                <Bot size={16} className="text-white" />
                                            </div>
                                            <div
                                                className={`rounded-2xl rounded-tl-none px-4 py-2 border flex items-center ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-800/50 border-zinc-800'
                                                        : 'bg-zinc-100 border-zinc-200'
                                                }`}
                                            >
                                                <div className="flex gap-1">
                                                    <div className="w-1.5 h-1.5 bg-zinc-500 rounded-full animate-bounce" style={{ animationDelay: '0s' }}></div>
                                                    <div className="w-1.5 h-1.5 bg-zinc-500 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                                                    <div className="w-1.5 h-1.5 bg-zinc-500 rounded-full animate-bounce" style={{ animationDelay: '0.4s' }}></div>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    <div ref={chatEndRef} />
                                </div>
                                <div
                                    className={`p-3 border-t ${
                                        theme === 'dark' ? 'border-zinc-800 bg-[#121214]' : 'border-zinc-200 bg-zinc-50'
                                    }`}
                                >
                                    {chatFiles.length > 0 && (
                                        <div className="flex gap-2 overflow-x-auto pb-2 mb-2 custom-scrollbar">
                                            {chatFiles.map((f, i) => (
                                                <div key={i} className="relative group shrink-0">
                                                    {f.isImage ? (
                                                        <img
                                                            src={f.content}
                                                            className={`w-12 h-12 object-cover rounded border ${
                                                                theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'
                                                            }`}
                                                            alt={f.name}
                                                        />
                                                    ) : f.isVideo ? (
                                                        <video
                                                            src={f.content}
                                                            className={`w-16 h-12 object-cover rounded border bg-black ${
                                                                theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'
                                                            }`}
                                                            muted
                                                            playsInline
                                                        />
                                                    ) : f.isAudio ? (
                                                        <div
                                                            className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                theme === 'dark'
                                                                    ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                    : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                        >
                                                            <FileAudio size={16} />
                                                            <span className="text-[8px] mt-1">音频</span>
                                                        </div>
                                                    ) : f.isPDF ? (
                                                        <div
                                                            className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                theme === 'dark'
                                                                    ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                    : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                        >
                                                            <FileText size={16} />
                                                            <span className="text-[8px] mt-1">PDF</span>
                                                        </div>
                                                    ) : f.isDoc ? (
                                                        <div
                                                            className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                theme === 'dark'
                                                                    ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                    : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                        >
                                                            <FileText size={16} />
                                                            <span className="text-[8px] mt-1">DOC</span>
                                                        </div>
                                                    ) : f.isExcel ? (
                                                        <div
                                                            className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                theme === 'dark'
                                                                    ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                    : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                        >
                                                            <FileText size={16} />
                                                            <span className="text-[8px] mt-1">XLS</span>
                                                        </div>
                                                    ) : (
                                                        <div
                                                            className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                theme === 'dark'
                                                                    ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                    : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                        >
                                                            <FileText size={16} />
                                                            <span className="text-[8px] mt-1 max-w-full truncate px-1">
                                                                {f.fileExt || f.name.split('.').pop() || '文件'}
                                                            </span>
                                                        </div>
                                                    )}
                                                    <button
                                                        onClick={() => removeChatFile(i)}
                                                        className={`absolute -top-1 -right-1 rounded-full p-0.5 border opacity-0 group-hover:opacity-100 transition-opacity ${
                                                            theme === 'dark'
                                                                ? 'bg-zinc-900 text-zinc-400 hover:text-white border-zinc-700'
                                                                : 'bg-white text-zinc-500 hover:text-zinc-900 border-zinc-300'
                                                        }`}
                                                    >
                                                        <X size={10} />
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    <div
                                        className={`relative rounded-xl flex items-end p-2 focus-within:border-blue-500/50 transition-colors border ${
                                            theme === 'dark'
                                                ? 'bg-zinc-800/50 border-zinc-700'
                                                : 'bg-white border-zinc-300'
                                        }`}
                                    >
                                        <label
                                            className={`p-2 cursor-pointer transition-colors ${
                                                theme === 'dark'
                                                    ? 'text-zinc-400 hover:text-white'
                                                    : 'text-zinc-500 hover:text-zinc-900'
                                            }`}
                                            title="上传文件"
                                        >
                                            <Paperclip size={18} />
                                            <input type="file" multiple className="hidden" onChange={handleChatFileUpload} accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.md,.js,.py,.html,.css,.json,.csv" />
                                        </label>
                                        <textarea
                                            value={chatInput}
                                            onChange={(e) => setChatInput(e.target.value)}
                                            onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(); } }}
                                            placeholder="发送消息..."
                                            className={`w-full bg-transparent text-sm resize-none outline-none max-h-32 py-2 px-1 custom-scrollbar ${
                                                theme === 'dark'
                                                    ? 'text-white placeholder-zinc-500'
                                                    : 'text-zinc-800 placeholder-zinc-400'
                                            }`}
                                            rows={1}
                                            style={{ minHeight: '36px' }}
                                        />
                                        <button
                                            onClick={sendChatMessage}
                                            disabled={(!chatInput.trim() && chatFiles.length === 0) || isChatSending}
                                            className={`p-2 rounded-lg transition-all mb-0.5 ${
                                                (!chatInput.trim() && chatFiles.length === 0) || isChatSending
                                                    ? 'opacity-50 bg-transparent text-zinc-400'
                                                    : 'bg-blue-600 text-white hover:bg-blue-500'
                                            }`}
                                        >
                                            <Send size={16} />
                                        </button>
                                    </div>
                                    <div className={`text-[10px] text-center mt-2 ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>
                                        支持 MP4/MP3/PDF/Doc/Excel/Code 等格式 • Enter 发送
                                    </div>
                                </div>
                            </div>

                            {contextMenu.visible && (
                                <div
                                    className={`fixed z-50 w-40 rounded-lg shadow-xl border ${
                                        theme === 'dark' ? 'bg-[#18181b] border-zinc-800' : 'bg-white border-zinc-200'
                                    }`}
                                    style={{ left: contextMenu.x, top: contextMenu.y, transform: 'translate(-50%, -50%)' }}
                                    onMouseLeave={() => setContextMenu(prev => ({ ...prev, visible: false }))}
                                >
                                    <div className="p-1">
                                        {[
                                            { type: 'input-image', label: '图片输入' },
                                            { type: 'text-node', label: '文字节点' },
                                            { type: 'video-input', label: '视频输入' },
                                            { type: 'video-analyze', label: '视频拆解 / 提示词反推' },
                                            { type: 'storyboard-node', label: '智能分镜表' },
                                            { type: 'gen-image', label: 'AI 绘图' },
                                            { type: 'gen-video', label: 'AI 视频' },
                                            { type: 'image-compare', label: '图像对比' },
                                            { type: 'preview', label: '预览窗口' },
                                        ].map(item => (
                                            <button
                                                key={item.type}
                                                className={`w-full text-left px-3 py-2 text-xs rounded transition-colors ${
                                                    theme === 'dark'
                                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                                        : 'text-zinc-700 hover:bg-zinc-100'
                                                }`}
                                                onClick={() => addNode(item.type, contextMenu.worldX, contextMenu.worldY, contextMenu.sourceNodeId, undefined, undefined, contextMenu.targetNodeId, contextMenu.inputType)}
                                            >
                                                {item.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {historyContextMenu.visible && (
                                <div
                                    className={`fixed z-[100] w-48 rounded-lg shadow-2xl py-1 animate-in fade-in duration-100 border ${
                                        theme === 'dark' ? 'bg-[#18181b] border-zinc-700' : 'bg-white border-zinc-200'
                                    }`}
                                    style={{ left: historyContextMenu.x, top: historyContextMenu.y }}
                                >
                                    <div
                                        className={`px-3 py-1.5 text-[10px] font-medium border-b mb-1 ${
                                            theme === 'dark' ? 'text-zinc-500 border-zinc-800' : 'text-zinc-500 border-zinc-200'
                                        }`}
                                    >
                                        操作
                                    </div>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendHistoryToChat}
                                    >
                                        <MessageSquare size={14} className="text-purple-500" /> 发送到当前对话
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendHistoryToCanvas}
                                    >
                                        <CopyPlus size={14} className="text-blue-500" /> 发送到画布
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={() => {
                                            const item = historyContextMenu.item;
                                            if (!item?.url) return;
                                            // 找到所有预览节点，默认更新最近创建的一个
                                            setNodes(prev => {
                                                const previews = prev.filter(n => n.type === 'preview');
                                                if (!previews.length) return prev;
                                                const targetId = previews[previews.length - 1].id;
                                                return prev.map(n => 
                                                    n.id === targetId
                                                        ? { ...n, content: item.url, previewType: item.type === 'video' ? 'video' : 'image' }
                                                        : n
                                                );
                                            });
                                            setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
                                        }}
                                    >
                                        <Maximize2 size={14} className="text-emerald-500" /> 发送到预览窗口
                                    </button>
                                    {/* 拓展图片功能已移除 */}
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={applyHistoryToSelectedNode}
                                    >
                                        <ArrowRightSquare size={14} className={selectedNodeId ? 'text-green-500' : 'text-zinc-400'} /> 应用到选中节点
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={() => {
                                            const item = historyContextMenu.item;
                                            if (!item?.url) return;
                                            
                                            if (activeShot.nodeId && activeShot.shotId) {
                                                // 发送到选中的分镜
                                                updateShot(activeShot.nodeId, activeShot.shotId, { image_url: item.url });
                                                // 可选：添加一个小提示或动画
                                            } else {
                                                alert("请先点击分镜表中的某一行使其处于选中状态");
                                            }
                                            setHistoryContextMenu({ visible: false, x: 0, y: 0, worldX: 0, worldY: 0, item: null });
                                        }}
                                    >
                                        <LayoutGrid size={14} className={activeShot.nodeId && activeShot.shotId ? 'text-orange-500' : 'text-zinc-400'} /> 发送到当前分镜
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={() => {
                                            const item = historyContextMenu.item;
                                            if (item?.url) {
                                                // 将九宫格切割结果推到历史卡片右侧，避免遮挡列表
                                                const startX = (historyContextMenu.worldX || 0) + 340; // 侧边栏约 320px，再留 20px 间距
                                                const startY = historyContextMenu.worldY || 0;
                                                handleSplitGridFromUrl(item.url, { originX: startX, originY: startY });
                                            }
                                            setHistoryContextMenu({ visible: false, x: 0, y: 0, worldX: 0, worldY: 0, item: null });
                                        }}
                                    >
                                        <Scissors size={14} className="text-blue-500" /> 九宫格裁切
                                    </button>
                                </div>
                            )}

                            {frameContextMenu.visible && (
                                <div
                                    className={`fixed z-[110] w-48 rounded-lg shadow-2xl py-1 animate-in fade-in duration-100 border ${
                                        theme === 'dark' ? 'bg-[#18181b] border-zinc-700' : 'bg-white border-zinc-200'
                                    }`}
                                    style={{ left: frameContextMenu.x, top: frameContextMenu.y }}
                                >
                                    <div
                                        className={`px-3 py-1.5 text-[10px] font-medium border-b mb-1 ${
                                            theme === 'dark' ? 'text-zinc-500 border-zinc-800' : 'text-zinc-500 border-zinc-200'
                                        }`}
                                    >
                                        操作
                                    </div>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendFrameToChat}
                                    >
                                        <MessageSquare size={14} className="text-purple-500" /> 发送到当前对话
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendFrameToCanvas}
                                    >
                                        <CopyPlus size={14} className="text-blue-500" /> 发送到画布
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendFrameToPreview}
                                    >
                                        <Maximize2 size={14} className="text-emerald-500" /> 发送到预览窗口
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={applyFrameToSelectedNode}
                                    >
                                        <ArrowRightSquare size={14} className={selectedNodeId ? 'text-green-500' : 'text-zinc-400'} /> 应用到选中节点
                                    </button>
                                </div>
                            )}

                            {previewContextMenu.visible && (
                                <div
                                    className={`fixed z-[110] w-48 rounded-lg shadow-2xl py-1 animate-in fade-in duration-100 border ${
                                        theme === 'dark' ? 'bg-[#18181b] border-zinc-700' : 'bg-white border-zinc-200'
                                    }`}
                                    style={{ left: previewContextMenu.x, top: previewContextMenu.y }}
                                    onMouseLeave={closePreviewContextMenu}
                                >
                                    <div
                                        className={`px-3 py-1.5 text-[10px] font-medium border-b mb-1 ${
                                            theme === 'dark' ? 'text-zinc-500 border-zinc-800' : 'text-zinc-500 border-zinc-200'
                                        }`}
                                    >
                                        操作
                                    </div>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendPreviewToChat}
                                    >
                                        <MessageSquare size={14} className="text-purple-500" /> 发送到当前对话
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendPreviewToCanvas}
                                    >
                                        <CopyPlus size={14} className="text-blue-500" /> 发送到画布
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={() => {
                                            const item = previewContextMenu.item;
                                            if (item?.url) {
                                                // 检查是否有框选的节点，且数量正好是9个
                                                const currentSelectedIds = selectedNodeIdsRef.current;
                                                const hasSelectedNodes = currentSelectedIds && currentSelectedIds.size === 9;
                                                
                                                if (hasSelectedNodes) {
                                                    // 替换模式：直接替换已选中的9个节点
                                                    handleSplitGridFromUrl(item.url, { replaceSelected: true });
                                                } else {
                                                    // 创建新节点模式：在源节点旁边创建
                                                    const source = item.sourceNode;
                                                    const originX = source ? source.x + source.width + 20 : undefined;
                                                    const originY = source ? source.y : undefined;
                                                    handleSplitGridFromUrl(item.url, { originX, originY });
                                                }
                                            }
                                            closePreviewContextMenu();
                                        }}
                                    >
                                        <Scissors size={14} className="text-blue-500" /> 九宫格裁切
                                    </button>
                                </div>
                            )}

                            {inputImageContextMenu.visible && (
                                <div
                                    className={`fixed z-[110] w-48 rounded-lg shadow-2xl py-1 animate-in fade-in duration-100 border ${
                                        theme === 'dark' ? 'bg-[#18181b] border-zinc-700' : 'bg-white border-zinc-200'
                                    }`}
                                    style={{ left: inputImageContextMenu.x, top: inputImageContextMenu.y }}
                                    onMouseLeave={closeInputImageContextMenu}
                                >
                                    <div
                                        className={`px-3 py-1.5 text-[10px] font-medium border-b mb-1 ${
                                            theme === 'dark' ? 'text-zinc-500 border-zinc-800' : 'text-zinc-500 border-zinc-200'
                                        }`}
                                    >
                                        操作
                                    </div>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendInputImageToChat}
                                    >
                                        <MessageSquare size={14} className="text-purple-500" /> 发送到当前对话
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={() => {
                                            const nodeId = inputImageContextMenu.nodeId;
                                            const node = nodesMap.get(nodeId);
                                            if (!node || !node.content) return;
                                            
                                            // 检查是否有框选的节点，且数量正好是9个
                                            const currentSelectedIds = selectedNodeIdsRef.current;
                                            const hasSelectedNodes = currentSelectedIds && currentSelectedIds.size === 9;
                                            
                                            if (hasSelectedNodes) {
                                                // 替换模式：直接替换已选中的9个节点
                                                handleSplitGridFromUrl(node.content, { replaceSelected: true });
                                            } else {
                                                // 创建新节点模式：在源节点旁边创建
                                                const originX = node.x + node.width + 20;
                                                const originY = node.y;
                                                handleSplitGridFromUrl(node.content, { originX, originY });
                                            }
                                            closeInputImageContextMenu();
                                        }}
                                    >
                                        <Scissors size={14} className="text-blue-500" /> 九宫格裁切
                                    </button>
                                </div>
                            )}

                            <Lightbox 
                                item={lightboxItem} 
                                onClose={() => setLightboxItem(null)}
                                onNavigate={(newIndex) => {
                                    if (lightboxItem && lightboxItem.mjImages && lightboxItem.mjImages.length > newIndex && newIndex >= 0) {
                                        // 确保newIndex在有效范围内
                                        const validIndex = Math.max(0, Math.min(newIndex, lightboxItem.mjImages.length - 1));
                                        // 更新历史记录中的selectedMjImageIndex（只更新当前lightboxItem对应的历史项）
                                        setHistory((prev) => prev.map((hItem) => 
                                            hItem.id === lightboxItem.id 
                                                ? { ...hItem, url: lightboxItem.mjImages[validIndex], selectedMjImageIndex: validIndex } 
                                                : hItem
                                        ));
                                        // 更新lightboxItem显示
                                        setLightboxItem({ 
                                            ...lightboxItem, 
                                            url: lightboxItem.mjImages[validIndex],
                                            selectedMjImageIndex: validIndex
                                        });
                                    }
                                }}
                            />

                            <Modal isOpen={settingsOpen} onClose={() => setSettingsOpen(false)} title="模型接口配置" theme={theme}>
                                <div className="p-4 space-y-3">
                                    <div className="mb-2">
                                        <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>Global API Key（可选，全局默认 Key）</label>
                                        <div className="mt-1 flex gap-2">
                                            <input
                                                type="password"
                                                value={globalApiKey}
                                                onChange={(e) => setGlobalApiKey(e.target.value)}
                                                className={`flex-1 rounded px-2 py-1 text-xs outline-none focus:border-blue-600/50 border ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-900 border-zinc-800 text-zinc-300'
                                                        : 'bg-white border-zinc-300 text-zinc-900'
                                                }`}
                                                placeholder="如果不想每个模型单独填 Key，可以在这里填一个全局 Key"
                                            />
                                    </div>
                                    </div>
                                    <div className="mb-2">
                                        <div className="flex items-center justify-between">
                                            <div className="flex-1">
                                                <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                    即梦图生图使用本地文件
                                                </label>
                                                <p className={`text-[10px] mt-0.5 ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>
                                                    启用后，即梦模型的图生图功能将强制使用本地文件（FormData），URL图片会自动下载转换为本地文件
                                                </p>
                                            </div>
                                            <label className="relative inline-flex items-center cursor-pointer ml-3">
                                                <input
                                                    type="checkbox"
                                                    checked={jimengUseLocalFile}
                                                    onChange={(e) => {
                                                        const newValue = e.target.checked;
                                                        setJimengUseLocalFile(newValue);
                                                        localStorage.setItem('tapnow_jimeng_use_local_file', String(newValue));
                                                    }}
                                                    className="sr-only peer"
                                                />
                                                <div className={`w-11 h-6 rounded-full peer peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-500/50 ${
                                                    jimengUseLocalFile
                                                        ? 'bg-blue-600'
                                                        : theme === 'dark'
                                                            ? 'bg-zinc-700'
                                                            : 'bg-zinc-300'
                                                } peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all`}></div>
                                            </label>
                                        </div>
                                    </div>
                                    <div className="flex justify-between items-center mb-2">
                                        <span className={`text-xs ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>管理您的第三方模型接口。</span>
                                        <Button className="h-7 text-xs px-3 bg-blue-600 hover:bg-blue-500" onClick={addNewModel}><Plus size={14} className="mr-1" /> 添加模型</Button>
                                    </div>
                                    <div className="space-y-3 max-h-[50vh] overflow-y-auto custom-scrollbar pr-1">
                                        {apiConfigs.filter(api => !DELETED_MODEL_IDS.includes(api.id)).map((api) => (
                                            <div
                                                key={api.id}
                                                className={`p-3 rounded-lg border relative group ${
                                                    theme === 'dark' ? 'bg-[#18181b] border-zinc-800' : 'bg-zinc-50 border-zinc-200'
                                                }`}
                                            >
                                                {api.isCustom && (
                                                    <button
                                                        onClick={() => deleteApiConfig(api.id)}
                                                        className={`absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity ${
                                                            theme === 'dark'
                                                                ? 'text-zinc-600 hover:text-red-500'
                                                                : 'text-zinc-400 hover:text-red-500'
                                                        }`}
                                                    >
                                                        <Trash2 size={12} />
                                                    </button>
                                                )}
                                                <div className="flex items-center gap-2 mb-3">
                                                    <div className={`w-1.5 h-1.5 rounded-full ${getStatusColor(api.id)}`}></div>
                                                    <span className={`text-sm font-bold ${theme === 'dark' ? 'text-white' : 'text-zinc-900'}`}>{api.provider}</span>
                                                    <span
                                                        className={`text-[9px] font-mono px-1.5 py-0.5 rounded ml-auto border ${
                                                            theme === 'dark'
                                                                ? 'bg-zinc-900 text-zinc-500 border-zinc-800'
                                                                : 'bg-white text-zinc-500 border-zinc-200'
                                                        }`}
                                                    >
                                                        {api.type}
                                                    </span>
                                                </div>
                                                <div className="space-y-2 pl-1">
                                                    {[
                                                        { key: 'modelName', label: 'Model ID', type: 'text', placeholder: 'model-id' },
                                                        { 
                                                            key: 'key', 
                                                            label: (api.id.includes('jimeng') || api.provider?.includes('Jimeng')) ? 'Session ID' : 'API Key', 
                                                            type: 'password', 
                                                            placeholder: (api.id.includes('jimeng') || api.provider?.includes('Jimeng')) ? '粘贴Session ID...' : 'sk-...' 
                                                        },
                                                        { key: 'url', label: 'Base URL', type: 'text', placeholder: 'https://...' },
                                                    ].map((field) => (
                                                        <div key={field.key} className="grid grid-cols-4 items-center gap-2">
                                                            <label className={`text-[10px] font-medium uppercase tracking-wider text-right ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                {field.label}
                                                            </label>
                                                            <input
                                                                type={field.type}
                                                                value={api[field.key]}
                                                                onChange={(e) => {
                                                                    const newValue = e.target.value;
                                                                    updateApiConfig(api.id, { [field.key]: newValue });
                                                                    
                                                                    // 如果是jimeng模型的Session ID字段，首次粘贴后自动保存到localStorage
                                                                    if (field.key === 'key' && (api.id.includes('jimeng') || api.provider?.includes('Jimeng')) && newValue && newValue.trim().length > 0) {
                                                                        const savedSessionId = localStorage.getItem('tapnow_jimeng_session_id');
                                                                        // 如果localStorage中没有保存的Session ID，或者当前值不同，则保存
                                                                        if (!savedSessionId || savedSessionId !== newValue.trim()) {
                                                                            localStorage.setItem('tapnow_jimeng_session_id', newValue.trim());
                                                                            // 同时更新所有jimeng模型的Session ID
                                                                            setApiConfigs((prev) => prev.map((c) => 
                                                                                (c.id.includes('jimeng') || c.provider?.includes('Jimeng')) && c.key !== newValue.trim()
                                                                                    ? { ...c, key: newValue.trim() }
                                                                                    : c
                                                                            ));
                                                                        }
                                                                    }
                                                                }}
                                                                className={`col-span-3 w-full rounded px-2 py-1 text-xs outline-none focus:border-blue-600/50 border ${
                                                                    theme === 'dark'
                                                                        ? 'bg-zinc-900 border-zinc-800 text-zinc-300'
                                                                        : 'bg-white border-zinc-300 text-zinc-900'
                                                                }`}
                                                                placeholder={field.placeholder}
                                                            />
                                                </div>
                                                    ))}
                                                </div>
                                                <div className={`mt-3 pt-2 border-t flex justify-end ${theme === 'dark' ? 'border-zinc-800/50' : 'border-zinc-200'}`}>
                                                    <button
                                                        onClick={() => testApiConnection(api.id)}
                                                        disabled={apiTesting === api.id}
                                                        className={`flex items-center gap-1.5 px-2 py-1 rounded text-[10px] font-medium transition-all ${
                                                            apiStatus[api.id] === 'success'
                                                                ? 'bg-green-500/10 text-green-500'
                                                                : theme === 'dark'
                                                                    ? 'bg-zinc-800 text-zinc-400 hover:text-white hover:bg-zinc-700'
                                                                    : 'bg-zinc-100 text-zinc-600 hover:text-zinc-900 hover:bg-zinc-200'
                                                        }`}
                                                    >
                                                        {apiTesting === api.id ? (
                                                            <>
                                                                <Loader2 size={10} className="animate-spin" /> 测试中...
                                                            </>
                                                        ) : apiStatus[api.id] === 'success' ? (
                                                            <>
                                                                <CheckCircle2 size={10} /> 正常
                                                            </>
                                                        ) : (
                                                            <>
                                                                <LinkIcon size={10} /> 测试连接
                                                            </>
                                                        )}
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                    <div className={`pt-2 flex justify-end gap-2 border-t mt-3 ${theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'}`}>
                                        <Button variant="secondary" onClick={() => setSettingsOpen(false)}>关闭</Button>
                                    </div>
                                </div>
                            </Modal>
                        </div>

                        {/* 批量素材管理模态框 */}
                        {batchModalOpen && (
                            <div className="fixed inset-0 z-50 flex items-center justify-center">
                                <div 
                                    className="absolute inset-0 bg-black/50 backdrop-blur-sm"
                                    onClick={() => {
                                        setBatchModalOpen(false);
                                        setBatchSelectedIds(new Set());
                                    }}
                                />
                                <div className={`relative w-[90vw] h-[85vh] max-w-7xl rounded-lg shadow-2xl flex flex-col ${
                                    theme === 'dark' ? 'bg-[#121214] border border-zinc-800' : 'bg-white border border-zinc-200'
                                }`}>
                                    {/* 顶部栏 */}
                                    <div className={`p-4 border-b flex items-center justify-between ${
                                        theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}>
                                        <div className="flex items-center gap-4">
                                            <h2 className={`text-lg font-bold ${
                                                theme === 'dark' ? 'text-zinc-100' : 'text-zinc-900'
                                            }`}>
                                                批量素材管理
                                            </h2>
                                            <span className={`text-sm ${
                                                theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'
                                            }`}>
                                                已选中 {batchSelectedIds.size} 项
                                            </span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <button
                                                onClick={() => {
                                                    if (batchSelectedIds.size === history.length) {
                                                        setBatchSelectedIds(new Set());
                                                    } else {
                                                        setBatchSelectedIds(new Set(history.map(item => item.id)));
                                                    }
                                                }}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                        : 'bg-zinc-100 text-zinc-700 hover:bg-zinc-200'
                                                }`}
                                            >
                                                {batchSelectedIds.size === history.length ? '取消全选' : '全选'}
                                            </button>
                                            <button
                                                onClick={() => {
                                                    if (batchSelectedIds.size === 0) return;
                                                    if (confirm(`确定要删除选中的 ${batchSelectedIds.size} 项吗？`)) {
                                                        setHistory(prev => {
                                                            const filtered = prev.filter(item => !batchSelectedIds.has(item.id));
                                                            // 立即保存到 localStorage，不等待防抖
                                                            try {
                                                                localStorage.setItem('tapnow_history', JSON.stringify(filtered));
                                                            } catch (e) {
                                                                console.error('立即保存历史记录失败:', e);
                                                            }
                                                            return filtered;
                                                        });
                                                        setBatchSelectedIds(new Set());
                                                    }
                                                }}
                                                disabled={batchSelectedIds.size === 0}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors flex items-center gap-1.5 ${
                                                    batchSelectedIds.size === 0
                                                        ? theme === 'dark'
                                                            ? 'bg-zinc-800/50 text-zinc-600 cursor-not-allowed'
                                                            : 'bg-zinc-100 text-zinc-400 cursor-not-allowed'
                                                        : 'bg-red-600 text-white hover:bg-red-700'
                                                }`}
                                            >
                                                <Trash2 size={14} />
                                                批量删除
                                            </button>
                                            <button
                                                onClick={async () => {
                                                    if (batchSelectedIds.size === 0) return;
                                                    const selectedItems = history.filter(item => batchSelectedIds.has(item.id) && item.url);
                                                    if (selectedItems.length === 0) {
                                                        alert('选中的项目中没有有效的素材');
                                                        return;
                                                    }
                                                    
                                                    // 获取画布中心坐标
                                                    const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
                                                    
                                                    // 计算起始位置（稍微偏移，避免重叠）
                                                    const startX = world.x;
                                                    const startY = world.y;
                                                    
                                                    // 批量添加到画布
                                                    selectedItems.forEach((item, index) => {
                                                        const offsetX = (index % 5) * 20; // 每行5个，横向偏移
                                                        const offsetY = Math.floor(index / 5) * 20; // 纵向偏移
                                                        
                                                        let content = item.url;
                                                        if (item.type === 'video' && !isVideoUrl(content)) {
                                                            content += (content.includes('?') ? '&' : '?') + 'force_video_display=true';
                                                        }
                                                        
                                                        // 根据类型添加节点
                                                        if (item.type === 'image') {
                                                            // 尝试获取图片尺寸
                                                            (async () => {
                                                                try {
                                                                    const dims = await getImageDimensions(content);
                                                                    addNode('input-image', startX + offsetX, startY + offsetY, null, content, dims);
                                                                } catch (e) {
                                                                    addNode('input-image', startX + offsetX, startY + offsetY, null, content);
                                                                }
                                                            })();
                                                        } else if (item.type === 'video') {
                                                            addNode('video-input', startX + offsetX, startY + offsetY, null, content);
                                                        }
                                                    });
                                                    
                                                    setBatchModalOpen(false);
                                                    setBatchSelectedIds(new Set());
                                                }}
                                                disabled={batchSelectedIds.size === 0}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors flex items-center gap-1.5 ${
                                                    batchSelectedIds.size === 0
                                                        ? theme === 'dark'
                                                            ? 'bg-zinc-800/50 text-zinc-600 cursor-not-allowed'
                                                            : 'bg-zinc-100 text-zinc-400 cursor-not-allowed'
                                                        : 'bg-blue-600 text-white hover:bg-blue-700'
                                                }`}
                                            >
                                                <ArrowRightSquare size={14} />
                                                发送到画布
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setBatchModalOpen(false);
                                                    setBatchSelectedIds(new Set());
                                                }}
                                                className={`p-1.5 rounded transition-colors ${
                                                    theme === 'dark'
                                                        ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                                        : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                                }`}
                                            >
                                                <X size={18} />
                                            </button>
                                        </div>
                                    </div>
                                    
                                    {/* 内容区 - 网格布局 */}
                                    <div className="flex-1 overflow-y-auto custom-scrollbar p-4">
                                        <div className="grid grid-cols-4 gap-4">
                                            {history.map((item) => {
                                                const isSelected = batchSelectedIds.has(item.id);
                                                const displayUrl = item.mjImages && item.mjImages.length > 1 
                                                    ? (item.mjImages[item.selectedMjImageIndex || 0] || item.mjImages[0])
                                                    : item.url;
                                                
                                                return (
                                                    <div
                                                        key={item.id}
                                                        onClick={() => {
                                                            const newSet = new Set(batchSelectedIds);
                                                            if (isSelected) {
                                                                newSet.delete(item.id);
                                                            } else {
                                                                newSet.add(item.id);
                                                            }
                                                            setBatchSelectedIds(newSet);
                                                        }}
                                                        onDoubleClick={(e) => {
                                                            e.stopPropagation();
                                                            // 准备要显示的item，确保包含正确的url和selectedMjImageIndex
                                                            const displayItem = {
                                                                ...item,
                                                                url: displayUrl,
                                                                selectedMjImageIndex: item.mjImages && item.mjImages.length > 1 
                                                                    ? (item.selectedMjImageIndex || 0)
                                                                    : undefined
                                                            };
                                                            setLightboxItem(displayItem);
                                                        }}
                                                        className={`relative rounded-lg overflow-hidden border-2 cursor-pointer transition-all ${
                                                            isSelected
                                                                ? 'border-blue-500 shadow-lg shadow-blue-500/20'
                                                                : theme === 'dark'
                                                                    ? 'border-zinc-800 hover:border-zinc-700'
                                                                    : 'border-zinc-200 hover:border-zinc-300'
                                                        }`}
                                                    >
                                                        {/* 选中标记和查看按钮 */}
                                                        <div className="absolute top-2 right-2 z-10 flex items-center gap-1.5">
                                                            {isSelected && (
                                                                <div className="bg-blue-500 rounded-full p-1">
                                                                    <Check size={16} className="text-white" />
                                                                </div>
                                                            )}
                                                            {item.status === 'completed' && displayUrl && (
                                                                <button
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        // 准备要显示的item，确保包含正确的url和selectedMjImageIndex
                                                                        const displayItem = {
                                                                            ...item,
                                                                            url: displayUrl,
                                                                            selectedMjImageIndex: item.mjImages && item.mjImages.length > 1 
                                                                                ? (item.selectedMjImageIndex || 0)
                                                                                : undefined
                                                                        };
                                                                        setLightboxItem(displayItem);
                                                                    }}
                                                                    className={`p-1.5 rounded-full transition-colors backdrop-blur-sm ${
                                                                        theme === 'dark'
                                                                            ? 'bg-black/60 text-white hover:bg-black/80'
                                                                            : 'bg-white/80 text-zinc-700 hover:bg-white'
                                                                    }`}
                                                                    title="查看大图 (双击也可查看)"
                                                                >
                                                                    <Maximize2 size={14} />
                                                                </button>
                                                            )}
                                                        </div>
                                                        
                                                        {/* 缩略图 */}
                                                        <div className={`relative ${
                                                            ((item.mjImages && (item.mjImages.length === 4 || item.mjImages.length > 1)) || (item.mjNeedsSplit && item.apiConfig?.modelId?.includes('mj')))
                                                                ? (() => {
                                                                    const ratio = item.mjRatio || '1:1';
                                                                    if (ratio === '16:9') return 'aspect-video';
                                                                    if (ratio === '9:16') return 'aspect-[9/16]';
                                                                    if (ratio === '4:3') return 'aspect-[4/3]';
                                                                    if (ratio === '3:4') return 'aspect-[3/4]';
                                                                    if (ratio === '21:9') return 'aspect-[21/9]';
                                                                    return 'aspect-square';
                                                                })()
                                                                : 'aspect-video'
                                                        } ${theme === 'dark' ? 'bg-zinc-900' : 'bg-zinc-100'}`}>
                                                            {item.status === 'completed' && displayUrl ? (
                                                                item.type === 'video' || isVideoUrl(displayUrl) ? (
                                                                    <video
                                                                        src={displayUrl}
                                                                        className="w-full h-full object-contain"
                                                                        muted
                                                                        playsInline
                                                                    />
                                                                ) : (
                                                                    <img
                                                                        src={displayUrl}
                                                                        className="w-full h-full object-contain"
                                                                        alt="生成图"
                                                                        onError={(e) => {
                                                                            e.target.style.display = 'none';
                                                                        }}
                                                                    />
                                                                )
                                                            ) : (
                                                                <div className={`w-full h-full flex items-center justify-center ${
                                                                    theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'
                                                                }`}>
                                                                    {item.status === 'generating' ? (
                                                                        <Loader2 size={24} className="animate-spin" />
                                                                    ) : (
                                                                        <FileImage size={24} />
                                                                    )}
                                                                </div>
                                                            )}
                                                        </div>
                                                        
                                                        {/* 底部信息 */}
                                                        <div className={`p-2 text-xs ${
                                                            theme === 'dark' ? 'bg-zinc-900 text-zinc-300' : 'bg-zinc-50 text-zinc-700'
                                                        }`}>
                                                            <div className="truncate font-medium">{item.prompt || '未命名'}</div>
                                                            <div className="text-[10px] opacity-70 mt-0.5">
                                                                {item.modelName || '未知模型'} • {item.time}
                                                            </div>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TapnowApp />);
    </script>
</body>
</html>